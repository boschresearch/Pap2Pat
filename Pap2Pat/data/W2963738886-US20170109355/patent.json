{
    "id": "US20170109355",
    "authors": [
        "Lei Li",
        "Zihang Dai",
        "Wei Xu"
    ],
    "title": "SYSTEMS AND METHODS FOR HUMAN INSPIRED SIMPLE QUESTION ANSWERING (HISQA)",
    "date": "2016-05-23 00:00:00",
    "abstract": "Described herein are systems and methods for determining how to automatically answer questions like \u201cWhere did Harry Potter go to school?\u201d Carefully built knowledge graphs provide rich sources of facts. However, it still remains a challenge to answer factual questions in natural language due to the tremendous variety of ways a question can be raised. Presented herein are embodiments of systems and methods for human inspired simple question answering (HISQA), a deep-neural-network-based methodology for automatic question answering using a knowledge graph. Inspired by human's natural actions in this task, embodiments first find the correct entity via entity linking, and then seek a proper relation to answer the question\u2014both achieved by deep gated recurrent networks and neural embedding mechanism.",
    "sections": [
        {
            "title": "DESCRIPTION",
            "paragraphs": [],
            "subsections": [
                {
                    "title": "A. TECHNICAL FIELD",
                    "paragraphs": [
                        "The present disclosure relates generally to computing technologies, and more specifically to systems and methods for automating the answering of questions raised in natural language and improving human computer interfacing."
                    ],
                    "subsections": [],
                    "outline_long": [
                        "define technical field"
                    ],
                    "num_characters": 223,
                    "outline_medium": [
                        "define technical field"
                    ],
                    "outline_short": [
                        "define technical field"
                    ]
                },
                {
                    "title": "B. BACKGROUND",
                    "paragraphs": [
                        "Issue exists about how to automatically answer questions, such as \u201cWhere did Harry Potter go to school?\u201d Carefully built knowledge graphs provide rich sources of facts. However, it still remains a challenge to answer fact-based questions in natural language due to the tremendous variety of ways a question can be raised.",
                        "Accordingly, what is needed are systems and methods that provide more effective and accurate ways to automatically answer questions."
                    ],
                    "subsections": [],
                    "outline_long": [
                        "motivate question answering"
                    ],
                    "num_characters": 455,
                    "outline_medium": [
                        "motivate question answering"
                    ],
                    "outline_short": [
                        "motivate question answering"
                    ]
                },
                {
                    "title": "DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS",
                    "paragraphs": [
                        "In the following description, for purposes of explanation, specific details are set forth in order to provide an understanding of the invention. It will be apparent, however, to one skilled in the art that the invention can be practiced without these details. Furthermore, one skilled in the art will recognize that embodiments of the present invention, described below, may be implemented in a variety of ways, such as a process, an apparatus, a system, a device, or a method on a tangible computer-readable medium.",
                        "Components, or modules, shown in diagrams are illustrative of exemplary embodiments of the invention and are meant to avoid obscuring the invention. It shall also be understood that throughout this discussion that components may be described as separate functional units, which may comprise sub-units, but those skilled in the art will recognize that various components, or portions thereof, may be divided into separate components or may be integrated together, including integrated within a single system or component. It should be noted that functions or operations discussed herein may be implemented as components. Components may be implemented in software, hardware, or a combination thereof.",
                        "Furthermore, connections between components or systems within the figures are not intended to be limited to direct connections. Rather, data between these components may be modified, re-formatted, or otherwise changed by intermediary components. Also, additional or fewer connections may be used. It shall also be noted that the terms \u201ccoupled,\u201d \u201cconnected,\u201d or \u201ccommunicatively coupled\u201d shall be understood to include direct connections, indirect connections through one or more intermediary devices, and wireless connections.",
                        "Reference in the specification to \u201cone embodiment,\u201d \u201cpreferred embodiment,\u201d \u201can embodiment,\u201d or \u201cembodiments\u201d means that a particular feature, structure, characteristic, or function described in connection with the embodiment is included in at least one embodiment of the invention and may be in more than one embodiment. Also, the appearances of the above-noted phrases in various places in the specification are not necessarily all referring to the same embodiment or embodiments.",
                        "The use of certain terms in various places in the specification is for illustration and should not be construed as limiting. A service, function, or resource is not limited to a single service, function, or resource; usage of these terms may refer to a grouping of related services, functions, or resources, which may be distributed or aggregated.",
                        "The terms \u201cinclude,\u201d \u201cincluding,\u201d \u201ccomprise,\u201d and \u201ccomprising\u201d shall be understood to be open terms and any lists the follow are examples and not meant to be limited to the listed items. Any headings used herein are for organizational purposes only and shall not be used to limit the scope of the description or the claims.",
                        "Each reference mentioned in this patent document is incorporate by reference herein in its entirety.",
                        "One skilled in the art shall recognize that: (1) certain steps may optionally be performed; (2) steps may not be limited to the specific order set forth herein; (3) certain steps may be performed in different orders; and (4) certain steps may be done concurrently."
                    ],
                    "subsections": [
                        {
                            "title": "A. Introduction",
                            "paragraphs": [
                                "Open-domain Question Answering (QA) targets providing exact answer(s) to questions expressed as natural language, without restriction of domain. Recently, the maturity of large-scale Knowledge Graph (KG), such as Freebase, which stores extracted facts from all domains as unified triplets, offers QA systems the opportunity to infer the answer(s) using structured data. Under such circumstances, the core task of a QA system can be formulated as matching the question in natural language with informative triple(s) in KG, and reasoning about the answer(s) based on these triples.",
                                "Among all sorts of questions, there is a type of question requiring only one fact (triple) in KG as evidence to answer, which we refer as Simple Questions in this document. A typical example can be \u201cWhere was Fran Drescher born?\u201d",
                                "Though simple enough, answering such questions remains an unsolved problem. Quite the contrary, Simple Questions are the most common type of question observed in community QA sites.",
                                "In this document, inspired by human behaviors in this task, proposes embodiments of a new system for answering Simple Questions. Different from most existing approaches, which generally perform a holistic chunk generation and entity linking, embodiments of systems herein first learn to accurately identify the part of question that describes the entity of interest, just as what a person will first do faced with a new question. Based on the identified language chunk, the system searches the KG for candidate entities with alias of the same surface form. In addition, rather than training a system to disambiguate different entities directly, the relations that each entity has are utilized to decide which one is more possible to appear in the question context. Intuitively, a person disambiguates entities with the same name by recognizing what (relation) is talked about in the question and whether an entity can be mentioned that way (has the relation). Take the process of humans handling the question \u201cWhere was Fran Drescher born?\u201d as an example. Although one may have no idea who or what \u201cFran Drescher\u201d is, it can be known that it is definitely the entity of interest in this question. Then, the database can be searched for the name \u201cFran Drescher\u201d. Assuming there are two entities with this name: one entity is an author, and another one is a TV show. Since one can be quite confident that the question is asking about the place that a person was born, the author entity is chosen and the corresponding property (relation) of it may be checked.",
                                "Extensively utilizing continuous Embedding and Stacked Bidirectional Gated-Recurrent-Units-Recurrent-Neural-Network (GRU-RNN) as sub-modules in embodiments of the system, excellent performance is obtained on all sub-modules, which collectively form a powerful yet intuitive neural pipeline for simple question answering.",
                                "The rest of this document is organized as follows. After discussing previous work in section B, section C formally defines the problem and introduces embodiment of the system. Then, section D details each sub-module, followed by training techniques in section E. Details of knowledge graphs are presented in section F. Section G provides some conclusions, and section H discloses some example system embodiments."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce open-domain question answering",
                                "describe knowledge graph usage",
                                "formulate core task of QA system",
                                "introduce simple questions",
                                "propose new system for answering simple questions",
                                "outline system components"
                            ],
                            "num_characters": 3288,
                            "outline_medium": [
                                "introduce open-domain question answering",
                                "describe simple questions and their challenges",
                                "propose a new system for answering simple questions"
                            ],
                            "outline_short": [
                                "motivate open-domain question answering"
                            ]
                        },
                        {
                            "title": "B. Related Work",
                            "paragraphs": [
                                "The research of knowledge base (KB)-supported QA has evolved from earlier domain-specific QA to open-domain QA based on large-scale KGs. An important line of research has been focused on semantic parsing of questions, which transforms natural language questions into structured queries against KG. Recent progress includes using distant supervision, utilizing paraphrasing, and requiring little question-answer pairs. In contrast, another line of research has proposed to represent both questions and KG elements with continuous embeddings, and then use similarity measures to decide the best match. The main difference among several approaches lies in the model used to embed questions and KG elements. While at least one approach used simpler model (essentially a one-layer structure) to form the question embedding and the knowledge embedding, at least one other approach proposed a deep Convolutional Neural Network (CNN) to do the task. Embodiments of approaches herein fall into this category, but utilize an RNN-based model to construct the question embedding. More importantly, a novel entity linking scheme is used in embodiments. In previous works, entity linking is typically achieved by first generating all possible N-Grams from the question, and then utilizing a ranking model to rank all entities matched any generated N-Gram. In contrast, in embodiments, we first apply sequential labeling to locate the exact subject string, which significantly reduces the number candidate entities, and then take advantage of the implicate constraint between the subject and the relation to rank candidates heuristically.",
                                "From the perspective of representation learning, embodiments are also related to compositional neural embedding and continuous knowledge base embedding. The research of compositional neural embedding started from a neural probabilistic language model discussed by Baldi et al., in a technical paper entitled, \u201cExploiting the past and the future in protein secondary structure prediction,\u201d Bioinformatics, 15(11): 937-946, 1999, followed by CNN-based models, Recursive Neural Networks based models, and also RNN-based models. For continuous knowledge base embedding, the majority of works focused on the knowledge base completion task, where transformation in the embedding space can be modeled as math operations."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "discuss knowledge base-supported QA",
                                "describe semantic parsing approaches",
                                "introduce continuous embedding approaches",
                                "relate to compositional neural embedding and continuous knowledge base embedding"
                            ],
                            "num_characters": 2338,
                            "outline_medium": [
                                "discuss knowledge base-supported QA research",
                                "describe entity linking and representation learning approaches"
                            ],
                            "outline_short": [
                                "summarize existing knowledge base-supported QA approaches"
                            ]
                        },
                        {
                            "title": "C. Overview",
                            "paragraphs": [
                                "In embodiments, an externally built Knowledge Graph \u03ba is utilized, which organizes knowledge in the form of subject-relation-object triples (s, r, o), where s, o \u03b5 , are entities and r \u03b5  is a binary relation. Queries in the form of (s, r, ?) against \u03ba will return all objects oi \u03b5  such that (s, r, oi) is a valid triple in \u03ba. Therefore, answering a simple question q can be formulated as finding s \u03b5 , r \u03b5  such that the query (s, r, ?) provides exact answer(s) to the question q. Using the same example \u201cWhere was Fran Drescher born?\u201d, it can be matched to the query (fran drescher, place of birth, ?). One example Knowledge Graph is Freebase, which is publicly available.",
                                "Based on the formulation, the core of embodiments of the present system is a neural pipeline to find the best match for both s and r. In a nutshell, the system comprises two trainable modules (subject labeling and relation ranking), and one rule-based module (joint disambiguation). While the two trainable modules learn to bridge the gap between unstructured language and structured knowledge, the rule-based model makes the final decision based on earlier results. FIG. 1 summarizes an embodiment of the system. As shown in the embodiment depicted in FIG. 1, starting from (1) subject labeling, the system first generates (2) candidate subjects and then (3) rank candidate relations, whose results are then combined to perform joint (4) disambiguation and produce final (5) prediction and answer generation.",
                                "In embodiments, the pipeline starts with a trainable subject labeling system, which identifies the chunk c describing the topic subject in the question. Based on the language chunk c, the system issues a query to obtain all entities whose alias has the same surface form as the identified chunk. We term this set of entities z as candidate subjects, denoted by {tilde over (S)}. Essentially, it may be assumed that one of the correct subject's aliases should appear in the question. This assumption is reasonable because modern KGs do include most ways people mention an entity as its aliases (although it shall be noted that more complex approximate matching schemes may be used, which may improve this process). Given the assumption, if the subject labeling is correct, the correct subject must be within the candidate subjects, or formally s \u03b5 {tilde over (S)}.",
                                "In embodiments, the system will try to identify the correct relation r. Note that the system does not have to retrieve r from all possible relations R, because the obtained candidate subjects have restricted the relation search space to those connected to candidate subjects. Hence, for each candidate subject {tilde over (s)}\u03b5 {tilde over (S)}, the system queries all relations going out of the subject, denoted as R({tilde over (s)}i), and aggregates all of them into a list of candidate relations {tilde over (R)}=UiR({tilde over (s)}i). For instance, in a knowledge graph, each candidate subject represents a node and the relations represent edges connected to the candidate subject. Again, it is assured that the correct relation is within candidate relations, or formally r \u03b5 {tilde over (R)}. Then, a relation ranking system may be trained to score relations in {tilde over (R)}, where higher score indicates larger possibility to be the correct relation.",
                                "Finally, another module applies a simple and heuristic joint disambiguation based on both the candidate subjects and the relation ranking scores, which produces the final prediction of the system."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce knowledge graph \u03ba",
                                "formulate answering simple question",
                                "describe neural pipeline components",
                                "introduce subject labeling module",
                                "introduce relation ranking module",
                                "introduce joint disambiguation module",
                                "summarize system pipeline"
                            ],
                            "num_characters": 3514,
                            "outline_medium": [
                                "formulate simple question answering as a query",
                                "describe the neural pipeline for finding the best match",
                                "outline the system's modules and their interactions"
                            ],
                            "outline_short": [
                                "introduce neural pipeline for simple question answering"
                            ]
                        },
                        {
                            "title": "D. Model Embodiments",
                            "paragraphs": [
                                "1. Subject Labeling",
                                "In embodiments, the target of subject labeling is to identify of chunk of words which describe the subject of interest in the natural question. In embodiments, it is formulated as a sequential labeling problem. Essentially, for each token in the question, a binary classification of whether or not this token is part of the subject chunk is made. For completeness, the Stacked Bidirectional GRU-RNN is briefly reviewed, where the Stacked Bidirectional GRU-RNN is the core model of this module.",
                                "Firstly, Bidirectional RNNs is a modified recurrent neural networks that presents each input sequence forwards and backwards to two separate recurrent hidden layers, both of which are connected to the same output layer. As a benefit, Bidirectional RNNs are able to capture complete past and future context information for making prediction. Secondly, very similar to Long-Short Term Memory (LSTM), Gated Recurrent Unit (GRU) is special cell design for RNNs. With trainable Gates and Constant Error Carousel (CEC), GRU suffers less from the vanishing gradient problem and is able to learn long-term dependence. Compared to LSTM, GRU is able to achieve similar performance with simpler design and fewer parameters. Finally, as the depth has been shown to be crucial to the success of neural networks theoretically and empirically, adding more layers to RNNs, which take the output of previous layers as input, can improve the performance of RNNs. Among many possible ways of increasing the depth of an RNN, a widely used convention is simply to stack several layers.",
                                "In embodiments, all three ideas mentioned above may be combined to form the Stacked Bidirectional GRU-RNN. The structure is somewhat similar to the one discussed by Graves et al., in a technical paper entitled \u201cSpeech recognition with deep recurrent neural networks,\u201d Acoustics, Speech and Signal Processing (ICASSP),\u201d IEEE International Conference, pp 6645-6649, IEEE, 2013 and Huang et al., discussed in a technical paper entitled, \u201cBidirectional lstm-crf models for sequence tagging,\u201d arXiv preprint arXiv:1508.01991, 2015, except that GRU rather than LSTM is used. In the rest of the document, the Stacked Bidirectional GRU-RNN is abbreviated as S-Bi-GRU.",
                                "FIG. 2 shows the full model for subject labeling 200 (which is the same as the subject modeling 105 in FIG. 1), according to embodiment of the present disclosure, in which a sequential labeling model based on word-embedding and Recurrent Neural Networks (including basic RNN and its variations such as Bi-directional RNN, Bi-directional-LSTM, and Stacked-Bi-directional-GRU) is used to identify the subject string. In embodiments, the model comprises an embedding layer 210 which transforms the discrete input sequence into a sequence of continuous vectors (word embeddings), an S-Bi-GRU 212 which learns to produce the features for classification, and a logistic regression (binary classification) layer 214 to predict the probability of each token being part of the subject chunk based on the features produced by the S-Bi-GRU layer 212. With standard Negative Log Loss (NLL), in embodiments, the model is fully derivable and thus can be trained by Backpropagation directly.",
                                "After the model is trained, a question is fed in to get the probability of each token being part of the subject chunk. In embodiments, based on the probability, a threshold is set and all tokens whose probability is higher than the threshold is concatenated as the predicted subject string. In embodiments of the system, a relative measurement rather than the absolute threshold may be used. In embodiments, firstly, the token with the highest probability is selected, and then expand the selection to both sides until the probability decreases more than a certain percentage relative to the adjacent inner one. Empirically, this method is slightly better.",
                                "Based on the chosen subject chunk, the candidate subjects may be obtained by querying the KG for entities whose name or alias has the same surface form (i.e., same spelling). However, in embodiments, if no matched entity is founded (5%), the Freebase Suggest API is simply utilized to suggest entities using the chosen chunk. After this, there may be either one or multiple entities as candidate subject(s). For easier reference, the case with only one entity is termed as the single-subject case, and the other case with multiple entities is termed as the multi-subject case.",
                                "FIG. 3 shows a flowchart 240 of an illustrative process for subject labeling according to embodiments of the present disclosure. At step 242, an input query having one or more words is received. In the present example, the sentence \u201cwhere was Fran Drescher born?\u201d may be included in the input query. Then, at step 204, the input query may be parsed into five words 202 (where, was, Fran, Drescher and born), and each word may be input to the subject labeling model 201, which includes the embedding layer 210, stacked Bi-directional GRU-RNN 212, and logistic regression layer 214. In embodiments, the subject labeling model 201 identifies a subject chunk. In the present example, as shown in FIG. 1, the subject labeling 200 identifies \u201cFran Drescher\u201d as a subject chunk. Next, at step 206, the query having the subject chunk is sent to a knowledge base (such as knowledge graph) to get one or more candidate subject entities (or, equivalently, candidate subjects), as indicated by an arrow 109 in FIG. 1. In embodiments, the name or alias of each candidate subjects has the same surface form (i.e., spelling) as the subject chunk. In the present example, two entities (actor and TV series) are found as candidate subjects.",
                                "FIG. 4 shows the detailed process of step 244 according to embodiments of the present disclosure. At step 2442, the embedding layer 210 transforms the one or more words of the input query into one or more embeddings, where each embedding is a vector that represents the corresponding word. Then, at step 2444, the stacked-bidirectional RNN 212, to produce one or more tokens corresponding to the one or more embeddings, respectively, and binary classification features of whether each token is a part of the subject chunk or nor. Next, at step 2446, based on the classification features, the logical regression layer 214 predicts the probability of each token being a part of the subject chunk. In the present example, the five words, \u201cwhere\u201d, \u201cwas\u201d, \u201cFran\u201d, \u201cDrescher\u201d and \u201cborn\u201d, in the input question have the probabilities of 0.003, 0.002, 0.986, 0.975, and 0.103, respectively. At step 2448, some of the tokens whose probabilities are higher than a threshold may be concatenated as the subject chunk. Hereinafter, the term \u201csome of the tokens\u201d refers to one or more of the tokens. In the present example, the two tokens \u201cFran\u201d and \u201cDrescher\u201d are concatenated as the subject chunk.",
                                "2. Relation Ranking",
                                "In embodiments, the relation ranking module aims at identifying the correct relation implied by the question in natural language. In embodiments, as the name of the module suggests, instead of using classification to choose the best relation, this problem is formulated as a ranking problem. Essentially, if a candidate relation is semantically more similar to the question, it should have a higher rank. In embodiments in this disclosure, an embedding approach is taken to measure the semantic similarity between a relation and a question. Firstly, each relation r in the KG is represented as a k-dimensional continuous vector E(r). Then, for each question q, another S-Bi-GRU based model is utilized to embed it into the same k-dimensional vector space as E(q). Since both the relation and the question are represented as vectors of the same dimension, their semantic similarity can be directly computed using some distance metric. Here, we simply exploit the dot product.",
                                "FIG. 5 illustrates an example of a model 300 used to rank a candidate relation from a knowledgebase corresponding to the question, in accordance with embodiments of the present disclosure. As depicted, the embedding layer 302 embeds the words in the question to vectors. In the present example, the embedding 303a-303n are vector representations of the five words \u201cwhere\u201d \u201cwas\u201d \u201cFran\u201d \u201cDrescher\u201d \u201cborn,\u201d respectively. The final states from all layers of S-Bi-GRU based model 304 are combined to form the question embedding (or, equivalently, question vector) 308. The S-Bi-GRU has been simplified to avoid clutter. As shown in the lower half of the figure, after the S-Bi-GRU based model 304 processes the embedding sequence of the question, final-step hidden output vectors of all stacked layers are concatenated together to form a long vector 306, which is basically a neural representation of the question.",
                                "In the case of Bidirectional RNN, final-step indicates both the first step and the last step. However, since the hidden size or the number of layers of the S-Bi-GRU 304 can vary, the dimension of the long vector 306 may not be the same as that of the relation embedding, and thus cannot be directly used as the question embedding. As a solution, in embodiments, another linear projection layer 307 is added to make sure their dimensions match. Hence, the ranking score (semantic similarity score) between a question q and a relation r may be written as RS(q, r)=E(q)T E(r). In embodiments, each relation r in a KG is represented as a k-dimensional continuous vector E(r) 314. For each question q, the linear projection layer 307 projects the long vector 306 into a k-dimensional question vector E(q) 308 so that question vector E(q) 308 and the relation vector E(r) 314 have the same dimension. In embodiments, a dot product 316 between a relation vector E(r) 314 and the question vector E(q) 308 is performed to get a ranking score.",
                                "Finally, in embodiments, to train the ranking model, both positive and negative matches are needed. As positive matches come directly with the dataset, we use negative sampling to obtain the negative matches. Section E.1 of the present document explains the negative sampling method in detail. So, with both positive and negative pairs, some ranking loss can be used to train the S-Bi-GRU based model 304. In embodiments, the margin ranking loss:",
                                "L(q,r,r\u2032)=[\u03b3\u2212RS(q,r)+RS(q,r\u2032)]",
                                "is used, where r represents the positive match, r\u2032 represents the negative match, and \u03b3 is the predefined margin.",
                                "FIG. 6 shows a flowchart 340 of an illustrative process for relation ranking according to embodiments of the present disclosure. At step 342, a query including a question that has one or more words is received. Then, at step 344, the question embedding model 301 may generate a question vector E(q) 308 in a k-dimensional vector space using the input query.",
                                "At step 346, a database is queried to get the relation vectors 314 that represent candidate relations in a k-dimensional vector space. In embodiments, for each candidate subject determined in 246, the relation vectors 314 that represent all relations associated with the candidate subject are searched in the database. In the present example, as shown in FIG. 1, the candidate relations for a candidate subject, Entity-1, includes \u201cPlace of birth,\u201d \u201cNationality,\u201d \u201cParents\u201d, \u201cFilm,\u201d so on. Likewise, the candidate relations for a candidate subject, Entity-2, includes \u201cName,\u201d \u201cType,\u201d \u201cSeries\u201d, \u201cseason,\u201d so on. Then, based on the dot product between the question vector 308 and each of the relation vectors 314, the ranking score 318 of each candidate relation is determined at step 348. In embodiments, each ranking score 318 may be a scalar number and indicate a semantic similarity between the question and the corresponding relation.",
                                "FIG. 7 shows the detailed process of step 344 according to embodiments of the present disclosure. At step 3442, the embedding layer 302 transforms the one or more words of the input question into one or more embeddings 303, where each embedding is a vector representing a corresponding word. At step 3444, the S-Bi-GRU generates a vector 306 that is a neural representation of the query question. Then, at step 3446, the linear projection layer 307 projects the vector 306 into a k-dimensional vector space to get the question vector 308 if the vector 306 is not a k-dimensional vector.",
                                "Referring back to FIG. 1, each arrows 110 represents sending a query for a candidate relation to a database at step 346. In the present example, as shown in FIG. 1, the ranking score of the candidate relation \u201cPlace of birth\u201d for Entity-1 is 0.543 and the ranking score of the candidate relation \u201cNationality\u201d for Entity-1 is 0.404. In FIG. 1, relation ranking 115 show the list of relations and their ranking scores for each entity.",
                                "3. Joint Disambiguation",
                                "In embodiments, after obtaining the ranking score of candidate relations, this module is used to disambiguate candidate subjects (if there are multiple ones), and produce the final prediction of both the subject and the relation.",
                                "In embodiments, for the single-subject case, since there is nothing to disambiguate, it is straightforward to choose the only subject as the predicted one, and then the relation with the highest score to be the prediction.",
                                "In embodiments, for the multi-subject case, a heuristic based model is used to perform joint disambiguation. The core idea of the joint disambiguation is that if a relation is more semantically similar to the question, it is more probable that the correct subject will have this relation coming out of it. Conceptually, it is the semantics of the relations connected to an entity that defines the semantics of the entity. Based on this idea, the ranking scores of all relations coming out of a subject is used to decide which candidate subject is more correct. For example, the ranking score of a candidate subject {tilde over (s)} may be defined to be RS({tilde over (s)})=\u03a3{tilde over (r)}\u03b5R({tilde over (s)})RS({tilde over (r)}). However, this may be biased towards candidate subjects with more out connections. Also, relations with low scores may bring in undesired noise. Therefore, in embodiments, only the candidate relations with top-N ranking scores is considered. Here, N is a hyper-parameter to be chosen. Using Rtop({tilde over (s)}) to denote the top-N candidate relations, the ranking score of a candidate subject {tilde over (s)} can be rewritten as RS({tilde over (s)})=\u03a3{tilde over (r)}\u03b5R({tilde over (s)})RS({tilde over (r)}).",
                                "For prediction, in embodiments, the candidate subject with the highest ranking score may be predicted as the correct one, i.e.:",
                                "\\(\\begin{matrix}\n{\\hat{s} = {\\arg \ue89e{\\max\\limits_{\\overset{\\sim}{s} \\in \\overset{\\sim}{S}}\ue89e{{RS}\ue8a0\\left( \\overset{\\sim}{s} \\right)}}}} & (1)\n\\end{matrix}\\)",
                                "and then predict the correct relation as the one with the highest ranking score among all candidate relations connected to the predicted subject \u015d, i.e.:",
                                "\\(\\begin{matrix}\n{\\hat{r} = {\\arg \ue89e{\\max\\limits_{\\overset{\\sim}{r} \\in {R\ue8a0{(\\overset{\\sim}{s})}}}\ue89e{{RS}\ue8a0\\left( \\overset{\\sim}{r} \\right)}}}} & (2)\n\\end{matrix}\\)",
                                "Note that the order of prediction may be important when N\u22673, because the relation with the highest score among all candidate relations may not be connected to the predicted subject under such circumstances.",
                                "Referring to FIG. 1, as indicated by an arrow 120, the joint disambiguation is performed assuming that the hyper-parameter N is 2 for the present example. The ranking scores 130 of the candidate subjects, Entity-1 and Entity-2, are 0.947 and 0.239, respectively. Since Entity-1 has the highest ranking score, Entity-1 is predicted as the correct subject, as indicated by the arrow 125. Also, since the candidate relation \u201cPlace of birth\u201d has the highest ranking score, this relation is predicted as the correct relation.",
                                "In embodiments, based on the predicted subject and relation, a structured query is generated and sent to a KG server. Then, the KG server executes the structure query to obtain the object, i.e., answer to the question. In embodiments, the KG includes data in the format of N-Triples RDF and each RDF triple has the form (subject, relation, object).",
                                "FIG. 8 shows a flowchart 370 of an illustrative process for disambiguating candidate subjects to produce the predicted subject and relation according to embodiments of the present disclosure. At step 372, it is determined whether there is more than one candidate subject for the input query. If there is only candidate subject, the candidate subject is chosen as the predicted subject at step 374. Then, at step 376, a relation with the highest ranking score amongst all relations associated with the predicted subject is selected as the predicted relation.",
                                "If there is more than one candidate subject for the input query, the process proceeds to step 380. At step 380, for each candidate subject, the top-N ranking scores are added. Then, the candidate subject having the highest sum of the top-N ranking scores is chosen as the predicted subject. Then, the process proceeds to step 376 to select the predicted relation."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce subject labeling",
                                "formulate sequential labeling problem",
                                "review Stacked Bidirectional GRU-RNN",
                                "describe embedding layer",
                                "describe S-Bi-GRU layer",
                                "describe logistic regression layer",
                                "train model by Backpropagation",
                                "predict subject chunk",
                                "obtain candidate subjects",
                                "illustrate process for subject labeling",
                                "parse input query",
                                "input words to subject labeling model",
                                "identify subject chunk",
                                "send query to knowledge base",
                                "get candidate subject entities",
                                "illustrate detailed process of step 244",
                                "transform words to embeddings",
                                "generate tokens and classification features",
                                "predict probability of each token",
                                "concatenate tokens as subject chunk",
                                "introduce relation ranking",
                                "formulate ranking problem",
                                "represent relation as vector",
                                "embed question into vector space",
                                "compute semantic similarity",
                                "illustrate process for relation ranking",
                                "receive query",
                                "generate question vector",
                                "query database for relation vectors",
                                "determine ranking score",
                                "illustrate detailed process of step 344",
                                "transform words to embeddings",
                                "project vector into k-dimensional space"
                            ],
                            "num_characters": 17058,
                            "outline_medium": [
                                "introduce subject labeling",
                                "formulate sequential labeling problem",
                                "review Stacked Bidirectional GRU-RNN",
                                "describe model structure for subject labeling",
                                "train model using Backpropagation",
                                "predict subject chunk",
                                "obtain candidate subjects",
                                "introduce relation ranking",
                                "formulate ranking problem",
                                "describe embedding approach",
                                "compute semantic similarity",
                                "train ranking model using margin ranking loss",
                                "introduce joint disambiguation",
                                "perform joint disambiguation",
                                "predict subject and relation",
                                "generate structured query"
                            ],
                            "outline_short": [
                                "define subject labeling model",
                                "formulate subject labeling as sequential labeling problem",
                                "describe Stacked Bidirectional GRU-RNN architecture",
                                "illustrate subject labeling process with flowchart",
                                "define relation ranking model",
                                "formulate relation ranking as ranking problem",
                                "describe S-Bi-GRU based model for relation ranking",
                                "illustrate relation ranking process with flowchart"
                            ]
                        },
                        {
                            "title": "E. Training",
                            "paragraphs": [
                                "As discussed in Section D, in embodiments, the two trainable models are both full derivable and can be trained by standard (mini-batch) Stochastic Gradient Descent (SGD). However, to fully exploit the power of embodiments of the system disclosed herein, extra techniques may be used to speed up the training and improve the convergence. In this section, some training techniques are introduced that, in embodiments, improve the final performance.",
                                "1. Mini-Batch Negative Sampling",
                                "In embodiments, when training the relation ranking model, for each (q, r, r\u2032) triple, the system computes their embeddings E(q), E(r), and E(r\u2032) firstly, and then the corresponding dot products E(q)TE(r), E(q)TE(r\u2032). However, since each question can have only one positive match but thousands of negative matches, if the system simply performs the computation described above for each possible (q, r, r\u2032), it will waste a lot of resources by repetitively computing the same E(q), E(r) and E(q)TE(r). As a result, if one wants to use many (or even all) negative samples, the training time can be unfeasibly long. As more negative samples generally leads to better performance, in embodiments, it is proposed to use mini-batch negative sampling to relieve the repeated computation problem. Basically, for each positive question relation pair (q, r), instead of sampling one negative relation at a time, a mini-batch of b negative relations {r1\u2032, . . . , rb\u2032} is sampled. Then, the positive part is computed only once for b negative samples. Further, by efficient memory manipulation, the loop is transformed through different negative samples into a big dense matrix multiplication, which is more GPU-friendly. Moreover, in embodiments, this technique is combined with vectorized computation, where a mini-batch of (q, r, {r1\u2032, . . . , rb\u2032}) triples are computed in parallel. As a result, training the model with exhausted negative sampling is not only feasible but also fast.",
                                "2. AdaGrad with Momentum Schedule",
                                "As default optimization algorithm for deep neural networks, Stochastic gradient descent (SGD) has been successfully applied to different problems. However, to make good use of it, in embodiments, both the initial learning rate and the annealing schedule may be manually tuned.",
                                "In comparison, AdaGrad, which is a SGD variant, has the advantage of self-adjusting (diminishing) the learning rate based on former gradients. Hence, only the global learning rate of AdaGrad needs to be tuned, which is much easier in practice. Moreover, AdaGrad adjusts the learning rate element-wise based on the geometry of the parameter space and thus enables the model to pay special attention to less-frequent (rare) features. So, when substituting SGD with AdaGrad, both the subject labeling model and the relation ranking model can achieve better and more consistent performance stably (e.g., in experiments, performance differences between several runs were within 0.5%) performance stably.",
                                "Although AdaGrad is very powerful, it continuously decreases the learning rate based on the magnitude of previous gradients. As a result, the faster the model learns, the faster the learning rate decreases. Hence, the training usually slows down quickly. To overcome this weakness, in embodiments, combining AdaGrad with momentum is proposed, which may enable the AdaGrad to step further in the right direction accumulatively. During each parameter update, the velocity is accumulated using the adjusted gradient",
                                "\\(\\begin{matrix}\n{v_{t} = {{\\rho_{t}\ue89ev_{t - 1}} - {\\frac{\\eta}{\\sqrt{\\sum\\limits_{i = 1}^{t}\ue89e\\; \ue89eg_{i}^{2}}}\ue89eg_{t}}}} & (3)\n\\end{matrix}\\)",
                                "where gt, \u03bdt, \u03c1t are the gradient, accumulated velocity, and momentum rate at time step t, respectively, and all math operations here are element-wise. Then, the accumulated velocity is used to perform the update",
                                "\u03b8t=\u03b8t\u22121+\u03bdt\u2003\u2003(4)",
                                "where \u03b8t is the parameter at time step t.",
                                "Empirically, for the subject labeling model, combining AdaGrad with momentum gives the same performance using much shorter training time. However, for relation ranking, directly adding momentum caused the loss to oscillate dramatically from the beginning of the training. Consequently, the training loss goes down very slowly, worsening the performance. It is conjectured that this is due to the noisy gradients in the beginning. As a remedy, in embodiments, it is proposed to use momentum schedule, which disables the momentum in the beginning, and starts to increase the momentum gradually after a few epochs or when the training loss reaches a certain level. Intuitively, it is desirable to avoid those noisy gradients in the early stage and use more valid gradients later to form the momentum. In this work, this strategy is referred to as AdaGrad with momentum schedule.",
                                "Using AdaGrad with momentum schedule, a much lower training loss is achieved for the relation ranking model using the same training time, leading to 3.0%+ performance improvement on validation set.",
                                "3. Dropout",
                                "Another technique found to be helpful is to apply vertical dropout to the S-Bi-GRU. In embodiments, dropout is applied to the input signal of each Bi-GRU layer, which is denoted by dot-dash lines before the \u201cRNN\u201d components in FIG. 2. In experiments performed by the inventors, using dropout usually requires longer time for the training to converge to the same level of loss. But once it converges, the model always has better performance on validation set. Therefore, in embodiments, this is incorporated into both the subject labeling model and the relation ranking model.",
                                "4. Pretrained Word Embedding",
                                "Similar to previous observations, using pretrained word embedding helps to achieve a better performance. In experiments performed by the inventors, when the 300d Glove is used (available at nlp.stanford.edu/projects/glove/), which is an unsupervised learning algorithm for obtaining vector representations for words and developed by Stanford University, Stanford, Calif., to initialize the word embedding, the performance tends to be consistently better than that of randomly initialized embeddings.",
                                "5. Tuning Model Structure and Hyperparameters",
                                "In embodiments in this work, different settings are used for the sub-structures of the subject labeling model. Below is a guideline to train models on a practical dataset. With other datasets, similar tuning steps with slightly different hyper-parameter setting (e.g. learning rate) may be applied.",
                                "For the word embedding layer, since it uses pretrained GloVe as initialization, in embodiments, the parameters are slightly fine-tuned. Thus, in embodiments, instead of using the powerful AdaGrad with momentum, standard SGD is used with a small initial learning rate (0.001) and the learning rate (times 0.85) is annealed after each epoch. For the S-Bi-GRU, two layers with 128 cells are used in each layer. During training, in embodiments, parameters of the S-Bi-GRU and the logistic regression layer are both randomly initialized, and trained by AdaGrad (\u03b7=0.01) with momentum (\u03c1t=0.8). In addition, vertical dropout (0.5) may be applied to the S-Bi-GRU.",
                                "In embodiments, for training the relation ranking model, the same setting (i.e., the two models do not share the word embedding in this embodiment) is used for the word embedding layer as in the subject labeling model. For the S-Bi-GRU, in embodiments, a slightly larger structure is used, with two layers of 256 cells. During training, both the S-Bi-GRU and the linear projection layer may be trained by AdaGrad (\u03b7=0.005) with momentum schedule, where the momentum rate is increased by 0.3 until 0.9 after 3 epochs. In addition, in embodiments, weaker dropout (0.3) is applied to the S-Bi-GRU. In embodiments, for the relation embedding, only 128d vectors are used. During training, each relation embedding is constrained to remain within the unit-ball, i.e. \u2225E(r)\u2225<1. \u2200r\u03b5. Due to the constraint, a smaller learning rate (0.001) may be used to ensure finer search."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce mini-batch negative sampling",
                                "compute embeddings and dot products",
                                "relieve repeated computation problem",
                                "introduce AdaGrad with momentum schedule",
                                "adjust learning rate element-wise",
                                "combine AdaGrad with momentum",
                                "update parameters using accumulated velocity",
                                "introduce momentum schedule",
                                "disable momentum in early stage",
                                "increase momentum gradually",
                                "apply vertical dropout to S-Bi-GRU",
                                "use pretrained word embedding",
                                "tune model structure and hyperparameters",
                                "fine-tune word embedding layer",
                                "train S-Bi-GRU and logistic regression layer"
                            ],
                            "num_characters": 7964,
                            "outline_medium": [
                                "introduce mini-batch negative sampling",
                                "describe AdaGrad with momentum schedule",
                                "apply vertical dropout to S-Bi-GRU",
                                "use pretrained word embedding",
                                "tune model structure and hyperparameters",
                                "train subject labeling model",
                                "train relation ranking model"
                            ],
                            "outline_short": [
                                "describe mini-batch negative sampling technique",
                                "explain AdaGrad with momentum schedule optimization algorithm",
                                "discuss additional training techniques: dropout, pretrained word embedding, and hyperparameter tuning"
                            ]
                        },
                        {
                            "title": "F. Knowledge Graph",
                            "paragraphs": [
                                "In embodiments in this work, the latest Freebase dump data is used as the data source of our KG. The data dump contains more than 3B facts, where each fact is prepared in the format of N-Triples RDF. Each RDF triple has the form (subject, relation, object), just as introduced in Section A.",
                                "It shall be noted that while this section mention one example data source, namely Freebase, the present disclosure may be used on other knowledge graphs. For example, if the Freebase knowledge graph was replaced with a different language knowledge graph (such as, a Chinese language knowledge graph), and trained with question/answer pairs in that language, the resulting system would be able to answer questions in that language as well.",
                                "In embodiments, to store KGs, a graph database (such as Cayley or Virtuoso, both are open source software) is utilized, which can directly load N-Triples RDF data into its storage. In addition, Cayley can be easily queried in a Gremlin-inspired manner. Virtuoso can be easily queried in SPARQL (which is a query language for graph database specified in www.w3.org/TR/rdf-sparq1-query/ and made a standard by World Wide Web Consortium). Any other graph database with the same capability may be used as a replacement."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce knowledge graph data source",
                                "describe graph database usage"
                            ],
                            "num_characters": 1247,
                            "outline_medium": [
                                "describe knowledge graph data source and storage"
                            ],
                            "outline_short": [
                                "describe knowledge graph data source and storage"
                            ]
                        },
                        {
                            "title": "G. Some Conclusions",
                            "paragraphs": [
                                "Presented herein are embodiments of systems and methods of novel and nonobvious frameworks for simple question answering. With the unique subject labeling module, most noisy information found in previous systems is excluded and the entity linking problem is reduced to a disambiguation problem. With proper training techniques, a powerful S-Bi-GRU based ranking model may be obtained to match natural language with structured relation. Moreover, in embodiments, utilizing the underlying regularity between subject and relation, a heuristic disambiguation method achieves very competitive performance. Putting sub-modules together, embodiments of the neural pipeline outperforms previous systems on the SIMPLEQUESTIONS dataset."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "summarize system advantages"
                            ],
                            "num_characters": 726,
                            "outline_medium": [
                                "summarize system and method for simple question answering"
                            ],
                            "outline_short": [
                                "summarize system and method for simple question answering"
                            ]
                        },
                        {
                            "title": "H. System Embodiments",
                            "paragraphs": [
                                "FIG. 9 depicts an example system diagram according to embodiments of the present disclosure. As shown in the embodiment depicted in FIG. 9, the system 400 may comprise: a natural language query interface 406 to receive an input query; a preprocessor stage 408 that performs tokenization and indexing of the input query, that is, translating queries such as \u201cWhere was Fran Drescher born?\u201d into sequences of numbers where each word is mapped to an integer value according to a pre-built dictionary (the dictionary is a mapping from words or tokens into integer indices); a HISQA subject & relation model 410 according to embodiments disclosed herein (Section D); a query generator 416 that generates a structured query using a graph traversal language, such as Gremlin, according to the subject and relation found by the model in previous step; a knowledge graph server 414 interfaces with the query generator 416 and the model 410 to execute the structured query to obtain an answer (as Section F); and an answer rendering module 412 that outputs and presents the results in text or html page. In embodiments, the system 400 may also comprise a training system (which may be done offline), which may access a labeled Q/A dataset 402 to train an HISQA model 410, as discussed above (Section E). An example structured query for the example question produced by the query generator can be \u201cSELECT ?object WHERE {<entity_for_fran_drescher> <place_of_birth_for_person> ?object}\u201d.",
                                "FIG. 10 depicts an example diagram of the human inspired simple question answering (HISQA) Subject & Relation model 410 according to embodiments of the present disclosure. As depicted, an input question 449 is sent to the subject labeling model 450, where the subject labeling model 450 identifies a subject chunk that describes the topic subject of the input question. In embodiments, the question 449 may be tokenized and indexed, that is, the question, such as \u201cWhere was Fran Drescher born?\u201d may be transformed into sequences of numbers where each word is mapped to an integer value according to a pre-built dictionary. Using the subject chunk, a database 452 is queried to find one or more candidate subject entities whose names or aliased have the same surface form as the subject chunk.",
                                "The relation ranking model 454 generates a question vector using the question 449. It also finds one or more relation vectors that represent one or more relations associated with the candidate subject entities and determines ranking scores of the one or more relations by performing dot products between a question vector and the one or more relation vectors.",
                                "The joint disambiguation 456, which may be a computer software, hardware or a firmware, selects the predicted subject entity and relation among the candidate subject entities and the one or more relations. Using the predicted subject entity and relation, a database 458 is queried to find the answer 460 to the question 449.",
                                "FIG. 11 shows a flowchart 500 of an illustrative process for providing answer (or, equivalently, object) to an input query according to embodiments of the present disclosure. At step 502, an input query is received, where the input query may include a human inspired question. Then, at step 504, the subject labeling model 204 to identify the subject chunk of the query. Next, at step 506, using the subject chunk, a database is queried to find one or more candidate subjects.",
                                "At step 508, the ranking scores of the relations are generated for each candidate subject. In embodiments, the question embedding model 301 generates the question embedding 308 that may be a k-dimensional vector. For each of the candidate subject, the relation vectors 314 that correspond to all of the relations associated with the candidate subject are searched from a database. Then, for each of the candidate subject, the dot product between the relation vectors 314 associated with the candidate subject and the question embedding 308 is performed to determine the ranking scores of the relation vectors. In embodiment, for each candidate subject, the relation having the highest ranking score is identified as the correct relation for the candidate subject.",
                                "At step 510, if there are more than one candidate subjects, disambiguation of the candidate subjects is performed to select one of the candidate subject as the finally predicted subject. In embodiments, for each candidate subject, the top-N ranking scores are added. Then, the candidate subject having the highest sum of the top-N ranking scores is selected as the predicted subject. At step 512, the relation having the highest ranking score is selected amongst the relations associated with the predicted subject as the finally predicted relation.",
                                "At step 514, a database is queried to find the object associated with the predicted subject and predicted relation. In embodiments, the data in the database is organized in the form of subject-relation-object triples.",
                                "In embodiments, aspects of the present patent document may be directed to or implemented on information handling systems/computing systems. For purposes of this disclosure, a computing system may include any instrumentality or aggregate of instrumentalities operable to compute, calculate, determine, classify, process, transmit, receive, retrieve, originate, route, switch, store, display, communicate, manifest, detect, record, reproduce, handle, or utilize any form of information, intelligence, or data for business, scientific, control, or other purposes. For example, a computing system may be a personal computer (e.g., laptop), tablet computer, phablet, personal digital assistant (PDA), smart phone, smart watch, smart package, server (e.g., blade server or rack server), a network storage device, or any other suitable device and may vary in size, shape, performance, functionality, and price. The computing system may include random access memory (RAM), one or more processing resources such as a central processing unit (CPU) or hardware or software control logic, ROM, and/or other types of memory. Additional components of the computing system may include one or more disk drives, one or more network ports for communicating with external devices as well as various input and output (I/O) devices, such as a keyboard, a mouse, touchscreen and/or a video display. The computing system may also include one or more buses operable to transmit communications between the various hardware components.",
                                "FIG. 12 depicts a simplified block diagram of a computing device/information handling system (or computing system) according to embodiments of the present disclosure. It will be understood that the functionalities shown for system 600 may operate to support various embodiments of an information handling system\u2014although it shall be understood that an information handling system may be differently configured and include different components.",
                                "As illustrated in FIG. 12, system 600 includes one or more central processing units (CPU) 601 that provides computing resources and controls the computer. CPU 601 may be implemented with a microprocessor or the like, and may also include one or more graphics processing units (GPU) 617 and/or a floating point coprocessor for mathematical computations. System 600 may also include a system memory 602, which may be in the form of random-access memory (RAM), read-only memory (ROM), or both.",
                                "A number of controllers and peripheral devices may also be provided, as shown in FIG. 12. An input controller 603 represents an interface to various input device(s) 604, such as a keyboard, mouse, or stylus. There may also be a scanner controller 605, which communicates with a scanner 606. System 600 may also include a storage controller 607 for interfacing with one or more storage devices 608 each of which includes a storage medium such as magnetic tape or disk, or an optical medium that might be used to record programs of instructions for operating systems, utilities, and applications, which may include embodiments of programs that implement various aspects of the present invention. Storage device(s) 608 may also be used to store processed data or data to be processed in accordance with the invention. System 600 may also include a display controller 609 for providing an interface to a display device 611, which may be a cathode ray tube (CRT), a thin film transistor (TFT) display, or other type of display. The computing system 600 may also include a printer controller 612 for communicating with a printer 613. A communications controller 614 may interface with one or more communication devices 615, which enables system 600 to connect to remote devices through any of a variety of networks including the Internet, a cloud resource (e.g., an Ethernet cloud, an Fiber Channel over Ethernet (FCoE)/Data Center Bridging (DCB) cloud, etc.), a local area network (LAN), a wide area network (WAN), a storage area network (SAN) or through any suitable electromagnetic carrier signals including infrared signals.",
                                "In the illustrated system, all major system components may connect to a bus 616, which may represent more than one physical bus. However, various system components may or may not be in physical proximity to one another. For example, input data and/or output data may be remotely transmitted from one physical location to another. In addition, programs that implement various aspects of this invention may be accessed from a remote location (e.g., a server) over a network. Such data and/or programs may be conveyed through any of a variety of machine-readable medium including, but are not limited to: magnetic media such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROMs and holographic devices; magneto-optical media; and hardware devices that are specially configured to store or to store and execute program code, such as application specific integrated circuits (ASICs), programmable logic devices (PLDs), flash memory devices, and ROM and RAM devices.",
                                "Embodiments of the present invention may be encoded upon one or more non-transitory computer-readable media with instructions for one or more processors or processing units to cause steps to be performed. It shall be noted that the one or more non-transitory computer-readable media shall include volatile and non-volatile memory. It shall be noted that alternative implementations are possible, including a hardware implementation or a software/hardware implementation. Hardware-implemented functions may be realized using ASIC(s), programmable arrays, digital signal processing circuitry, or the like. Accordingly, the \u201cmeans\u201d terms in any claims are intended to cover both software and hardware implementations. Similarly, the term \u201ccomputer-readable medium or media\u201d as used herein includes software and/or hardware having a program of instructions embodied thereon, or a combination thereof. With these implementation alternatives in mind, it is to be understood that the figures and accompanying description provide the functional information one skilled in the art would require to write program code (i.e., software) and/or to fabricate circuits (i.e., hardware) to perform the processing required.",
                                "It shall be noted that embodiments of the present invention may further relate to computer products with a non-transitory, tangible computer-readable medium that have computer code thereon for performing various computer-implemented operations. The media and computer code may be those specially designed and constructed for the purposes of the present invention, or they may be of the kind known or available to those having skill in the relevant arts. Examples of tangible computer-readable media include, but are not limited to: magnetic media such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROMs and holographic devices; magneto-optical media; and hardware devices that are specially configured to store or to store and execute program code, such as application specific integrated circuits (ASICs), programmable logic devices (PLDs), flash memory devices, and ROM and RAM devices. Examples of computer code include machine code, such as produced by a compiler, and files containing higher level code that are executed by a computer using an interpreter. Embodiments of the present invention may be implemented in whole or in part as machine-executable instructions that may be in program modules that are executed by a processing device. Examples of program modules include libraries, programs, routines, objects, components, and data structures. In distributed computing environments, program modules may be physically located in settings that are local, remote, or both.",
                                "One skilled in the art will recognize no computing system or programming language is critical to the practice of the present invention. One skilled in the art will also recognize that a number of the elements described above may be physically and/or functionally separated into sub-modules or combined together.",
                                "It will be appreciated to those skilled in the art that the preceding examples and embodiments are exemplary and not limiting to the scope of the present disclosure. It is intended that all permutations, enhancements, equivalents, combinations, and improvements thereto that are apparent to those skilled in the art upon a reading of the specification and a study of the drawings are included within the true spirit and scope of the present disclosure. It shall also be noted that elements of the claims, below, may be arranged differently including having multiple dependencies, configurations, and combinations. For example, in embodiments, the subject matter of various claims may be combined with other claims."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce system diagram",
                                "describe natural language query interface",
                                "explain preprocessor stage",
                                "introduce HISQA subject & relation model",
                                "describe query generator",
                                "explain knowledge graph server",
                                "introduce answer rendering module",
                                "describe training system",
                                "introduce HISQA subject & relation model diagram",
                                "explain input question processing",
                                "describe subject labeling model",
                                "explain database query for candidate subjects",
                                "introduce relation ranking model",
                                "describe question vector generation",
                                "explain relation vector generation",
                                "describe ranking score calculation",
                                "introduce joint disambiguation",
                                "explain predicted subject entity and relation selection",
                                "describe answer retrieval",
                                "introduce flowchart for answer provision",
                                "describe input query reception",
                                "explain subject labeling",
                                "describe candidate subject retrieval",
                                "explain relation ranking score generation",
                                "describe disambiguation",
                                "explain predicted subject and relation selection",
                                "describe answer retrieval from database"
                            ],
                            "num_characters": 13774,
                            "outline_medium": [
                                "introduce system diagram",
                                "describe natural language query interface",
                                "describe preprocessor stage",
                                "describe HISQA subject & relation model",
                                "describe query generator",
                                "describe knowledge graph server",
                                "describe answer rendering module",
                                "describe training system",
                                "introduce HISQA subject & relation model diagram",
                                "describe subject labeling model",
                                "describe relation ranking model",
                                "describe joint disambiguation",
                                "describe process for providing answer to input query"
                            ],
                            "outline_short": [
                                "describe system diagram and components",
                                "detail HISQA subject & relation model",
                                "explain query generator and knowledge graph server",
                                "describe answer rendering module",
                                "illustrate HISQA subject & relation model diagram",
                                "outline process for providing answer to input query"
                            ]
                        }
                    ],
                    "outline_long": [
                        "introduce patent description",
                        "define invention scope",
                        "describe component representation",
                        "explain connection between components",
                        "define embodiment terminology",
                        "incorporate references by reference"
                    ],
                    "num_characters": 3271,
                    "outline_medium": [
                        "define patent application structure",
                        "describe components and connections",
                        "explain terminology and references"
                    ],
                    "outline_short": [
                        "define patent application structure"
                    ]
                }
            ],
            "outline_long": [],
            "num_characters": 0,
            "outline_medium": [],
            "outline_short": []
        }
    ],
    "claims": [
        "1. A computer-implemented method for providing an answer to a query, the method comprising:\nreceiving a query having one or more words, the one or more words including a subject chunk that describes a topic subject of the query;\nquerying a database to find at least one candidate subject, a name or an alias of the at least one candidate subject having a same surface form as the subject chunk;\nquerying a database to find one or more relation vectors that represent one or more relations associated with the at least one candidate subject;\ndetermining ranking scores of the one or more relations, each of the ranking scores indicating a semantic similarity between the query and a corresponding relation;\nselecting a relation with a highest ranking score amongst the one or more relations as a predicted relation and selecting the at least one candidate subject as a predicted topic subject; and\nquerying a database with the predicted relation and predicted topic subject to find an answer to the query.",
        "2. A computer-implemented method as recited in claim 1, further comprising:\ntransforming the one or more words into one or more embeddings, each of the embeddings being a vector representing a corresponding word;\npredicting a probability of each of the one or more embeddings being a part of the subject chunk; and\nselecting some of the one or more embeddings whose probabilities are higher than a threshold as the predicted topic subject; and\nconcatenating one or more words corresponding to the selected embeddings as the subject chunk.",
        "3. A computer-implemented method as recited in claim 2, wherein the step of predicting a probability comprises:\ngenerating one or more tokens corresponding to the one or more embeddings, respectively, and binary classification features of whether each token is a part of the subject chunk or not; and\nbased on the binary classification features, predicting a probability of each token being a part of the subject chunk.",
        "4. A computer-implemented method as recited in claim 1, further comprising:\ntransforming the one or more words into one or more embeddings, each embedding being a vector representing a corresponding word; and\nusing the one or more embeddings, generating a question vector that is a neural representation of the query.",
        "5. A computer-implemented method as recited in claim 4, further comprising:\nif a dimension of the question vector is not same as a dimension of the one or more relation vectors, projecting the question vector into a vector having a same dimension of the one or more relation vectors.",
        "6. A computer-implemented method as recited in claim 4, wherein the step of determining ranking scores of the one or more relations comprises:\nperforming dot product between the question vector and the one or more relations vectors.",
        "7. A computer-implemented method as recited in claim 1, wherein the at least one candidate subject includes multiple candidate subjects, further comprising:\ndisambiguating the multiple candidate subjects to select the predicted subject amongst the multiple candidate subjects.",
        "8. A computer-implemented method as recited in claim 7, wherein the step of disambiguating the multiple candidate subjects comprises:\nfor each candidate subject, adding top-N of the ranking scores, N being an integer number; and\nselecting a candidate subject having a highest sum of the top-N ranking scores as the predicted topic subject.",
        "9. A computer-implemented method for identifying a topic subject in a question, the method comprising:\nreceiving a query question having one or more words, the one or more words including a topic subject of the query question;\ntransforming the one or more words into one or more embeddings, each embedding being a vector representing a corresponding word;\npredicting a probability of each of the one or more embeddings being a part of the topic subject;\nselecting some of the one or more embeddings whose probabilities are higher than a threshold as the topic subject; and\nconcatenating one or more words corresponding to the selected embeddings as the topic subject.",
        "10. A computer-implemented method as recited in claim 9, wherein the step of predicting a probability comprises:\ngenerating one or more tokens corresponding to the one or more embeddings, respectively, and binary classification features of whether each token is a part of the topic subject or not; and\nbased on the binary classification features, predicting a probability of each token being a part of the topic subject.",
        "11. A computer-implemented method as recited in claim 10, wherein the step of generating one or more token are performed using at least one of basic Recurrent Neural Network (RNN), Bi-directional RNN, Bi-directional Long-Short-Term-Memory (LSTM) and stacked-Bi-directional-Gated-Recurrent-Units (GRU)-RNN.",
        "12. A computer-implemented method as recited in claim 9, wherein the threshold is determined relative to the selected highest probability.",
        "13. A computer-implemented method for providing an answer to a query, the method comprising:\nreceiving an input query having one or more words;\nusing a neural network model, identifying a subject chunk of the input query, the subject chunk describing a topic subject of the input query;\nquerying a database using the subject chunk to identify at least one candidate subject whose name or alias has a same surface form as the subject chunk;\nselecting a predicted relation amongst one or more relations associated with the at least one candidate subject and selecting the at least one candidate subject as a predicted topic subject; and\nquerying a database with the predicted relation and predicted topic subject to find an answer to the query.",
        "14. A computer-implemented method as recited in claim 13, wherein the step of identifying a subject chunk comprises:\ntransforming the one or more words into one or more embeddings, each of the embeddings being a vector representing a corresponding word;\npredicting a probability of each of the one or more embeddings being a part of the subject chunk; and\nselecting some of the one or more embeddings whose probabilities are higher than a threshold as the predicted topic subject; and\nconcatenating one or more words corresponding to the selected embeddings as the subject chunk.",
        "15. A computer-implemented method as recited in claim 14, wherein the step of predicting a probability comprises:\ngenerating one or more tokens corresponding to the one or more embeddings, respectively, and binary classification features of whether each token is a part of the subject chunk or not; and\nbased on the binary classification features, predicting a probability of each token being a part of the subject chunk.",
        "16. A computer-implemented method as recited in claim 15, wherein the step of selecting a predicted relation amongst one or more relations comprises:\nquerying a database to find one or more relations associated with the at least one candidate subject; and\ndetermining ranking scores of the one or more relations, each of the ranking scores indicating a semantic similarity between the input query and a corresponding relation; and\nselecting a relation with a highest ranking score amongst the one or more relations as the predicted relation.",
        "17. A computer-implemented method as recited in claim 16, wherein the step of determining ranking scores of the one or more relations comprises:\nquerying a database to find one or more relation vectors that represent the one or more relations, respectively;\ngenerating a question vector that represents the input query and has a same dimension as the one or more relation vectors; and\nperforming dot product between the question vector and the one or more relation vectors to determine the ranking scores of the one or more relations.",
        "18. A computer-implemented method as recited in claim 17, wherein the step of generating the question vector comprises:\ntransforming the one or more words into one or more embeddings, each embedding being a vector representing a corresponding word;\nusing the one or more embeddings and a Recurrent-Neural-Network (RNN), generating a vector that is a neural representation of the query;\nif a dimension of the vector that is a neural representation of the query is not same as a dimension of the one or more relation vectors, projecting the vector into the question vector having a same dimension of the one or more relation vectors; and\nif the dimension of the vector that is a neural representation of the query is same as the dimension of the one or more relation vectors, taking the vector as the question vector.",
        "19. A computer-implemented method as recited in claim 18, wherein the RNN includes at least one of basic Recurrent Neural Network (RNN), Bi-directional RNN, Bi-directional Long-Short-Term-Memory (LSTM) and stacked-Bi-directional-Gated-Recurrent-Units (GRU)-RNN.",
        "20. A computer-implemented method as recited in claim 16, when multiple candidate subjects are found in the step of querying a database using the subject chunk, further comprising:\nfor each of the candidate subjects, adding top-N of the ranking scores, N being an integer number; and\nselecting a candidate subject having a highest sum of the top-N ranking scores as the predicted topic subject."
    ]
}