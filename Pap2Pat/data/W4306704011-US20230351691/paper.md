# Introduction

3D point cloud representation learning is critical for autonomous driving, especially for core tasks like 3D object detection. The challenges of learning from 3D point clouds mainly come from two aspects. The first aspect is that 3D points are sparsely distributed in the 3D space due to the nature of LiDAR sensors. This forces 3D models to be different from dense models in natural language processing (where words in a sentence are dense) or image understanding (where pixels in an image are dense). The second aspect is that both the number of points in a point cloud frame and the point cloud sensing region are increasing along with the improvement of the LiDAR sensor hardware. Some of the latest commercial LiDARs can sense up to 250m [15] and 300m [44] in all directions around the vehicle, leading to a large range of point clouds.

To address these challenges, previous works have proposed many methods that can be roughly organized as five categories. PointNet [30,32,38] based method treats 3D point clouds as unordered sets and encodes them with MLPs and max pooling. Hierarchical structure is introduced to deal with the large input space and to better capture local information. These methods usually have inferior representation capacity compared with more recent methods. PointPillars-style methods [18] divide the space into grids of fixed sizes to convert the sparse 3D problem to a dense 2D problem. This method scales quadratically with the range, making it hard to scale with the advancement of LiDAR hardwares. Sparse submanifold convolutions [14,36,40] based method can handle the sparse input efficiently. Usually these methods use small 3 × 3 convolution kernels which cannot connect features that are sparsely disconnected without adding normal sparse convolution and striding. This weakness limits its representation capacity. Another weakness of this method is their need for heavily optimized custom ops to be efficient on the modern GPUs and incompatibility with matmul optimized accelerators such as TPUs. Range image is a compact representation of point cloud. Multi-view methods [50,40,43,2] run dense convolutions in this view to extract features and fuse with BEV features learned in the PointPillars-style to improve 3D representation learning. It is hard to regress 3D objects directly from the range image due to its lack of 3D information encoding in the dense 2D perspective convolutions. To tackle this weakness, graph-style kernels [4,12] replace convolutions to make use of the range information in range images to capture 3D information which greatly improves the accuracy but is still inferior to the state of the art. Transformer [41] is designed to process sequences of data. The challenge in applying it to a point cloud is to solve the quadratic complexity on the number of inputs. Recent methods tackle this problem by attending to neighboring points [29], neighboring voxels [23] or voxels in fixed windows [11]. A generic and efficient transformer-only model without limitations like limited receptive field, irregular memory access pattern, and lack of scalability is still to be designed.

In this paper, we adapt window-based Transformers to 3D point clouds. The Transformer [41] architecture has been hugely successful in modeling language sequences and image patches. In particular, on 2D images, Swin Transformer [22] proposed to partition images into windows and merge context information in a hierarchical manner. Our Sparse Window Transformer (SWFormer) builds upon similar ideas, but with several key adaptations for sparse windows. Our first adaption is to add a bucketing-based window partition for sparse windows. Although each window has the same spatial size, such as a 10×10 voxel grid, the number of non-empty voxels in each window can vary significantly, so we group these windows into buckets with different effective sequence lengths. Our second adaptation is to limit the expensive window shifting. Swin Transformer [22] uses window shifting once per Transformer layer to connect features between windows and increases receptive fields, but this shifting operation is expensive in the sparse world as it needs to re-order all the sparse features with gather operations. Moreover, it is extremely slow on matmul optimized accelerators such as TPUs. To address this issue, SWFormer employs a new hierarchical backbone architecture, where each SWFormer block has many Transformer layers but only one shifting operation, as shown in Figure 3. It relies on multi-scale features to achieve large receptive fields for context information, and a multi-scale fusion network to effectively combine these features. The model uses additional custom downsample and upsample algorithms to properly handle the sparse features during feature fusion.

Our innovation continues from the backbone into the 3D object detection head. Existing 3D object detection methods [51,18,50,43,13,36,4,40,24,46] can mostly be viewed as either anchor based methods with implicit or explicit anchors or DETR [3] based methods [26]. The detection performance is closely related with the distribution of the difference between anchor and groundtruth. Methods with inaccurate anchors [4,24] have poor performance in detecting large objects such as vehicles though they can have reasonable performance on pedestrians. One way to solve this problem is to have a two-stage model to refine the boxes [24,36] which greatly improves the detection accuracy. CenterNetstyle detection methods [13,46,40] strive to define anchors in the center of the groundtruth boxes only which enforces distributions of closer to zero mean and smaller variance. However, when detecting objects directly from sparse features (e.g. features from PointNet, Submanifold convolutions, sparse Transformers), there are not necessarily features close to the object centers. To alleviate this issue, [40] applies normal sparse convolutions to insert points in the convolution output; [11] scatters the sparse features to a dense BEV grid and runs dense convolutions to expand features to missing positions. These methods are expensive. In this paper, we propose a voxel diffusion module to address this issue efficiently in a scalable way by segmenting and diffusing foreground voxels to their nearby regions as described in §3. 4.

Extensive experiments are conducted on the challenging Waymo Open Dataset [39] to show state of the art results of SWFormer on 3D object detection. We summarize our contributions as follows:

-We propose a hierarchical Sparse Window Transformer (SWFormer) backbone for 3D representation learning. Its flexible receptive fields and multiscale features make it suitable for different self-driving tasks like object detection and semantic segmentation. -We propose a generic voxel diffusion module to address the unique challenge of anchor placement in 3D object detection from sparse features. -We conduct extensive experiments on Waymo Open Dataset [39] to demonstrate the state of the art performance of our SWFormer model.

# Related Work

## 3D object detection

As one of the most important tasks in autonomous driving, 3D object detection has been extensively studied in prior works. Early works like PointNet [30] and PointNet++ [32] directly apply multilayer perceptions on individual points, but it is difficult to scale them to large point clouds with good accuracy. The current mainstream 3D object detectors often convert point clouds into bird eye view 3D [51] or 2D voxels [18] (2D voxels are also referred as pillars), where each voxel aggregates the information from points it contains. In this way, regular 2D or 3D convolutional neural networks can be applied to process these bird-eye-view representations. The pseudo image of voxels also makes it easier to reuse the rich research advancements in 2D object detection, such as two-stage or anchorbased detection heads [46]. The downside is that the pseudo image of voxels grows cubically/quadratically with the voxelization granularity and detection range, not to mention that many of the voxels are effectively empty. Therefore, another type of approach is to perform 3D object detection without voxelization. This includes methods that detect objects from the perspective view [25,4,12], or lookup nearest neighbors for each point [28]. However, the detection accuracy is typically inferior to the voxelization route.

To have the best of both worlds, recent approaches [45,40,36] start to explore multi-view approaches and make use of sparse convolutions on the voxelized point cloud. For example, the recent range sparse net (RSN [40]) adopts a twostep approach, where the first step performs class-specific segmentation on the range image view, and the second step applies sparse 3D convolutions on the voxel view for specific classes. However, submanifold sparse convolutions cannot connect features that are sparsely disconnected without adding normal sparse convolutions and striding, and they often require heavily optimized customized ops to be efficient on modern accelerators.

Our work aims to learn the 3D representations from sparse point clouds without using any dense or sparse convolutions. Instead, we resort to a hierarchical Transformer to achieve our goal.

## Transformers

Transformers [41] have shown great success in natural language processing [7]. Recently, researchers have brought this architecture to computer vision [1,33,42,6]. ViT [9] partitions images into patches, which greatly advanced the use of Transformers for image classification. Swin Transformer [22] further demonstrated better ways to fuse contextual information through window shifting and hierarchy, and also generalized to other tasks such as segmentation and detection.

Interestingly, Transformers are naturally suitable for sparse point clouds, because they can take any length of sequences as inputs and do not require dense 2D/3D image representations. Therefore, recent works have attempted to adopt Transformers for 3D representation learning, but they are primary developed for object scans and indoor applications [47,10,27,29]. Voxel Transformer [24] is the submanifold sparse convolution [14] counterpart in the Transformer world, by replacing the convolution kernel with attention. Its irregular memory access pattern is computationally inefficient, and its accuracy is worse than state of the art methods. Recently, SST [11] proposes a single-stride transformer for 3D object detection and achieved impressive results on Waymo Open Datasets especially for pedestrian object detection. However, due to its single stride nature, SST has a limited receptive field and thus has difficulty dealing with large objects, making it ineffective in important tasks like large vehicle detection, large object segmentation (e.g. buildings), lane detection, and trajactory prediction. It needs to scatter features to a dense BEV grid to run several dense convolutions which limits its scalability. It is also computationally expensive as it needs to run many layers of transformers on the high resolution feature map which limits its applications in realtime systems.

Our work is inspired by window-based Transformers (e.g., SwinTransformer [22]) in the sense that we also adopt the hierarchical window-based Transformer backbone, but to address the unique challenges of 3D sparse point clouds, we propose several novel techniques such as the improved SWFormer blocks, multi-scale feature fusion, and voxel diffusion.

# Sparse Window Transformer

## Overall Architecture

SWFormer is a pure Transformer-based model without any convolutions. Figure 1 shows the overall network architecture: given a sequence of point cloud frames as inputs, each point is augmented with per-frame voxel features [18] and an auxiliary frame timestamp offset [40]. It uses dynamic voxelization [50] and a point net [18,30] based feature embedding net to get sparse voxel features. Note, our voxels are also referred as pillars in other works [18]. These sparse voxels are then processed by a hierarchical sparse window Transformer network described in §3.2. The resulting multi-scale features are then fused with a Transformer based feature fusion blocks. To address the unique challenge of detecting 3D boxes from sparse features, we first segment the foreground voxels and then apply a voxel diffusion module to expand foreground voxels to neighboring locations with pseudo voxels. In the end, we apply a center net [46,40,49] style detection head to regress 3D boxes.

## Hierarchical Sparse Window Transformer Encoder

A key concept of our SWFormer is the sparse window in the birds eye view. After points are converted to a grid of 2D voxels on bird eye view, the voxel grid is further partitioned into a list of non-overlapping windows with fixed size H × W (e.g., 10 × 10), similar to Swin Transformer [22]; however, since points are often sparse, many voxels are empty with no valid points. Therefore, the number of non-empty voxels in each window may vary from 0 to HW . As we will explain later, all non-empty voxels within the same window will be flattened to a single variable-length sequence and fed into Transformer layers. In practice, these variable-length sequences prevent us from batch training, causing lower training efficiency. To solve this issue, we borrow a widely used ideas from natural language processing [41,8] and recent works [11], which group these sparse windows into different buckets based on their sequence lengths. Concretely, we divide sparse windows into at most k buckets {B 0 , B 1 , ..., B k }, where windows in B i are always padded to a maximum sequence length of HW/2 i . All padded tokens are masked in Transformer layers.

Based on the aforementioned sparse windows, our encoder adopts hierarchical Transformers to process the inputs and produce a list of multi-scale BEV features. As shown in Figure 1, each scale starts with a sparse window partition layer followed by a multi-layer SWFormer block.

Sparse Window Partition: We divide the BEV voxels into non-overlapping windows with fixed size H×W , which are then grouped into buckets {B 0 , B 1 , ..., B k }. For each bucket B i , we flatten all voxels within the same window into a sequence and zero-pad the sequence length to HW/2 i . These sequences are then batched and fed to the Transformer blocks, where the self-attention shares the keys and values for all query voxels coming from the same window [22]. Since SWFormer processes inputs in a hierarchical fashion with multiple feature scales, we need to apply strided window partitions at the beginning of each scale. The strided window partition is similar to traditional strided convolutions, except that it always picks the closest voxel to the center of the window with deterministic rules to break ties. Notably, no max or average pooling operations are applied because they are not friendly to sparse implementations. Figure 2 illustrates an example of a stride-4 window partition.

Sparse Window Transformer block: Transformer [41] is inherently suitable for sparse point clouds, as it does not require the dense 2D/3D inputs as in convolutional networks; unfortunately, due to the quadratic complexity of selfattention with respect to the input sequence length, it is prohibitively expensive to feed the whole point cloud (with millions of points) or voxel features (with tens of thousands valid voxels) as a single input sequence to Transformer. In this

Fig. 2. Strided Sparse Window Partition. Left shows a grid of 16x16 BEV voxels, where grey voxels are empty and others are non-empty. Right shows the results of stride-4 window partition, leading to a grid of 4x4 voxels. For each striding window, it picks the nearest neighbor non-empty voxel feature (light green) from the center (black dot) with any deterministic rule to break ties; if all voxels are empty in the striding window, then the corresponding voxel after striding is also empty. Best viewed in color. paper, we adopt the idea of Swin Transformer [22]: the sparse BEV voxels are first partitioned into windows, and Transformer is applied to each window separately. To increase the receptive field and connect the features across windows, SwinTransformer uses a window shifting technique to re-partition the window for every layer of Transformer. However, as we are operating on sparse voxel features, such shift-window operation is memory-read/write intensive, especially for matrix-optimized accelerators like TPUs. To alleviate this problem, we propose to limit the shift-window operation to once per stride rather than per layer. Figure 3 shows the detailed architecture of a SWFormer block: it largely follows the same style of SwinTransformer to perform self-attention within a local window, except it only performs shift-window operation once in the middle. Formally, our SWFormer block can be described as follows:

where x is the input features after sparse window partition, mask z is the mask for input padding, PE z is the positional encoding. The process contains two stages:

(1) the first stage applies N Transformer layers to z 0 and output z N . Each Transformer layer consists of a standard multi-head self-attention (MSA) and multilayer perceptron (MLP), but slightly different from the standard version, here we adopt the post-norm scheme where layer norm (LN) is added after MSA and MLP. For simplicity, we use the standard sine/cosine absolute positional encoding in this paper. (2) The second stage first applies window-shift to z N , and adds the updated mask u and positional encoding PE u based on z N ; afterwards, M Transformer layers are added to process u 0 and generate the final output u M . Notably, each SWFormer block has N + M Transformer layers but only one window-shift operation. By restricting window-shift operations, our SWFormer block is more efficient than the conventional Swin Transformer; however, it also limits the receptive field, since each Transformer layer is only applied to a small window. To address this challenge, SWFormer is designed as a hierarchical network with multiple scales, where the strides are gradually increased: for simplicity, this paper uses strides {1, 2, 4, 16, 32} for the five scales. For each scale, we always keep the window size fixed (e.g., 10 × 10); however, as the later scales have larger strides, the same window in later scales will cover much larger area. As an example, for the last scale with stride 32, a 10 × 10 window would cover 320 × 320 area on the original BEV voxel grid, and a single window-shift would connect all features within an area as large as 480 × 480.

## Multi Scale Feature Fusion

Inspired by feature pyramid network (FPN [20]), SWFormer adopts Transformerbased multi-scale feature network to effectively combine all features from the hierarchical Transformer encoder. Figure 4 shows the overall architecture of the feature network: given a list of encoder features {P 0 , P 1 , ..P 5 }, it iteratively fuses (P i+1 , P i ) from large-stride P 5 to small-stride P 0 . Formally, our feature fusion process can be described as:

P i P i+1 Starting from the last feature map P 5 , we first upsample it to have the same stride as P 4 such that they can be concatenated into a single feature map; afterwards, we simple apply a 1-layer SWFormer block to process the concatenated feature and generate the new P4 . The process is iterated until all fused features { P0 , ..., P5 } have been generated, which have the same strides as {P 0 , ..., P 5 } features. The fused features are further used in voxel diffusion and box regression as described in the following sections. One challenge in sparse upsamping is that one cannot naively duplicate the feature to all upsampled locations (like commonly done in dense upsampling), which will cause unnecessary excessive feature duplication and significantly reduce the sparsity. In this paper, we restrict features in P i+1 to only duplicate to locations that have nonempty features in P i , as shown in Figure 4. In this way, we can ensure Pi has the same sparsity as P i .

## Voxel Diffusion

Diffusion 0.9 0.5 Fig. 5. Voxel Diffusion. After foreground segmentation, each voxel receives a segmentation score s ∈ [0, 1]. All voxels with scores greater than a threshold γ = 0.05 are scattered to a dense BEV grid, and then we apply a k × k max pooling on the dense BEV grid to expand valid voxel features to their neighboring locations where k is set to 5 in this example. (Left) before diffusion, there are only two foreground voxels with segmentation scores {0.5, 0.9} greater than γ; (Right) after voxel diffusion, 47 voxels become valid. Best viewed in color.

To detect 3D objects from sparse voxel features, a unique challenge is that there might be no valid voxel feature near object centers which are the best positions to place implicit [46] or explicit anchors [34]. Prior works have attempted to resolve this issue by: 1) second-stage box refinement [36], 2) sparse convolutions [40] or coordinate refinement [29] that can expand features to empty voxels close to the object centers, 3) scattering sparse voxel features to dense and applying dense convolutions [11]. In this paper, we propose a novel voxel diffusion module to effectively and efficiently address this challenge.

Voxel diffusion is based on two simple ideas: First, we segment all foreground voxels by jointly performing foreground/backgrond segmentation, thus effectively filtering out the majority of background voxels. Second, we expand all foreground voxels by zero-initializing their features into neighboring locations with a simple k × k max pooling operations on the dense BEV grid, where k is the detection head specific diffusion factor to control the magnitude of expansion. The diffused voxel features are further connected and processed with a few Transformer layers. Combining these two ideas, we can simultaneously keep voxel features sparse (by filtering out background voxels) and features filled (by voxel diffusion) for voxels closer to the object center. Figure 5 illustrates an example of voxel diffusion.

Our foreground segmentation is jointly trained with object detection. Specifically, for each voxel, we assign a binary groundtruth label: 0 (background, voxel does not overlap with any objects) and 1 (foreground, voxel overlaps with at least one object). The foreground segmentation is trained with a two-class focal loss [21] for each object class c:

where N is the total number of valid voxels and L i is the focal loss for voxel i. At inference time, we keep voxels as foreground if their foreground scores are greater than a threshold γ.

## Box Regression

SWFormer follows [40] to use a modified CenterNet [49,13,40,46] head to regress boxes from voxel features. The heatmap loss is computed as a penalty-reduced focal loss [49,21] per object class.

where hi and h i are the predicted and ground truth heatmap values for object class c respectively at voxel i. N is the number of boxes in class c. We use = 1e -3, α = 2 and β = 4 in all experiments, following [49,19,40]. SWFormer parameterize 3D boxes as b = {d x , d y , d z , l, w, h, θ} where d x , d y , d z are the box center offsets relative to the voxel centers. l, w, h, θ are box length, width, height and box heading. We follow [40] to apply a bin loss [38] to regress heading θ, smooth L1 to regress other box parameters, and an IoU loss [48] to improve overall box accuracy on the voxels with ground truth heatmap values above a threshold δ 1 .

where bi , b i are the predicted and ground truth box parameters respectively, θi , θ i are the predicted and ground truth box heading respectively. The net is trained end to end with the total loss defined as

When decoding prediction boxes, we first filter voxels with heatmap less than a threshold δ 2 , then run max pool on the heatmap to select boxes corresponding to the local heatmap maximas without any non-maximum-suppression.

# Experiments

We describe the SWFormer implementation details, and demonstrate its efficiency and accuracy in multiple experiments. Ablation studies are conducted to understand the importance of various design choices.

## Waymo Open Dataset

Our experiments are primary based on the challenging Waymo Open Dataset (WOD) [39], which has been adopted in many recent state of the art 3D detection methods [36,46,40,11,31]. The dataset contains 1150 scenes, split into 798 training, 202 validation, and 150 test. Each scene has about 200 frames, where each frame captures the full 360 degrees around the ego-vehicle. The dataset has one long range LiDAR with range capped at 75 meters, four near range LiDARs and five cameras. SWFormer uses all five LiDARs in the experiments.

## Implementation Details

We normalize intensity and elongation in the raw point cloud with the tanh function.The dynamic voxelization uses 0.32m voxel size in x, y and infinite size in z. During training, we ignore all ground truth boxes with fewer than five points inside. The voxel feature embedding net has two layers of MLPs with channel size of 128. All of the transformer layers have channel size of 128, 8 heads, and inner MLP ratio of 2. We also use stochastic depth [16] with survival probability 0.6. The segmentation cutoff γ in §3.4 is set to 0.05. The heatmap threshold δ 1 , δ 2 are set to 0.2, 0.1 respectively for both vehicle and pedestrian heads. For training efficiency, we cap the number of regression targets in each frame by 1024 for vehicle and 800 for pedestrian sorted by ground truth heatmap values. λ 1 , λ 2 are set to 200 and 10 in Eq. 10.

Data augmentation. We have adopted the several popular 3D data augmentation techniques described in [5] during training: randomly rotating the world by yaws uniformly chosen from [-π, π] with probability 0.74, randomly flipping the world along y-axis with probability 0.5, randomly scaling the world with scaling factor uniformly chosen within [0.95, 1.05), randomly dropping points with probability of 0.05.

Training and Inference. The SWFormer models are trained end-to-end with 32 TPUv3 cores using the Adam optimizer [17] for a total number of 128 epochs with an initial learning rate set to 1e-3. We apply cosine learning rate decay and 8 epoch warmup with initial warmup learning rate set to 5e-4.

## Main Results

We measured the detection results using the official WOD detetion metrics: BEV and 3D average precision (AP), heading error weighted BEV, and 3D average precision (APH) for L1 (easy) and L2 (hard) difficulty levels [39]. The official metrics used to rank in the leaderboard uses IoU cutoff of 0.7 for vehicle, 0.5 for pedestrian. We report additional AP results at IoU of 0.8 for vehicle, 0.6 for pedestrian. Large vehicles that have max dimension greater than 7 meters are also reported. Table 1 reports the main results on validation set, Table 2 reports additional results for high IoU and large vechiels on the validation set, and Table 3 shows the test set results by submitting our predictions to the official test server. Results from methods with test time augmentation or emsemble are not included.

As shown in Table 1, SWFormer achieves new state-of-the-art results for vehicle detection on the WOD validation set: it has 1.5 APH/L2 higher than the prior best single-stage model RSN [40]. SWFormer even outperforms the prior best performing two-stage method PVRCNN++ [37] by 0.42 APH/L2. Importantly, SWFormer performs very well at detecting large vehicles, 6.35 AP/L2 higher than the prior art of RSN [40] as shown in Table 2. SWFormer slightly outperforms the state of the art single stage method SST 3f [11] by 0.12 APH/L2. Notably, the single frame single stage SWFormer 1f also outperforms all prior single frame methods.

We have compiled the model with XLA [35] and ran inference for the 15th frame in scene 8907419590259234067 1960 000 1980 000 that has 68 vehicles and 69 pedestrians on a Nvidia T4 GPU. The latency is 43ms, more efficient than the popular realtime detector PointPillars [18] which takes about 100ms on the same GPU with our own implementation. With fused transformer GPU kernels and optimized GPU sparse window partition operations, the latency can be further reduced to 20ms.

Table 3 shows vehicle and pedestrian detection result comparison with published results on the WOD test set, which shows SWFormeroutperforms all previous single-stage or two-stage methods on the official ranking method mAPH/L2.   Window shifting is introduced in SwinTransformer [22] to connect the features among windows. We have limited its usage to one per scale. What happens if we completely remove it? Table 5 shows clear accuracy drop especially on vehicles if the window-shift operations are removed from the SWFormer blocks. This meets our intuition that it is important to keep one window shift operation per scale to make sure every voxel gets the similar receptive field in all directions.

# Conclusion

This paper presents SWFormer, a scalable and accurate sparse window transformeronly model, to effectively learn 3D point cloud representations for object detection. Built upon window-based Transformers, it addresses the unique challenges brought by the sparse 3D point clouds, and proposes a bucketing-based multiscale Transformer neural network. SWFormer takes full advantage of the sparsity of point clouds, and can effectively processes sparse windows of point clouds using pure Transformer layers without any convolutions. It also proposes a novel voxel diffusion module to further detect 3D objects from sparse features. Experiments show state-of-the-art results on the challenging Waymo Open Dataset.

# A Window Shift

The window shift operation (Figure 6) is implemented by adding offsets of half of the window sizes to the voxelized coordinates and then running the same window partition algorithm. We have proposed to limit the window shift operation per scale for efficiency of processing sparse inputs. We wondered what happens if we add more window shifts to the model. Will it impact model accuracy? We added one more window shift to the scale 1 and scale 2 respectively. It has slowed down our training by 10%. Surprisingly, it slightly decreased the model accuracy as shown in Table 6. Our hypothesis is that more shifts make the model harder to train when we do not need to rely on window shifts to increase receptive field.  

# B Qualitative Results

Figure 7 visualizes ground truth boxes, detected boxes, and attention scores for layers selected from different scales for the 15th frame in scene 8907419590259234067 1960 000 1980 000 selected from the Waymo Open Dataset validation set. The selected layers are the stride 1, 2 afters multi-scale feature fusion, and stride 1, 2, 4, 16 from the main backbone. We use all foreground points as the query points. The predicted boxes almost overlap perfectly with the ground truth boxes. The attention score pattern shown in these subplots indicates that different information is captured in different layers and scales. Interestingly, we have found that most of the attention scores are either 0 or 1 for foreground query points. We hope that these findings can inspire more research in the future.

C Future Work: More Tasks Waymo Open Dataset [39] has recently added semantic segmentation labels for about 14% of the frames per scene for all of the 1150 scenes. We have extended the SWFormer detection network to perform joint semantic segmentation and detection. Figure 8 illustrates the joint detection and semantic segmentation network architecture. We concatenate the per-point feature from the voxel embedding net before per-voxel max pooling and its corresponding voxel feature from a selected scale after multi-scale feature fusion to predict the per-point semantic segmentation logits. Without much tuning, we have obtained reasonable semantic segmentation results as shown in Table 7 and Figure 9. We plan to further improve this model and extend it to more autonomous driving related tasks.  

