{
    "id": "https://semopenalex.org/work/W4376626943",
    "authors": [
        "Jonas Janneck",
        "Anselme Tueno",
        "David Boehm"
    ],
    "title": "A Method for Securely Comparing Integers using Binary Trees",
    "date": "2023-07-01",
    "abstract": "In this paper, we propose a new protocol for secure integer comparison which consists of parties having each a private integer. The goal of the computation is to compare both integers securely and reveal to the parties a single bit that tells which integer is larger. Nothing more should be revealed. To achieve a low communication overhead, this can be done by using homomorphic encryption (HE). Our protocol relies on binary decision trees that is a special case of branching programs and can be implemented using HE. We assume a client-server setting where each party holds one of the integers, the client also holds the private key of a homomorphic encryption scheme and the evaluation is done by the server. In this setting, our protocol outperforms the original DGK protocol of Damg\u00e5rd et al. and reduces the running time by at least 45%. In the case where both inputs are encrypted, our scheme reduces the running time of a variant of DGK by 63%.",
    "sections": [
        {
            "title": "INTRODUCTION",
            "paragraphs": [
                "Multi-party computation (MPC) is a cryptographic technique that allows several parties to compute a function on their private inputs without revealing any information other than the function's output [5,21,[27][28][29]. A classic example in the literature is the so-called Yao's Millionaire's problem introduced in [53]. Two millionaires are interested in knowing which of them is richer without revealing their actual wealth. Formally, let there be two parties \ud835\udc43 1 , \ud835\udc43 2 with private input \ud835\udc65, \ud835\udc66 respectively. The goal of the computation is to compute and reveal \ud835\udc4f = [\ud835\udc65 \u2265 \ud835\udc66] to the parties and nothing else. This is illustrated in Figure 1.",
                "Integer comparison is one of the basic arithmetic operations in computer programming and algorithm design. Secure integer comparison is therefore necessary in many privacy-preserving computations. In machine learning, private integers must be compared securely while evaluating classifiers such as decision trees [42,45,46,51] or neural networks. In secure enterprise benchmarking [48], key performance indicators are securely compared to determine how companies perform compared to their competitors. In secure auction [8,9], bids are privately compared to determine the winner. Secure integer comparison has application in different privacy-preserving analytics.",
                "In the following, the party with input \ud835\udc65 is the client and the party with input \ud835\udc66 is the server. The idea of our solution consists of having the server construct a binary tree that represents \ud835\udc66. Then, the client encrypts \ud835\udc65 using a homomorphic encryption scheme and let the server evaluate on the tree representing \ud835\udc66. Finally, the client receives the result of the computation and decrypts it. Depending on the use case, the client can send the result to the server or they could both get a share of the final result. Furthermore, there are two variants of the protocol. The first (basic) variant utilizes the input of the server in plaintext, the second variant requires both inputs to be encrypted. We compare our results of the first variant to the original DGK protocol [18] and reduce the running time by 45%. Compared to an optimization of the DGK protocol proposed by Veugen [49], we can reduce the running time by about 10% for the first variant. However, for the second variant in which both inputs are encrypted we achieve a reduction of more than 63%.",
                "In total, our contributions are: We propose a new protocol for secure integer comparison based on binary trees. We present two instantiations of our protocol using FHE and AHE. We extend our protocol to handle shared output bit, encrypted inputs and less than comparison. We give a theoretical analysis including specifications for the two variants and their complexity implications. We implement and evaluate both variants.",
                "The remainder of the paper is structured as follows. We review preliminaries in Section 2 and related work in Section 3. Section 4 defines correctness and security of the functionality. We describe our protocol and its algorithms in Section 5 and present some extensions in Section 6. Section 8 gives details about our implementation and evaluation results."
            ],
            "subsections": []
        },
        {
            "title": "PRELIMINARIES",
            "paragraphs": [
                "Homomorphic encryption (HE) allows computations on ciphertexts by generating an encrypted result whose decryption matches the result of a function on the plaintexts [12,25]. HE Algorithms. An HE scheme consists of the following algorithms:",
                "\u2022 pk, sk, ek \u2190 KGen(\ud835\udf06): This probabilistic algorithm takes a security parameter \ud835\udf06 and outputs public, private, and evaluation keys pk, sk, and ek. \u2022 c \u2190 Enc(pk, m): This algorithm takes pk and a message m and outputs a ciphertext c. We will use \ud835\udc5a as a shorthand notation for Enc(pk, m). We require IND-CPA security and the following correctness conditions. Given any set of \ud835\udc5b plaintexts m 1 , . . . , m \ud835\udc5b , it must hold for any pk, sk, ek:",
                "\u2022 Dec(sk, Enc(pk, m \ud835\udc56 )) = Dec(sk, m \ud835\udc56 ) = m \ud835\udc56 ,",
                "\u2022 Dec(sk, Eval(ek, \ud835\udc53 , m 1 , . . . , m \ud835\udc5b )) = Dec(sk, \ud835\udc53 (m 1 , . . . , m \ud835\udc5b ) ).",
                "In practice, a homomorphic encryption defines two basic operations for addition and multiplication that can then be used to compute larger functionalities. FHE Operations. An FHE scheme defines both operations (addition and multiplication). For all plaintexts m 1 , m 2 , we define the following operations and introduce shorthand notations:",
                "\u2022 Addition:",
                "Additively HE. If the scheme supports only addition, then it is called additively HE (AHE). Schemes such as Paillier [41] or Elliptic Curve ElGamal [33] are additively homomorphic and have the following properties for all integer plaintexts m 1 , m 2 and bit plaintexts \ud835\udc4e, \ud835\udc4f \u2208 {0, 1}:",
                "\u2022 Xor: Xor( \ud835\udc4e , \ud835\udc4f) = \ud835\udc4e \u2295 \ud835\udc4f .",
                "Note that we use the same shorthand notation for FHE and AHE. The actual implementation depends on the underlying scheme.",
                "Somewhat, Leveled and Fully HE. If the scheme supports addition and multiplication, but for a limited number of times, then it is somewhat homomorphic (SHE). When arbitrary computation can be performed on encrypted data, then the encryption scheme is fully homomorphic (FHE). Because FHE requires the so-called bootstrapping that is computationally expensive, it is sometime useful to use leveled FHE for efficiency. Leveled FHE can evaluate only computation up to a given circuit depth that is fixed by the encryption keys. In the following, we will use only the term FHE for fully homomorphic encryption and leveled fully homomorphic encryption."
            ],
            "subsections": []
        },
        {
            "title": "RELATED WORK",
            "paragraphs": [
                "In his seminal paper [53], Yao introduced the millionaires' problem and the first protocol to securely compare two integers. Later, different alternatives of securely comparing integers have been proposed. In [35,36] Kolesnikov et al. proposed schemes that use garbled circuits. In [18], Damg\u00e5rd et al. proposed the so-called DGK protocol, where the parties must evaluate",
                ") on the input bit encrypted with AHE. DGK has been improved by Veugen [49] and Joye and Salehi [31]. Similar protocols to the DGK, that rely on AHE, include Lin and Tzeng [37,48], Fischlin [22], Blake and Kolesnikov [6], Garay et. al. [24]. Other protocols [13,17,38,40,43] and most recent ones [4,20,39] Client Server",
                "Figure 1: The GT functionality are based on the arithmetic black-box model which is a powerful tool commonly used in MPC frameworks such as MP-SPDZ [32] or SCALE-MAMBA [1]. In [14,15], Cheon et al. proposed a scheme where the following circuit is evaluated using SHE/FHE:",
                "), for \ud835\udc56 > 1. In summary, all these schemes require access to the bit representation of the integers. Some schemes have a constant number of rounds [6,15,18,22,[35][36][37]. Other schemes have log-logarithmic number of rounds [16,24,26]. In Section 8, we analyze the closely related work in more detail and compare it to our approach. More recent work include [11,30] that reduce to comparison of small integers, using a base \ud835\udc5d > 2 representation instead of the binary representation. Bourse et al. [11] Use a specific AHE construction based on Factoring and cannot support comparison of two encrypted input, and sharing of the output bit. We do require any specific AHE, but can implement our scheme using ECC ElGamal resulting in a faster scheme with smaller communication. Iliashenko and Zucca [30] use specific structure of BGV and BFV to design faster schemes. We do not assume a specific FHE scheme, have a smaller circuit depth and can compare more integers using SIMD."
            ],
            "subsections": []
        },
        {
            "title": "DEFINITIONS",
            "paragraphs": [
                "Setting. The protocol consists of a server holding an input \ud835\udc66, and a client holding an input \ud835\udc65 . We assume that both inputs consist of \ud835\udf07-bit integers and \ud835\udf07 is public. The ideal functionality F GT takes \ud835\udc66 from the server and \ud835\udc65 from the client. It computes and outputs a bit \ud835\udc4f = [\ud835\udc65 \u2265 \ud835\udc66] to the parties such that \ud835\udc4f = 1 if \ud835\udc65 \u2265 \ud835\udc66 and \ud835\udc4f = 0 otherwise. The functionality is illustrated in Figure 1. In the following, we build our protocol on the case where only the client gets an output \ud835\udc4f = [\ud835\udc65 \u2265 \ud835\udc66]. It can be easily extended to a symmetric scenario if the server chooses a random \ud835\udc4f \ud835\udc60 \u2208 {0, 1} and homomorphically computes \ud835\udc4f \ud835\udc50 = \ud835\udc4f \u2295 \ud835\udc4f \ud835\udc60 before sending the result to the client. Then, the client decrypts the result and both parties holding shares \ud835\udc4f \ud835\udc50 , \ud835\udc4f \ud835\udc60 respectively and can reconstruct the result \ud835\udc4f = \ud835\udc4f \ud835\udc50 \u2295 \ud835\udc4f \ud835\udc60 . In some larger settings, it might be required to return only these shares of \ud835\udc4f to the parties, preventing them to learn intermediate result."
            ],
            "subsections": []
        },
        {
            "title": "Security and Correctness.",
            "paragraphs": [
                "A protocol correctly implements the GT functionality if after the computation the output is correct, i.e., \ud835\udc4f = 1 if \ud835\udc65 \u2265 \ud835\udc66 and \ud835\udc4f = 0 otherwise. Besides correctness parties must learn only what they are allowed to. This is formalized using the ideal/real world paradigm, where for each party there must exist a simulator, that given only the input of that party and the output, can generate a distribution that is computationally indistinguishable to the party's view [27]. To formalize this, we need the following definition [27] ",
                "In other words, there is no algorithm that can distinguish between the distributions. In multi-party protocols the view of a party consists of its input and the sequence of messages that it has received during the protocol execution [27]. The protocol is said to be secure if for each party, one can construct a simulator that, given only the input of that party and the output, can generate a distribution that is computationally indistinguishable to the party's view. We focus on the semi-honest security model in which parties follow the protocol but may try to learn more information from its execution. A protocol securely implements the GT functionality F GT in the semi-honest model if each party learns only its output and nothing else. In particular, there must exists simulators Sim gt C and Sim gt S that simulate the client and the server given only their input and output to the protocol.",
                "Let \u03a0 GT denote a protocol that securely implements F GT , and let View \u03a0 GT P (\ud835\udc65, \ud835\udc66) denote the view of party \ud835\udc43 during the protocol, then the following hold:",
                "\u2022 there exists a PPT algorithm Sim gt S that simulates the server's view View \u03a0 GT S given only \ud835\udc66 and [\ud835\udc65 \u2265 \ud835\udc66] such that: "
            ],
            "subsections": []
        },
        {
            "title": "OUR PROTOCOL",
            "paragraphs": [
                "Our protocol relies on a branching program that is represented as a binary tree. We therefore start by describing the intuition behind our scheme and defining our data structure. Then, we describe how our algorithms use this data structure to implement the functionality."
            ],
            "subsections": [
                {
                    "title": "Intuition",
                    "paragraphs": [
                        "Our key observation is that the comparison problem can be seen as a classification problem using a decision tree, where the tree is built on the server input and evaluated using the client input.",
                        "That is, given a server's input \ud835\udc66, a client's input \ud835\udc65 classifies as 1 if \ud835\udc65 \u2265 \ud835\udc66 or 0 otherwise. The tree edges are labelled with bits such that the evaluation is done by traversing the tree along the path of \ud835\udc65. However, we do not know the path representing \ud835\udc65 -since it is encrypted -and therefore have to evaluate all paths and aggregate the results. Evaluating a path on encrypted inputs means computing bit equality between edge labels and the bits of \ud835\udc65 and adding or multiplying the results along the path. For example, let \ud835\udc66 = 3 whose tree is illustrated in Figure 2. We have the following paths \ud835\udc43 0 = (0, 0, -, 0), \ud835\udc43 1 = (0, 1, 0, 0), \ud835\udc43 2 = (0, 1, 1, 1), \ud835\udc43 3 = (1, -, -, 1), where the last the element in each represents the leaf label and missing edges in shorter paths are represented with the symbol \" -\" that will be ignored. Let \ud835\udc65 = 2, i.e., binary vector (0, 1, 0), we evaluate as follows:",
                        ", -, -, 1) resulting in (1, 0, -, 0), (1, 1, 1, 0), (1, 1, 0, 1), (0, -, -, 1). By multiplying the elements in each vector",
                        "we get 0, 0, 0, 0 which finally results to 0 after adding all four zeros. Similarly for \ud835\udc65 = 4, i.e., (1, 0, 0), we have (0",
                        "Alternatively, we can instead label the leaves for \ud835\udc65 \u2032 \u2265 \ud835\udc66 with 0, otherwise with 1, then compute bit inequality and check if at most one path sums to 0. That is, for \ud835\udc65 = 2, \ud835\udc66 = 3 we have 0+1+1 = 2, 0+0+0+1 = 1, 0+0+1+0 = 1, 1+0 = 1; and for \ud835\udc65 = 4, \ud835\udc66 = 3 we have, 1",
                        "In the tree, paths may have common prefixes which allows to avoid considering each path separately and thus reducing the number of operations. Moreover, if \ud835\udc66 is not encrypted, i.e., labels of tree edge are not encrypted, and we aggregate the paths multiplicatively (resp. additively) then it is enough to evaluate only paths that lead to a classification 1 (resp. 0), reducing the computation even further. This is because, if \ud835\udc66 > \ud835\udc65 exactly one of those paths will aggregate to 1 (resp. 0), otherwise they will all aggregate to 0 (resp. non zero).",
                        "In our schemes, we compute the bit equality using XOR or XNOR. This is possible with AHE only if one of the bits is not encrypted and therefore requires the server to know \ud835\udc66 in the clear. Previous work solve this by adding a computation round which allows the parties to reduce the problem to the comparison of two random inputs, which preserve the order relation between the initial \ud835\udc65 and \ud835\udc66. If \ud835\udc65, \ud835\udc66 are encrypted, we compute the bit equality using a subtraction, without an extra round. This eventually introduces an error (0-1 = -1) which we correct before aggregating the results on the path.",
                        "For (leveled) FHE, computing prefixes by simply multiplying values is inefficient, as the multiplicative depth matters. Our scheme keeps a logarithmic (instead of linear) multiplicative depth at the cost of a low overhead on the number of multiplications. We do this by pre-computing dependency lists for multiplication as in [45]. This pre-computation depends only on the bitlength (and not on the inputs), and its result is unique for a given bitlength. It can be computed once and offline and later used as a constant parameter in the online protocol."
                    ],
                    "subsections": []
                },
                {
                    "title": "Data Structure",
                    "paragraphs": [
                        "The data structure is a binary tree consisting of inner nodes and terminal nodes. Each inner node has two child nodes and terminal nodes have no child nodes. There is a node with no parent node that is called root node. Let \ud835\udc63 be a node in the tree. We define a node data structure consisting of the following:",
                        "\u2022 \ud835\udc63.parent: a value representing the pointer to the parent node, \u2022 \ud835\udc63.left: a value representing the pointer to the left child node, \u2022 \ud835\udc63.right: a value representing the pointer to the right child node, \u2022 \ud835\udc63.lEdge: a bit representing the edge label to the left child node, \u2022 \ud835\udc63.rEdge: a bit representing the edge label to the right child node, \u2022 \ud835\udc63.cLabel: a value representing a node label,",
                        "\u2022 \ud835\udc63.cost: an integer representing the cost on the path from the root.",
                        "The pointer to the parent node \ud835\udc63.parent is initially null and points to the respective parent node, when the child node is created. This pointer remains null for the root node. The pointers to the child nodes \ud835\udc63 .left, \ud835\udc63.right are initially null, and point to the respective nodes if they are created. The edge labels to the child nodes \ud835\udc63.lEdge, \ud835\udc63.rEdge are 0 on the left and 1 on the right. The node label \ud835\udc63.cLabel is 0 or 1 for terminal nodes and undefined for inner nodes.",
                        "The cost attribute \ud835\udc63.cost is computed during evaluation of the tree."
                    ],
                    "subsections": []
                },
                {
                    "title": "Algorithms",
                    "paragraphs": [
                        "Our scheme works for both AHE and FHE but must be implemented differently. Initialization. The Initialization consists of a one time key generation. The client generates an appropriate triple (pk, sk, ek) of public, private and evaluation key for an HE scheme. Then, the client sends (pk, ek) to the server. For each computation, the client just encrypts its input and sends it to the server.",
                        "Creating the Binary Tree. Let \ud835\udc66 be the server input with bitlength \ud835\udf07. The server starts by creating a binary tree representing \ud835\udc66. The basic idea consists of creating a binary tree representing all bit strings of length \ud835\udf07. Then the leaf of the path that represents \ud835\udc66 and the leaves of all paths right to the path of \ud835\udc66 are labelled with 1 (i.e., \ud835\udc63 .cLabel = 1). The leaves of the paths left to \ud835\udc66 are labelled with 0 (i.e., \ud835\udc63.cLabel = 0). Finally, we can prune all subtrees that are labelled with the same bit. That is, if an inner node \ud835\udc63 has two child nodes labelled with the same bit \ud835\udc4f, we remove the child nodes of \ud835\udc63 from the tree and transform \ud835\udc63 into a leaf node labelled with \ud835\udc4f, (i.e., \ud835\udc63.cLabel = \ud835\udc4f). However, we can avoid the pruning by traversing the tree a single time with the bits of \ud835\udc66. If \ud835\udc66 [\ud835\udc56] = 1, we insert a leaf node on the left with cLabel = 0, and a new node on the right, then we traverse to the right. If \ud835\udc66 [\ud835\udc56] = 0, we insert a leaf node on the right with cLabel = 1 and a new node on the left, then we traverse to the left. Note that inserting a leaf node is only required if we are using FHE. For AHE, the traversal works similarly as above except that no leaf node is inserted left from the traversed path. Therefore, the created tree contains only paths, that can be evaluated to zero, i.e., paths labelled with integers that are larger or equal to \ud835\udc66. The creation of the binary tree is illustrated in Algorithm 1. For example, assume that \ud835\udf07 = 3, then Figure 2 illustrates the binary trees of 2 and 5 if the scheme is for FHE and Figure 3    \ud835\udc65 [\ud835\udc56] against the edge labels of node \ud835\udc63. This is represented by a comparison operation comp. For FHE, it is implemented as a bit equality test that returns 1 if the two bits are equal and 0 otherwise. For AHE, it is implemented as an inequality test that returns 0 if the two bits are equal and 1 otherwise. The operation can be computed by at least one Not gate. For example, consider the FHE case in which we have to achieve an equality test. If the edge label is 1, we just take the client's input \ud835\udc65   end if 15: end for bits is illustrated in Algorithm 2.",
                        "Aggregating Decision Bits. For each leaf node \ud835\udc63, the server aggregates the comparison bits along the path from the root to \ud835\udc63. For FHE this is done using homomorphic multiplication of the decision bits. For AHE, it is done using homomorphic addition of the decision bits. To unify the depiction of our algorithms as much as possible, we introduce a new notation for aggregating the decision bits: BitAgg. It refers to the homomorphic multiplication in the FHE case and to the homomorphic addition in the AHE case. The aggregated result is then stored at the leaf node of the corresponding path. We implement it using a queue and traversing the tree in BFS order as illustrated in Algorithm 3. Note that this computation can be improved using path prefixes, i.e. for two paths having the same prefix, the prefix is evaluated once.",
                        "Evaluating leaves. The evaluation of the leaves depends on the scheme as well. For FHE, after aggregating the decision bits along the paths to the leaf nodes, each leaf node \ud835\udc63 stores either \ud835\udc63.cost = 0 or \ud835\udc63.cost = 1 . Moreover, there is a unique leaf with \ud835\udc63.cost = 1 and all other leaves have \ud835\udc63.cost = 0 . Then, the server aggregates the costs at the leaves by computing for each leaf \ud835\udc63 the value \ud835\udc63.cost \ud835\udc63.cLabel and summing all the results of all leaves. This"
                    ],
                    "subsections": []
                }
            ]
        },
        {
            "title": "Algorithm 3 EvalPaths",
            "paragraphs": [
                "Require: root 1: let \ud835\udc44 be a queue 2: let leaves be a queue 24: return leaves computation is illustrated in Algorithm 4. For AHE, after aggregating the decision bits along the paths to the leaves nodes, each leaf node \ud835\udc63 stores a cost which is either \ud835\udc63.cost = 0 or \ud835\udc63 .cost = \ud835\udc5f , where \ud835\udc5f is the number of 1s on a path. Moreover, there is at most one leaf with \ud835\udc63.cost = 0 and all other leaves have \ud835\udc63 .cost = \ud835\udc5f , for an unknown \ud835\udc5f \u2208 {1, . . . , \ud835\udf07}. Note that for \ud835\udc66 \u2260 0 the number of paths is smaller or equal to \ud835\udf07 (See Figure 3a,3c). The server randomizes the encrypted costs at the leaves, chooses other random ciphertexts not encrypting zero, permutes the list and sends it to the client. These operations are implemented to guarantee the server's privacy. Randomization and permutation of ciphertexts prevents leakage of any information about \ud835\udc66 that is not intended. The generation of additional ciphertexts prevents leakage of the tree structure and therefore, potential information about \ud835\udc66 as well. Note that we exclude the case of randomly generating a ciphertext which decrypts to zero. The computation is illustrated in Algorithm 5.",
                "Decrypting the Result. The client decrypts the result of the evaluation. For FHE, it is a single encrypted bit indicating the comparison result. For AHE, the evaluation result consists of \ud835\udf07 ciphertexts among which at most one encrypts 0 and the remaining ones encrypt random plaintexts. The comparison result is true iff there is an encryption of 0. The client uses Algorithm 6 to decrypt and learn the final result."
            ],
            "subsections": []
        },
        {
            "title": "Algorithm 4 EvalLeaves (FHE)",
            "paragraphs": [
                "Require: leaves 1: \ud835\udc4f \u2190 0 2: for all \ud835\udc63 \u2208 leaves do Proof. In the tree of \ud835\udc66, there is a single path that is labeled with a prefix of \ud835\udc65. Evaluating the nodes on this path and aggregating"
            ],
            "subsections": []
        },
        {
            "title": "Client Server",
            "paragraphs": [
                "Input: x Input: y",
                "x EvalNodes(root, x )",
                "Protocol 4: The Basic Protocol the results produces a bit 1 (if FHE), resp. 0 (if AHE). On all other paths, at least one edge is labelled with a bit that is different to the bit of \ud835\udc65 at the same position such that the evaluation of the path produces a bit 0 (if FHE), resp. an integer \ud835\udc5f \u2260 0 (if AHE). \u25a1 Theorem 5.2. Let \ud835\udc66 and \ud835\udc65 be integers of length \ud835\udf07. If the encryption scheme is IND-CPA secure, then the comparison protocol is secure in the semi-honest model.",
                "Proof (sketch). The client only encrypts its own input and decrypts the final result which for FHE is a single bit, and for AHE a randomly ordered list of \ud835\udf07 ciphertexts among which at most one encrypts 0 and the remaining ones encrypt each a random plaintext. The server, on the other hand, computes on IND-CPA ciphertexts. Constructing the simulators therefore consists of on simply generating corresponding random strings for each protocol message except for the actual results (Appendix A). \u25a1"
            ],
            "subsections": []
        },
        {
            "title": "EXTENSION",
            "paragraphs": [
                "In the previous section, we discuss the basic idea of our scheme. Now we want to discuss how the basic scheme can be extended to different use cases."
            ],
            "subsections": [
                {
                    "title": "Handling Comparison to Zero for AHE in the Constant Case",
                    "paragraphs": [
                        "Recall that if the encryption is AHE, then Algorithm 1 creates a tree containing only paths, that can be evaluated to zero, i.e., paths labeled with integers that are larger or equal to \ud835\udc66. If \ud835\udc66 = 0 then the created tree has \ud835\udf07 + 1 leaves, since everything is larger or equal to zero. But the server is supposed to send back \ud835\udf07 ciphertexts to the client. That is, we still want the parties to perform the computation such that nothing more than the comparison bit is revealed. We notice that for all values smaller than 2 \ud835\udf07-1 (i.e., the most significant bit is 0), \ud835\udc65 traverses the tree of \ud835\udc66 = 0 to the left. To handle the case \ud835\udc66 = 0, the server, therefore, replaces the first encrypted bit of \ud835\udc65 by a ciphertext of 0 and omits the rightmost path of the tree in the evaluation."
                    ],
                    "subsections": []
                },
                {
                    "title": "Shared Output Bit",
                    "paragraphs": [
                        "In 2-party comparison like DGK [18], it is usual to share the comparison bit between the client and server. That is, if \ud835\udc4f is the comparison bit, then the server gets \ud835\udc4f \ud835\udc60 and the client gets \ud835\udc4f \ud835\udc50 such that \ud835\udc4f = \ud835\udc4f \ud835\udc50 \u2295\ud835\udc4f \ud835\udc60 . In our scheme, the server can randomly choose between computing GT (e.g., [\ud835\udc65 \u2265 \ud835\udc66]) or LT (e.g., [\ud835\udc65 \u2264 \ud835\udc66]) functionality. The server, therefore, chooses a bit \ud835\udc4f \ud835\udc60 and computes GT if \ud835\udc4f \ud835\udc60 = 0, otherwise it computes LT (See Section 6.5). Note that in both cases (GT vs. LT) the tree of \ud835\udc66 has the same structure, such that the server performs the same computation which is independent of [\ud835\udc65 \u2265 \ud835\udc66] and [\ud835\udc65 \u2264 \ud835\udc66] and hence does not leak which operation was evaluated. After this computation, the server returns \ud835\udf07 ciphertexts to the client, among which at most one encrypts 0 (due to sum of zeros on the corresponding path). The remaining ciphertexts encrypt each a random plaintext (since there is at least a 1 on the corresponding path). The client can then extract its share \ud835\udc4f \ud835\udc50 of the comparison bit. For further computation, the client can send back the ciphertext \ud835\udc4f \ud835\udc50 , from which the server can easily get the ciphertext \ud835\udc4f = Xor( \ud835\udc4f \ud835\udc50 , \ud835\udc4f \ud835\udc60 ) of the actual comparison bit. Note that this is not specific to our scheme, but it also works with other AHE-based comparison protocols."
                    ],
                    "subsections": []
                },
                {
                    "title": "Handling Encrypted Inputs",
                    "paragraphs": [
                        "So far we assume that only \ud835\udc65 is encrypted. In this section, we consider the case where both inputs are encrypted. In this scenario, the server has to run the comparison of two encrypted inputs with the help of the client (or another server) which has the decryption key. It is assumed that the inputs \ud835\udc65 and \ud835\udc66 do not belong to any party and must remain private. After the computation, the server learns the encrypted comparison bit. If the encryption is FHE, the server can perform the computation on its own. However, in the AHE case, the client must help the server to learn the encrypted result.",
                        "To guarantee the privacy of both inputs, the protocol has to be evaluated on ciphertexts only. However, the tree structure reveals a lot of information about \ud835\udc66 why we have to use a general representation of the tree to avoid any leakage. We start with a few formal definitions. Definition 6.1 (Comparison Tree). A comparison tree or cmptree for an integer \ud835\udc66 is a binary tree where edges and leaves are labelled with 0 or 1 such that for every integer \ud835\udc65, traversing the tree along a path labelled with the bits of \ud835\udc65 (starting with the most significant bit of \ud835\udc65) reaches a leaf labelled with 1 if \ud835\udc65 \u2265 \ud835\udc66 and 0 otherwise.",
                        "Note that for secure comparison the bits are encrypted such that we do not actually traverse the tree \ud835\udc66, but evaluate it on \ud835\udc65 as explained in the previous section. Therefore, when we say \ud835\udc65 traverses the tree of \ud835\udc66, we mean that there is a single path where \ud835\udc65 evaluates to 1 (if FHE), resp. 0 (if AHE), and on all other paths \ud835\udc65 evaluates to 0 (if FHE), resp. to an \ud835\udc5f \u2260 0 (if AHE).",
                        "While Definition 6.1 describes a cmp-tree, it can be built as follows. Let \ud835\udf07 be the input bit-length of \ud835\udc66. First build a binary tree representing all bit strings of length \ud835\udf07, i.e. left edges are labelled with 0 and right edges are labelled with 1. Then, there is a path \ud835\udc5d representing \ud835\udc66, label the leaf of \ud835\udc5d and the leaves of all paths right to \ud835\udc5d with 1. Finally, label the leaves of all paths left of \ud835\udc5d with 0. Such a tree construction is illustrated in Figure 5 for \ud835\udc66 = 2. Note  that the tree from Figure 5 is unnecessarily large as there are inner nodes whose child nodes are both leaves labelled with the same value. Such resulting sub-trees can be pruned without changing the semantic of the cmp-tree. We next formally define pruned cmp-tree.",
                        "We first recall the depth of a binary tree. Definition 6.2 (Depth of a Tree). For a binary tree, we define the depth of the tree as the length (i.e., number of edges) of the longest path. The depth of a node is the number of edges between this node and the root node. Let \ud835\udc51 be the depth of the binary tree, a deepest inner node is a node whose child nodes are both leaves with depth \ud835\udc51. Definition 6.3 (Pruned Cmp-tree). A comparison tree for an integer \ud835\udc66 is full-pruned if there is no inner node whose children are both leaves with the same label. A cmp-tree for an integer \ud835\udc66 is halfpruned if its depth is the bit-length of \ud835\udc66 and for each non deepest inner node exactly one child node is a leaf.",
                        "Note that a half-pruned cmp-tree is not necessarily full-pruned. For example if the bit-length is \ud835\udf07 = 3, then half-pruned tree of 4 is not full-pruned. In this case, the full-pruned tree is only the root with 2 leaves. In the following, we will rather consider half-pruned tree since the structure is similar for every input. The half-pruned tree for integer \ud835\udc66 can be built as follows. Traverse the non-pruned cmp-tree from Definition 6.1 along the path of \ud835\udc66. At each level, replace the non-traversed subtree by a leaf node. Let \ud835\udc5d be the path representing \ud835\udc66. Label the leaf of \ud835\udc5d and the leaves of all paths right to \ud835\udc5d with 1. Label the leaves of all path left to \ud835\udc5d with 0. By using Algorithm 1 with \ud835\udefd = 1, this can be done without first generating the full cmp-tree. Now, we want to introduce a structure of the tree based on the input size but independent of the actual inputs. We first define further notation. Recall that we use the symbol \ud835\udefd = 1 if the encryption scheme is FHE and \ud835\udefd = 0 if the encryption scheme is AHE. For a bit \ud835\udc4f \u2208 {0, 1}, we now define the function \ud835\udc39 \ud835\udefd (\ud835\udc4f) = \ud835\udefd + (-1) \ud835\udefd \u2022 \ud835\udc4f. Note that the function \ud835\udc39 \ud835\udefd does not have to be evaluated homomorphically, as its only purpose is to simplify the notation. For an encrypted bit \ud835\udc4f , we have \ud835\udc39 \ud835\udefd ( \ud835\udc4f ) = \ud835\udc4f if the encryption is AHE and \ud835\udc39 \ud835\udefd ( \ud835\udc4f ) = 1 -\ud835\udc4f if the encryption is FHE with arithmetic encoding or \ud835\udc39 \ud835\udefd ( \ud835\udc4f ) = 1 + \ud835\udc4f for binary encoding, as the addition is modulo two. Definition 6.4 (Normal Cmp-Tree). Let \ud835\udc66 be an integer of length \ud835\udf07. A normal Cmp-tree of \ud835\udc66 is a binary tree with the following structure:",
                        "\u2022 there is a leftmost path \ud835\udc5d of length \ud835\udf07 which is labelled with the bits of \ud835\udc66,",
                        "\u2022 the deepest inner node of path \ud835\udc5d has a left leaf node labelled with \ud835\udefd, \u2022 each inner node of path \ud835\udc5d has a right child leaf node, \u2022 for each inner node, let \ud835\udc4f be the label on the left edge, then the label on the right edge is 1 -\ud835\udc4f and the label on the right child leaf node is \ud835\udc39 \ud835\udefd (\ud835\udc4f).",
                        "While Algorithm 1 generates a half-pruned cmp-tree for \ud835\udc66 assuming the bits are given in plaintext, the normal cmp-tree can be built even if the input bits are homomorphically encrypted. For each encrypted bit \ud835\udc4f of the input string, one can homomorphically compute the encrypted inverse bit 1 -\ud835\udc4f and build the cmp-tree. The generation of the normal cmp-tree is described in Algorithm 7.",
                        "Note that in contrast to Algorithm 1, left and right edges are not per default labeled with 0 and 1, but they are assigned according to the definition of the normal cmp-tree. This makes the normal cmp-tree a general structure which is independent of the actual input \ud835\udc66. The input only influences the labels of the edges but not the tree structure itself.",
                        "Although both algorithms have the same complexity, Algorithm 7 is shorter and simpler. An example of normal cmp-trees is illustrated in Figure 6. Before using the normal form defined above, we need to prove that it is indeed a cmp-tree, by showing that the normal cmp-tree has the same number of nodes (inner nodes and leaves) as the half-pruned cmp-tree and that they can be transferred into each other. Lemma 6.5. Let \ud835\udc66 be an integer of length \ud835\udf07. The half-pruned tree of \ud835\udc66 has \ud835\udf07 + 1 leaves and \ud835\udf07 inner nodes.",
                        "Note that among the \ud835\udf07 + 1 leaves, at most \ud835\udf07 leaves are labelled with 1 (if FHE), resp. 0 (if AHE). For the AHE case, if \ud835\udc5b is the number of these leaves, then exactly the paths corresponding to them are created in Algorithm 1, evaluated and sent back (with \ud835\udf07 -\ud835\udc5b random ciphertexts) to the client. Definition 6.6. Two cmp-trees are equivalent if they represent the same value, have the same depth and the same number of leaf nodes and inner nodes. Lemma 6.7. The normal cmp-tree of \ud835\udc66 and a half-pruned cmp-tree of \ud835\udc66 are equivalent. Theorem 6.8. Let \ud835\udc66 and \ud835\udc65 be integers of length \ud835\udf07. If the encryption scheme is correct, then the comparison protocol is correct.",
                        "With the normal cmp-tree we have a structure independent of the actual tree which allows the server to compute on ciphertexts without learning anything of input \ud835\udc65. This structure is also equivalent to the structure we used for our basic protocol and yields correct results such that we can apply nearly the same routines. The only difference is in the computation of decision bits since the server does not know the edge labels in plaintext. Therefore, we have to apply an inequality/equality test on ciphertexts. For FHE we need an inequality test which can be implemented using an FHE Xnor gate. For AHE we must perform an equality test which can be implemented using an AHE Xor gate."
                    ],
                    "subsections": []
                },
                {
                    "title": "Handling Encrypted Inputs under AHE",
                    "paragraphs": [
                        "The handling of encrypted inputs described above works only for FHE. The reason is that the Xor-operation for AHE encrypted bits  16: return root requires one bit to be in the clear. In this section, we describe how to extend the previous section to handle the case for AHE. We assume the client sends two encrypted inputs \ud835\udc65 and \ud835\udc66 to the server. The server creates the normal cmp-tree of \ud835\udc66 using Algorithm 7, evaluates the encrypted input \ud835\udc65 on the tree and sends back a result that only the client can decrypt. However, the encrypted result is not an encrypted bit, but a set of \ud835\udf07 ciphertexts.",
                        "The computation needs two basic bit-operations, namely Not and Xor, that have to be simulated under AHE. Let \ud835\udc4e and \ud835\udc4f be two encrypted bits. We compute the Not-operation as \u00ac\ud835\udc4f = 1 -\ud835\udc4f = Add( 1 , MulCons( \ud835\udc4f , -1)). Then, we compute the Xor-operation as \ud835\udc4e \u2295 \ud835\udc4f = \ud835\udc4e -\ud835\udc4f . While the Not-operation is correct, this is not always the case for the Xor-operation, namely we have 0 \u2295 1 = -1 . We will handle this before aggregating the paths.",
                        "Recall that we have encrypted bits of \ud835\udc65 and \ud835\udc66 and we want to compute a comparison bit. First, using the encrypted input \ud835\udc66 , we can build the normal cmp-tree as explained in Algorithm 7. This requires only the Not-operation. Then we can evaluate the bits of \ud835\udc65 on the built tree. For that, we first have to apply the Xoroperations on the bits of \ud835\udc65 along the paths of the tree and then sum the result along the paths. Our goal is that, if \ud835\udc65 \u2265 \ud835\udc66, then exactly one path will have all Xor-results equal 0 such that the sum along the path is also 0. The remaining paths will have at least one Xor-result that is different to 0 resulting in a sum different to 0. Now we have the following problem: If the Xor-results of a path contain 1 and -1 then this path too may sum to 0. To get rid of the problem, we multiply the Xor-result at level \ud835\udc56 (i.e., edges starting at a node with depth \ud835\udc56) by 2 \ud835\udc56 before aggregating the results along the paths. Since 2 \ud835\udc56 is constant, the multiplication can be applied on an AHE ciphertext. The following lemma ensures that the sum on such a path is then always different to 0. Lemma 6.9. Let (\ud835\udc4f 0 , \u2022 \u2022 \u2022 , \ud835\udc4f \ud835\udc59 ) \u2208 {-1, 0, 1} \ud835\udc59+1 such that there exist at least one",
                        "For example, let \ud835\udc66 = 2, \ud835\udc65 = 1 and \ud835\udf07 = 3. Since we are evaluating [\ud835\udc65 \u2265 \ud835\udc66] under AHE, no path should evaluate to 0. First note that the paths are as follows (from left to right): (0, 1, 0, 0), (0, 1, 1, 0), (0, 0, -, 1), (1, -, -, 0), where the last element in each vector is the leaf label. Without Lemma 6.9, the evaluation of the leftmost path on (0, 0, 1) would result in (0-0)+(0-1)+(1-0)+0 = 0. By multiplying with powers of 2 as explained above, we have",
                        "which is different to 0 as expected. For the other paths (0, 1, 1, 0), (0, 0, -, 1), (1, -, -, 0) we will have respectively:",
                        "That is, on encrypted input we get ( 2 , -2 , 1 , -1 ). The server will then homomorphically randomize the plaintexts and send a permuted vector, from which the client can deduce the comparison bit \ud835\udc4f = 0, since no ciphertext decrypts to zero."
                    ],
                    "subsections": []
                },
                {
                    "title": "Less Than (LT) Comparison",
                    "paragraphs": [
                        "The computation of the Less-Than (LT) function is similar by using the following definition that is the inverse of the normal cmp-tree. Definition 6.10 (Inverse Normal Cmp-Tree). Let \ud835\udc66 be an integer of length \ud835\udf07. An inverse normal Cmp-tree of \ud835\udc66 is a binary tree with the following structure:",
                        "\u2022 there is a rightmost path \ud835\udc5d of length \ud835\udf07 which is labelled with the bits of \ud835\udc66, \u2022 the deepest inner node of path \ud835\udc5d has a left leaf node labelled with \ud835\udefd, \u2022 each inner node of path \ud835\udc5d has a left child leaf node, \u2022 for each inner node, let \ud835\udc4f be the label on the right edge, then the label on the left edge is 1 -\ud835\udc4f and the label on the left child leaf node is 1 -\ud835\udc39 \ud835\udefd (\ud835\udc4f).",
                        "While the inverse normal cmp-tree is defined with a right oriented structure (contrary to the left oriented structure of Definition 6.4), the inverse normal cmp-tree can be represented with a left oriented structure as well. The only difference is that all leaves except the leftmost one must be labelled with 1 -\ud835\udc39 \ud835\udefd (\ud835\udc4f) as in Definition 6.10 instead of \ud835\udc39 \ud835\udefd (\ud835\udc4f) as in Definition 6.4."
                    ],
                    "subsections": []
                }
            ]
        },
        {
            "title": "ANALYSIS",
            "paragraphs": [
                "In the sections above, we proved already that the computation correctly returns 1 if \ud835\udc65 \u2265 \ud835\udc66 and 0 otherwise. The computation is also secure as the server evaluates input encrypted under the client's public key. In this section, we therefore focus on the complexity analysis and count the number of homomorphic operations (addition and multiplication). "
            ],
            "subsections": [
                {
                    "title": "Number of Operations",
                    "paragraphs": [
                        "We start by counting the number of operations depending on the main steps of the algorithm, namely: node evaluation, path evaluation, leaves aggregation. In the following, we use A 1 , A 2 , A 3 (resp. M 1 , M 2 , M 3 ) to denote the number of addition (resp. multiplication) operation in node evaluation, path evaluation, leaves aggregation and A \ud835\udc47 (resp. M \ud835\udc47 ) for the total.",
                        "Node Evaluation. For node evaluation at each inner node, the algorithm performs exactly one Not gate due to the fact that the left and right edges of an inner node are always labelled with opposite bits. For the encrypted case (Section 6.3), we need one Not and one Xor. Hence, we have in total \ud835\udf07 Not-operations.",
                        "Path Evaluation. For path aggregation, the algorithm performs \ud835\udf07 -1 multiplications on the leftmost path and 2 multiplications on each right path except the rightmost path that requires only 1 multiplication. This result in total of \ud835\udf07 -1 + 2 \u2022 (\ud835\udf07 -1) + 1 = 3\ud835\udf07 -2.",
                        "Leaves Aggregation. In the case of FHE, the algorithm finally aggregates the \ud835\udf07 + 1 paths requiring \ud835\udf07 additions."
                    ],
                    "subsections": []
                },
                {
                    "title": "Complexity for FHE",
                    "paragraphs": [
                        "For FHE, we need to distinguish between binary and arithmetic circuit or encoding. An overview can be found in Table 1."
                    ],
                    "subsections": []
                }
            ]
        },
        {
            "title": "FHE Binary Circuit.",
            "paragraphs": [
                "For binary encoding, all operations are done modulo 2 such that Xor and Not operations are implemented as an addition. As a result, we have A 1 = \ud835\udf07 additions in node evaluations, no addition in path evaluation (i.e., A 2 = 0) and A 3 = \ud835\udf07 additions during leaves aggregation resulting in a total of A \ud835\udc47 = \ud835\udf07+0+\ud835\udf07 = 2\ud835\udf07 additions. For the encrypted case, we need an additional Xor at each node resulting in A 1 = 2\ud835\udf07 additions and in a total of A \ud835\udc47 = 3\ud835\udf07 additions. Only path aggregation requires M",
                "For some FHE schemes, it might come with performance improvements if we reduce the multiplicative depth. In our scheme, this only affects the path evaluation. The previous approach yields a depth of \ud835\udf07 but we can reduce the depth to log \ud835\udf07 by using an optimized implementation. For implementation details, we refer to Section 8 and Appendix B. The reduction of the multiplicative depth comes with an increasing number of multiplications. For the leftmost path, we need a multiplication for every pair, for every quadruple and so on. By the geometric sum formula, this is \ud835\udf07 -1 multiplications. The splitting of the leftmost path creates a structure that divides the path into sections of powers of two. Therefore, the connection of right children of one section needs one additional multiplication for every child in that section. This results in a total number of multiplications of \ud835\udf07 + \ud835\udf07 log \ud835\udf07 2",
                "for right children nodes. We provide a more detailed analysis in Appendix C. FHE Arithmetic Circuit. For arithmetic encoding, the Xor operation \ud835\udc4e \u2295 \ud835\udc4f is homomorphically computed as (\ud835\udc4e -\ud835\udc4f) 2 , such that each Xor operation requires 1 addition and 1 multiplication. The Not operation \u00ac\ud835\udc4f is computed as 1 -\ud835\udc4f. As a result, the node evaluation requires A 1 = \ud835\udf07 additions. For the encrypted case, we need A 1 = 2\ud835\udf07 additions and M 1 = \ud835\udf07 multiplications. For path and leaves evaluation, we have A 2 = 0, M 2 = 3\ud835\udf07 -2, A 3 = \ud835\udf07, M 3 = 0. The evaluation of the tree, therefore, requires A \ud835\udc47 = \ud835\udf07 + 0 + \ud835\udf07 = 2\ud835\udf07 additions and M \ud835\udc47 = 0 + (3\ud835\udf07 -2) + 0 = 3\ud835\udf07 -2 multiplications. In the encrypted case, the total is A \ud835\udc47 = 3\ud835\udf07 additions and M \ud835\udc47 = 4\ud835\udf07 -2 multiplications.",
                "Comparison to Previous Work. Cheon et al. [15] also use a comparison protocol based on FHE and present a variant with logarithmic multiplicative depth. Their critical is the iterative computation of a product with depth \ud835\udf07 -1, i.e., given integers \ud835\udc65 1 , . . . , \ud835\udc65 \ud835\udc5b , we want to compute products \ud835\udc43 \ud835\udc56 = \ud835\udc56 \ud835\udc57=1 \ud835\udc65 \ud835\udc57 , for \ud835\udc56 = 2, . . . , \ud835\udc5b while keeping the multiplicative depth logarithmic. They propose to compute the products using a recursive algorithm that builds a binary tree of products yielding sub products for positions which are power of 2. In the next step, they compute the missing products, i.e., for positions that are not power 2, based on a multiplication of the results for the power of two cases. We implemented this computation using an iterative algorithm described in Appendix D. For more details, we refer to the original work [15]. In total, the scheme of Cheon et al. requires 2\ud835\udf07 -2 additions and 2\ud835\udf07 -3 + (\ud835\udf07-1)\ud835\udc59\ud835\udc5c\ud835\udc54 (\ud835\udf07-1) 2 multiplications using binary encoding. Using arithmetic encoding, the 2\ud835\udf07 -2 additions require an additional \ud835\udf07 -1 homomorphic multiplications. As a result, the total number of multiplications in their scheme is 3\ud835\udf07 -4+ (\ud835\udf07-1)\ud835\udc59\ud835\udc5c\ud835\udc54 (\ud835\udf07-1) 2",
                ". As our approach, they also achieve a logarithmic depth but need less additions and slightly less multiplications. However, our optimized implementation uses a precomputation which is an advantage for the actual running time of the protocol, see further in Section 8."
            ],
            "subsections": [
                {
                    "title": "Complexity for AHE",
                    "paragraphs": [
                        "For AHE, we need to distinguish between the encrypted case where both inputs are encrypted and the the constant case where only one input is encrypted. An overview can be found in Table 2. In both cases, Xor and Not operations are realized using homomorphic addition. As a result, there are A 1 = \ud835\udf07 homomorphic operations for node evaluation. In the encrypted case, we have A 1 = 2\ud835\udf07 homomorphic operations.  Constant Case. Recall that in this case, we can omit the leaves (See Algorithm 1 and Figure 3). This results in A 2 = 2\ud835\udf07 -2 operations for paths evaluations, i.e., \ud835\udf07 -1 operations for evaluating the leftmost path and one operation for each of the \ud835\udf07 -1 deepest right oriented paths. In total, our scheme requires A \ud835\udc47 = \ud835\udf07 +2\ud835\udf07 -2 = 3\ud835\udf07 -2 operations. As a comparison, in [18], the DGK scheme performs 5\ud835\udf07 additions, \ud835\udf07 constant multiplications which is equivalent to 2\ud835\udf07 additions. In total, DGK has 7\ud835\udf07 additions plus additional \ud835\udf07 encryption operation and \ud835\udf07 modular inverse operations. Veugen [49] improved the DGK scheme by requiring only 4\ud835\udf07 operations. Encrypted Case. We now have A 1 = 2\ud835\udf07 homomorphic operations for node evaluation, but A 2 = 3\ud835\udf07 -1 operations for paths evaluation, as we have to consider the leaves. Additionally, we need 2\ud835\udf07 constant multiplications to prevent the problem explained in Section 6.4. A constant multiplication m \ud835\udc5b requires in worst case 2 log \ud835\udc5b homomorphic additions. For each level \ud835\udc56, we perform in Section 6.4 two multiplications by 2 \ud835\udc56 resulting in 2 \ud835\udf07-1 \ud835\udc56=2 \ud835\udc56 = O \ud835\udf07 2 operations which dominates the number of operations for nodes and paths evaluation.",
                        "Comparison to Previous Work. As a comparison Veugen also proposed two extensions of the DGK scheme in the encrypted case: a statistical and perfect secure scheme. Both have 2 rounds, i.e., 4 moves between the parties (while our scheme still has one round as the initial DGK). Both schemes require efficient decryption of a random plaintext and cannot be efficiently implemented using ECC ElGamal (see section on ElGamal). The scheme works as follows. The server holds \ud835\udc65 and \ud835\udc66 encrypted under Paillier with modulus \ud835\udc41 = \ud835\udc5d\ud835\udc5e, where \ud835\udc5d and \ud835\udc5e are large primes. The server chooses a random number \ud835\udc5f , such 0 \u2264 \ud835\udc5f < \ud835\udc41 , computes For the perfect security case, Veugen proposed a modified DGK protocol that is very complex and requires two times the same constant multiplication by 2 \ud835\udc56 as our scheme and additional operations, such as encryption, decryption and modular inversion, to get the final result. Since the scheme is very complex and the number of operations depends on the actual values, we use a complexity lower bound for a comparison with our scheme. Table 2 shows that our scheme is a significant improvement even to the lower bound of the optimized DGK protocol. As in [49], we assume a homomorphic multiplicative inversion to need 2  3 \ud835\udc52 multiplications where \ud835\udc52 is the bit-length of the number which is a ciphertext in this case. For the inversions used by the modified DGK protocol, this is on average",
                        "Another optimization of the DGK protocol has been published by Joye and Salehi [31]. Their scheme achieves about the same overhead as Veugen but prevents timing attacks. To this end, they use the hamming weight of one input and can furthermore half the number of ciphertexts being sent. However, to keep the security, they introduce another round to mask the input. Our protocol only needs one round but still transmits \ud835\udf07 instead of \ud835\udf07/2 ciphertexts."
                    ],
                    "subsections": []
                }
            ]
        },
        {
            "title": "EVALUATION AND IMPLEMENTATION",
            "paragraphs": [
                "In this section, we describe some implementation details and report on the experimental results of our implementations."
            ],
            "subsections": [
                {
                    "title": "Optimized Implementation",
                    "paragraphs": [
                        "Instead of implementing our scheme using a binary tree, we rely on a simpler data structure by using a two dimensional array \ud835\udc4e[(1, . . . , \ud835\udf07 + 1), (1, 2, 3)] with \ud835\udf07 + 1 rows and three columns. The idea is illustrated in Figure 7 for \ud835\udc65 = 1, \ud835\udc66 = 3, \ud835\udf07 = 3, \ud835\udefd = 1. The array is initialized with the cmp-tree of \ud835\udc66 = 3, where the first column stores the labels on the leftmost path. Column 2 and 3 store the right oriented paths from the first row to the last one. That is, the last row and the last column store leaf labels, where on the last row, only the first cell is filled.",
                        "The evaluation itself is illustrated in Algorithm 8 and Figure 7. On each row, we store \ud835\udc65 [\ud835\udc56] == \ud835\udc66 [\ud835\udc56] in cell 1, its negation in cell 2, and \ud835\udc39 \ud835\udefd (\ud835\udc66 [\ud835\udc56]) in cell 3. This corresponds to the computation of decision bits(cell 1 and 2) and the leaf node labels (cell 3). In Figure 7, the arrows illustrate paths evaluation, where \ud835\udc4e \ud835\udc56 \u2192 \ud835\udc4e \ud835\udc57 means that cells \ud835\udc4e \ud835\udc56 and \ud835\udc4e \ud835\udc57 are aggregated and the result is stored in cell \ud835\udc4e \ud835\udc57 .",
                        "For the FHE case, the multiplicative depth of the procedure is of relevance if the encryption scheme is leveled FHE. This is because a leveled FHE has a fixed parameter \ud835\udc3f such that circuits with depth at most \ud835\udc3f can be evaluated without bootstrapping. Therefore, we first evaluate the inner nodes as before by evaluating Xor operations, but use the multiplication with a direct acyclic graph described in [45]. This is illustrated in Figure 8 and consists of first computing a dependency list (DL) table for each element of the matrix (the middle table in Figure 8). The DL is a queue, represented as [) with back [ and front ) that contains cells' numbers along a multiplication path, i.e., the set of cells that must be multiplied together. In Figure 8, we have the following multiplication paths: (1,4,7,10), (1,4,8,9), (1,5,6), (2,3). For each path, we start with a Algorithm 8 Efficient implementation ",
                        "if \ud835\udefd = 0 then {AHE Section 6.4} 10: return permute(c) 33: end if list of nodes. First, we group the elements by pairs and add the first element to the second elements' DL. Then, we reduce the list by all elements that occur in any DL and repeat the procedure until there is only one element left. If a multiplication path consists of nodes \ud835\udc4e, \ud835\udc4f, \ud835\udc50, \ud835\udc51 in this order, then the DLs are as follows: [), [\ud835\udc4e), [), [\ud835\udc4f, \ud835\udc50). Note that the computation of the DL table does not depend on the input but only on the tree structure. In fact, it can be computed once and given as input to the algorithm. While multiplying, we move from top to bottom and from left to right in the matrix and compute the aggregated result of each cell using its DL. For example, using the DLs [), [\ud835\udc4e), [), [\ud835\udc4f, \ud835\udc50), there is nothing to do for nodes \ud835\udc4e and \ud835\udc50 since their DLs are empty. For node \ud835\udc4f, we compute \ud835\udc4f \u2190 \ud835\udc4e \u2022 \ud835\udc4f. For node \ud835\udc51, we first compute \ud835\udc51 \u2190 \ud835\udc50 \u2022 \ud835\udc51 and then \ud835\udc51 \u2190 \ud835\udc4f \u2022 \ud835\udc51. For a path of length \ud835\udc58, this reduces the multiplicative depth from \ud835\udc58 to log \ud835\udc58."
                    ],
                    "subsections": []
                },
                {
                    "title": "Setup Environment",
                    "paragraphs": [
                        "For AHE, we implemented DGK [18], the optimized DGK by Veugen [49], the scheme of Joye and Salehi [31] and our scheme in Java. We instantiated AHE with ElGamal on elliptic curve as described in Appendix E using curve secp256r1. We implemented  our scheme in three variants: the naive implementation using tree representation (Section 5), the optimized implementation using array representation (Algorithm 8) and the encrypted case (Section 6). For the scheme of Joye and Salehi, we only implemented the basic comparison protocol without the additional masking round which would be required to achieve full security. We note that Veugen [49] also proposed a protocol for the encrypted case, which is computationally more complex and no longer one round. For this reason, we did not implement it as it no longer fits with our basic protocol (Protocol 4) and our encrypted case is already theoretically better. It is one round and requires only a constant multiplication (by 2 \ud835\udc56 as explained above) per bit.",
                        "For FHE, we compared our protocol with Cheon et al. [15]. The implementation uses the BGV scheme [12] from HElib [3].",
                        "We evaluated our implementation according to our basic protocol which is a one round protocol. That is, the client encrypts its input and sends it to the server. The server evaluates and sends back encrypted result to the client. The client finally decrypts to learn the result. The evaluation of the AHE implementations is done on a single Laptop with a 6-core Intel(R) Xeon(R) E-2176M CPU @ 2.70GHz and 32GB of RAM running Windows 10 Enterprise. Due to the higher running time and memory requirements of FHE schemes, the evaluation of FHE implementations is done on an AWS instance with a 24-core Intel(R) Xeon(R) Scalable processor (Skylake 8151) with up to 4.0 GHz and 192GB of RAM running Ubuntu 20.04 LTS."
                    ],
                    "subsections": []
                },
                {
                    "title": "Results",
                    "paragraphs": [
                        "We present the result of our evaluation and compare our scheme to the related work. Since there are several schemes in the literature, we focus on schemes closely related to ours and discuss some recent work in Appendix F. That is the comparison uses the binary decomposition, performs computation on homomorphically encrypted inputs but does not assume a specific AHE or FHE scheme. AHE. For DGK, Veugen constant case and our scheme, the communication is the same, i.e., number of ciphertexts (\ud835\udf07 ciphertexts from client and \ud835\udf07 ciphertexts from server) sent times the length of a ciphertext. However, for the encrypted case, Veugen additionally requires Paillier encryption to encrypt large randomized plaintexts. This cannot be done with additive ElGamal, as decryption requires computing the discrete logarithm over a large domain. Veugen's scheme additionally sends few Paillier ciphertexts and requires two rounds instead of one in the encrypted case. Joye and Salehi have different communication because the server sends only half the number of ciphertexts as the other schemes. For the encrypted case, one might apply the same procedure as Veugen resulting in more expensive Paillier operations as well. The above is also true for the client computation effort. In DGK, constant case Veugen and our scheme, the client encrypts \ud835\udf07 plaintext bits and decrypts \ud835\udf07 ciphertexts. In Joye and Salehi, the decryption of the client is reduced by factor 2. Nevertheless, we focus our evaluation on the server computation but compare only to the basic scheme of Joye and Salehi without the additional round.",
                        "To evaluate the running time, we generated random inputs \ud835\udc65 and \ud835\udc66 and compare them using each protocols at security level 128. We repeated the experiment 100 times and computed the average running time which is illustrated in Table 3, for input bit-length \ud835\udf07 = 8, 16, 32, 64, 96, 128. While Veugen scheme and Joye and Salehi scheme clearly perform better than the original DGK scheme, Joye and Salehi performs slightly better for small bit-lengths (\ud835\udf07 \u2264 32), while Veugen performs better for large bit-lengths (\ud835\udf07 \u2265 64). Our naive implementation is only better than the both for large bitlengths (\ud835\udf07 \u2265 64) and our optimized implementation is always better. Although our encrypted case requires additional constant multiplications per bits, it still performs better than the original DGK scheme. In the encrypted case of Veugen's scheme and Joye and Salehi's scheme client and server both require additional Paillier ciphertext operations.",
                        "We implemented and evaluated the Paillier operations in Veugen's scheme at security level 128 (i.e., bit-length of the modulus \ud835\udc41 is 3072) on a single laptop as described above. These extra Paillier operations require on average 600 milliseconds which almost double our running time for \ud835\udf07 = 128. Note that the network cost for the extra protocol round is not included.  First, our optimized implementation only needs memory for the two-dimensional array, i.e. 3\ud835\udf07 ciphertexts, since the multiplication procedure is based on a pre-computed plan and applied within the array. Cheon et al. also need 3 times \ud835\udf07 ciphertexts but additional memory to compute \ud835\udf07 products [15]. Second, the implementation of our protocol (Algorithm 8) by another party is much easier since the construction of the multiplication plan does not have to be implemented but the pre-computed results can be taken from a public source. Our FHE evaluation in Algorithm 12 is given as parameter the dependency list precomputed by Algorithm 11. Cheon et al. and our scheme have three main steps. In the first step, we fill the array as explained in Figure 7 and Cheon et al. compute three arrays",
                        "In the second step, we aggregate the array elements as in Figure 8 using a precomputed dependency list and Cheon et al. compute products \ud835\udc5d \ud835\udc56 = \ud835\udf07 \ud835\udc57=\ud835\udc56+1 \ud835\udc67 \ud835\udc57 efficiently (i.e., reusing prefix results) while keeping the multiplicative depth logarithmic. This computation is illustrated in Appendix D and Algorithm 13. In the last step, we sum up all results in the third column and Cheon et al. compute \ud835\udc51 \ud835\udc56 = \ud835\udc51 \ud835\udc56 \u2022 \ud835\udc5d \ud835\udc56 and finally \ud835\udf07 \ud835\udc56=1 \ud835\udc51 \ud835\udc56 . In both cases the second step is the most complicated. However, the pre-computation of the dependency list makes our second step easy to implement and to evaluate, as it is done once and offline, such that for the online computation it is enough to implement and evaluate Algorithm 12. The product computation (Algorithm 13) in Cheon et al. 's scheme requires constructing a binary tree of product and process it recursively. This cannot be precomputed, must be implemented with the entire algorithm itself and requires extra memory for storing \ud835\udf07 log \ud835\udf07 ciphertexts during evaluation. "
                    ],
                    "subsections": []
                }
            ]
        },
        {
            "title": "APPLICATIONS",
            "paragraphs": [
                "Integer comparison is a fundamental building block in many MPC protocols. In this section, we describe few applications where our scheme can improve the performance. We estimate this improvement to be proportional to the number of comparison operations required in the respective application. The following is of course not exhaustive and gives only an overview of applications. Machine Learning (ML). ML classifiers are valuable tools in many areas such as healthcare, finance, spam filtering, intrusion detection, remote diagnosis, etc [50]. They usually require access to privacy-sensitive user's data such as medical records, financial situation, location information, etc. On the one hand, the model itself may contain sensitive data. On the other hand, it may have been built on sensitive data. White-box and sometimes even black-box access to an ML model allows so-called model inversion attacks [23,44,52], which can compromise the privacy of the training data. Privacy-preserving techniques are therefore critically needed to protect the privacy of the model and user's data. Many applications in ML require integer comparison. For example, a decision tree (DT) is a common and very popular classifier that requires integer comparison to classify inputs. Some private DT schemes rely on DGK [42,51] or on FHE [45]. In Appendix G, we evaluate the private DT scheme of Tai et al. [42] using our scheme and compared it to [18,49]. In [46], Tueno et al. proposed an application for range queries that uses search tree structure to implement order-preserving encryption (OPE). They overcame the limitation of private-key OPE by using garbled circuit or DGK comparison to traverse the search tree.",
                "Benchmarking and Auction. In this case, the goal is to securely compute the \ud835\udc58 th -ranked element in a distributed setting. That is, given \ud835\udc5b parties each holding a private integer, the problem is to securely compute the element ranked \ud835\udc58 (for a given \ud835\udc58 such that 1 \u2264 \ud835\udc58 \u2264 \ud835\udc5b) among these \ud835\udc5b integers. The computation should reveal to the parties only the \ud835\udc58 th -ranked element (or the index of party holding it) and nothing else. The computation of the \ud835\udc58 th -ranked element has applications in benchmarking, where a company is interested in knowing how well it is doing compared to others, or in auctions where bidders are interested in knowing the highest bid. In fact, the DGK protocol were proposed with online auction as application [18]. Privacy-preserving online auction was the world's first large scale application and commercial use of MPC. A team around the DGK authors developed, in 2008, a double auction solution for the Danish industry, which allowed farmers (sugar beets producers) and Danisco (the only sugar beets processor) to compute a so-called market clearing price (price per unit of the commodity that is traded) in a privacy-preserving way [2,10]. The main building block in this solution was integer comparison. Other work, including [9], [8], [48], have proposed protocols for computing the \ud835\udc58 th -ranked element using the DGK comparison protocol. In [48], Tueno et al. also proposed a variant of their protocol based on SHE/FHE and using the comparison scheme of Cheon et al. [15]. Biometrics. Biometrics are used to authenticate or identify users.",
                "In an enrollment phase, biometric features are scanned and stored.",
                "During the authentication or identification phase, the same features are scanned again and compared with the stored ones. On the one hand, biometric images are never perfect, and therefore a match is determined by computing a proximity to the stored images. This implies that threshold comparisons are required in biometric systems [35]. On the other hand, biometric information is highly sensitive and subject to privacy issues due to to possible misuse, lost or theft of biometric data. This gives rise to privacy-preserving biometric matching, that compute on biometric data without revealing sensitive information. Blanton and Gasti [7] proposed such a protocol for iris and fingerprint identification using the DGK protocol."
            ],
            "subsections": []
        },
        {
            "title": "CONCLUSION",
            "paragraphs": [
                "We proposed a new protocol for secure integer comparison of two parties using the evaluation of binary trees. Our approach is based on HE and is a non-interactive solution which can be used for a broad range of applications or as a subroutine for larger protocols. We theoretically presented an FHE and an AHE mode with several extensions and optimizations and implemented both variants using improved data representations and evaluations to reduce the computational overhead.",
                "can see its own input \ud835\udc66 or it can be encrypted as well. For simplicity, we consider the setting where the comparison result is revealed only to the client and the server input is not encrypted. In this case, security means that the client learns only the comparison bit and the server learns nothing. We then construct simulators Sim gt C (\ud835\udc65, \ud835\udc4f = [\ud835\udc65 \u2265 \ud835\udc66]), Sim gt S (\ud835\udc66, \u2205), for the client and the server. The goal of the simulator is to generate a view that is indistinguishable from the party's view in the real protocol. That is, for each message \ud835\udc5a that a party sees, the simulator should be able to generate an indistinguishable message \ud835\udc5a \u2032 using only the information available to that party, e.g., input, output, public and private key.",
                "Client Simulator FHE: In the real protocol, the client sees encryptions of its input bits x = \ud835\udc65 Server Simulator FHE: In the real protocol, the server sees encryptions of the client input bits x = \ud835\udc65 [1], . . . , \ud835\udc65 [\ud835\udf07] and ciphertexts generated during the evaluation of the tree. The simulator Sim gt S (\ud835\udc66, \u2205) has access to the server input and knows the public key, but not the private key. Hence, it can encrypt its own input bits. By assumption, the encryption scheme is IND-CPA secure, which means that each ciphertext is indistinguishable from a random value with the same length as the ciphertext. For all ciphertexts (either received from the client or resulting from the tree evaluation), the simulator just chooses a random element in the ciphertext space, i.e., encryption of a random plaintext.",
                "Client Simulator AHE: The difference to the FHE case is that the client does not get an encrypted bit from the server, but a set of ciphertexts c[1], . . . , c[\ud835\udf07] where either all ciphertexts encrypt random plaintexts, or exactly one (at a random position) encrypts 0 while the remaining ones encrypt random plaintexts. That is, the simulation of the encrypted client bits x = \ud835\udc65 Server Simulator AHE: The simulation is similar to the FHE case. \u25a1 Lemma 6.5. Let \ud835\udc66 be an integer of length \ud835\udf07. The half-pruned tree of \ud835\udc66 has \ud835\udf07 + 1 leaves and \ud835\udf07 inner nodes.",
                "Proof. The depth of the tree is obviously \ud835\udf07. A complete tree with depth \ud835\udf07 has 2 \ud835\udf07 + 2 \ud835\udf07 -1 nodes. While constructing the half-pruned cmp-tree as explained above, we start from the root with depth 0 and stop at a node with depth \ud835\udf07 -2, since node with depth \ud835\udf07 -1 have only leaves as child nodes. In each step at depth \u210e \u2208 {0, . . . , \ud835\udf07 -2}, we replace a subtree, that has 2 \ud835\udf07-\u210e -1 nodes, with a leaf. That is, at depth \u210e \u2208 {0, . . . , \ud835\udf07 -2}, we remove 2 \ud835\udf07-\u210e -2 nodes. Then the numbers of nodes remaining in the tree is:"
            ],
            "subsections": []
        },
        {
            "title": "Now we have:",
            "paragraphs": [
                "We also have",
                "By construction, there are \ud835\udf07 inner nodes and hence \ud835\udf07 + 1 leaves. \u25a1 Lemma 6.7. The normal cmp-tree of \ud835\udc66 and a half-pruned cmp-tree of \ud835\udc66 are equivalent.",
                "Proof. Given an arbitrary \ud835\udc66 of length \ud835\udf07. By construction, the normal cmp-tree has depth \ud835\udf07 since the leftmost path is the longest one. The same holds for the definition of a half-pruned cmp-tree.",
                "For the normal cmp-tree, there are \ud835\udf07 inner nodes on the leftmost path (including the root node). Since every node's right child is a leaf node, there are exactly \ud835\udf07 inner nodes. Moreover, we have \ud835\udf07 + 1 leaf nodes because every inner node has exactly one child leaf node (the right child) except the deepest inner node where both children are leaf nodes. Lemma 6.5 shows that a half-pruned tree has the same number of nodes and therefore they are equivalent. \u25a1 Theorem 6.8. Let \ud835\udc66 and \ud835\udc65 be integers of length \ud835\udf07. If the encryption scheme is correct, then the comparison protocol is correct.",
                "Proof. By Lemma 6.7, we already know that the normal-cmp tree and a half-pruned cmp-tree are equivalent. Moreover, we can transfer one representation into another without changing the result.",
                "By definition, a normal cmp-tree is half-pruned. It remains to show that it is also a cmp-tree. We assume that the encryption scheme is FHE. The case for AHE is similar. If \ud835\udc65 and \ud835\udc66 are equal, then \ud835\udc65 traverses the normal cmp-tree of \ud835\udc66 on the path as \ud835\udc66 itself.",
                "Otherwise, \ud835\udc65 and \ud835\udc66 have a common prefix that labels a path from the root to a node \ud835\udc63 with depth \u210e such that \ud835\udc66 traverses the tree to the left of \ud835\udc63 while \ud835\udc65 traverses to the right of \ud835\udc63. By construction of the normal cmp-tree, the left edge from \ud835\udc63 is labelled with the bit \ud835\udc66 [\u210e], while the right edge is labelled with the bit 1 -\ud835\udc66",
                ", then \ud835\udc63\ud835\udc5f is labelled with 1 (resp. 0) and the path to \ud835\udc63\ud835\udc5f evaluates to 1 (resp. 0). On all other paths at least one edge label differs from the bit of \ud835\udc65 at the same position such that the path evaluates to 0. This is sufficient to conclude whether \ud835\udc65 \u2265 \ud835\udc66 or not.",
                "For the other direction, we have to transfer a half-pruned cmptree into a normal cmp-tree. We start at the root node. If the left child node is not a leaf, we proceed with the left child. If not, we switch the below sub-trees and proceed with the left child which is now a leaf node. We repeat this procedure until we reach the tree's depth. The resulting structure fulfills all the requirements of a normal cmp-tree and still represents the same value \ud835\udc66. \u25a1 Lemma 6.9. Let (\ud835\udc4f 0 , \u2022 \u2022 \u2022 , \ud835\udc4f \ud835\udc59 ) \u2208 {-1, 0, 1} \ud835\udc59+1 such that there exist at least one \ud835\udc4f \ud835\udc56 \u2260 0 then it holds \ud835\udc59 \ud835\udc56=0 \ud835\udc4f \ud835\udc56 for \ud835\udc56 = 0 to \ud835\udf07 -(\ud835\udc5d + 1) do ",
                "This concludes that \ud835\udc4c strictly dominates \ud835\udc4b and therefore, the whole sum can never be 0. \u25a1"
            ],
            "subsections": []
        },
        {
            "title": "B ALGORITHMS FOR FHE INSTANTIATION",
            "paragraphs": [
                "In this section, we describe in detail our leveled FHE instantiation that uses the pre-computation of the dependency lists for the multiplication to keep a logarithmic multiplicative depth. We recall that this pre-computation depends only on the input length \ud835\udf07 and can be computed a single time and stored for future evaluations of integer comparison. The pre-computation consists of the following three basic steps:",
                "\u2022 Computation of the paths. Using the Illustration in Figure 8, we use a table representation of the tree as explained above and compute the paths: (1, 4, 7, 10), (1,4,8,9), (1,5,6), (2,3). This computation is illustrated in Algorithm 9. \u2022 Computation of the dependency lists for each single path. We compute the dependency lists for each path using Algorithm 10. \u2022 Computation of the dependency lists for the whole tree. This is done using Algorithm 11.",
                "To evaluate the integer comparison of two encrypted inputs, we use Algorithm 12. A detailed analysis of the number of multiplications needed is provided in the next section."
            ],
            "subsections": []
        },
        {
            "title": "C ANALYSIS NUMBER OF MULTIPLICATIONS",
            "paragraphs": [
                "In this section, we analyse in detailed the number of multiplications for our leveled FHE Instantiation. To ease the understanding of the derivation of the number of multiplications, we present an example of bit-length 8 and apply the optimized implementation described if \ud835\udc5d = 0 then  \ud835\udc50 \u2190 ((\ud835\udc65 -1) mod 3) + 1  9.",
                "Leftmost Path. The number of multiplications on the leftmost path are illustrated in Figure 10a. Our algorithm divides each path at half and repeats this procedure with the sub-paths until every node is connected. Going the other way around, this leads to one multiplication for each pair (In the example: 1 to 4, 7 to 10, 13 to 16 and 19 to 22), one multiplication for each quadruple (In the example: In general, we have Right Children. For the representation of the multiplications on the paths to the right leaves, we refer to Figure 10b. Note that we removed some of the numbers and arrows to ease the understanding of the analysis. We split the analysis for the right children into two parts.",
                "For each row we have exactly one edge connecting the second with third column, that is \ud835\udf07 multiplications.",
                "The multiplications from the first with the third column are more complicated. To analyze their total number, we consider the labels on the leftmost path and make use of the following observation. A label has at least one arrow to the right because it is on the paths to right leaves which have their last edge label in the second column and their leaf label in the third column. If it is multiplied with the following label on the leftmost path (first column), we do not have to consider it further since it is in the multiplication chain for any right child (third column) below. Therefore, such a label has only one multiplication with right children, for example 1, 7 or 19 in the example (marked with solid arrows). Based on the analysis of the leftmost path, there are \ud835\udf07/2 such labels. For every second label, we have at least two multiplications to the right because its information is lost in the following row since we do not multiply with it. In the example, it holds for 4 and is marked with a dashed line. The next step is 10 which is needed for the following 4 rows and marked with a dash-dotted arrow. Following this procedure, we need 2 \ud835\udc56-1 multiplications of a label with \"order\" \ud835\udc56. Order refers to the procedure of 2 \ud835\udc56 -tuples from the leftmost path. Now, we can count the number of multiplications analogously to the leftmost path and obtain on encrypted inputs and constant multiplication. It can be implemented using secret sharing or AHE. Some ABB-based protocols ( [17] and the improved version [39]) have some resemblance with our scheme as they rely on the bit decomposition of the inputs, and compute equality of bits and aggregate them. Other schemes rely on the extraction of the most significant bit of the difference of both inputs [4,20].",
                "When implemented with secret sharing, ABB-schemes have a very fast local computation and allow unconditional security. They support several parties (more than 2), where parties have symmetric role in the protocol, i.e. each party perform the same computation on secret-shared inputs. However, they also require an offline phase to generate so-called Beaver triples; they require secure channel to avoid share reconstruction by an eavesdropper; they usually run in asymptotically multiple rounds, which can affect the overall performance.",
                "Our scheme is secure as long as the underlying encryption scheme is secure. We support only 2 parties, where each has a specific role: one party (server or evaluator) evaluates the tree and the other one (client or decryptor) decrypts the result. We do not need an offline phase, but only a one-time setup phase, where the decryptor generates a pair of private and public key and publishes the public key. We do not require a secure channel as each message is already encrypted. We have exactly a single round, where the client sends its encrypted input to the server and gets an encrypted result. An overview comparison is summarized in Table 5. [4,20,39 "
            ],
            "subsections": []
        },
        {
            "title": "G EVALUATION OF DECISION TREES",
            "paragraphs": [
                "A decision tree (DT) is a common and very popular classifier that consists of decision nodes, each marked with a test condition, and leaf nodes, each marked with a classification label. Each test condition is actually a GT or LT comparison between a threshold value and an attribute of the input to be classified. In a private DT setting, a server holds a private tree model and a client holds a private attribute or feature vector. The goal is to classify the client's input using the server's model such that the result of the classification is revealed only to the client and nothing else is revealed neither to the client nor the server. Wu et al. [51] and Tai et al. [42] proposed a private DT protocol, that uses the DGK comparison and AHE. We implemented the private decision tree protocol of Tai et al. [42] in Java. Our implementation is not optimized and focuses on the main computation (GT comparison of features and thresholds, and paths aggregation), i.e., we ignored e.g. zero-knowledge proof, compression of elliptic curve points or network communication. We then evaluated the decision tree protocol instantiating the GT comparison with DGK [18], Veugen [49] and our scheme and observed a performance result comparable to Table 3. Basically, one can expect an improvement proportional to the number of comparisons. The result averaged over 100 runs is shown in Table 6 for a decision tree with depth \ud835\udc51 = 17, number of decision nodes \ud835\udc5a = 58 and number of features \ud835\udc5b = 57, which corresponds to the parameters of the Spambase dataset as in [42,45,47,51]. We used bitlength \ud835\udf07 = 8, 16, 32, 64, 128 for the features and thresholds. "
            ],
            "subsections": []
        },
        {
            "title": "ACKNOWLEDGMENTS",
            "paragraphs": [
                "We thank the anonymous PoPETs reviewers for their constructive feedback on this paper. This research work was supported by the German Federal Ministry for Economic Affairs and Climate Action (BMWK) in the project Trade-EVs II, FKZ:01MV20006A."
            ],
            "subsections": []
        },
        {
            "title": "A POSTPONED PROOFS",
            "paragraphs": [
                "This section provides missing proofs for theorems and lemmas. Theorem 5.2. Let \ud835\udc66 and \ud835\udc65 be integers of length \ud835\udf07. If the encryption scheme is IND-CPA secure, then the comparison protocol is secure in the semi-honest model. Proof. For our scheme, we can consider settings where the comparison result is either revealed only to the client, or to both client and server, or secret-shared to both. Additionally, the server"
            ],
            "subsections": []
        },
        {
            "title": "D ITERATIVE PRODUCTS COMPUTATION",
            "paragraphs": [
                "In this section, we describe our implementation of the product computation for Cheon et al. 's scheme. We start by recalling the task to be computed. Given integers \ud835\udc67 1 , . . . , \ud835\udc67 \ud835\udc5b , we want to compute products \ud835\udc43 \ud835\udc56 = \ud835\udc56 \ud835\udc57=1 \ud835\udc67 \ud835\udc57 , for \ud835\udc56 = 2, . . . , \ud835\udc5b with logarithmic multiplicative depth. Cheon et al. [15] propose to compute the products using a recursive algorithm that builds a binary tree of products. That is, we start with \ud835\udc67 1 , . . . , \ud835\udc67 \ud835\udc5b , compute products",
                ". . for the first level and continue this recursively until there is a single element left in the last level. At each level, if the number of elements is odd, then the last element is left alone. This yields products for positions which are a power of 2. In the next step, we compute the missing products, i.e., for positions \ud835\udc56 that are not a power of 2, based on a multiplication of the results for the power of two cases and the power of 2 decomposition of \ud835\udc56.",
                "Our implementation described in Algorithm 13 stores the binary tree of products in a matrix \ud835\udc4e[] [] with log(\ud835\udc5b) -1 rows and \ud835\udc5b/2 columns, where row \ud835\udc56 contains \ud835\udc5b/2 \ud835\udc56 non null elements, for \ud835\udc56 = 1, . . . , log(\ud835\udc5b) -1. Then, the first column contains the products \ud835\udc43 \ud835\udc56 for \ud835\udc56 a power of 2.",
                "For the remaining positions \ud835\udc56 not a power of 2, we decompose \ud835\udc56 in its power of 2: \ud835\udc60 1 , . . . , \ud835\udc60 \ud835\udc58 such that \ud835\udc60 \ud835\udc57 = 2 \ud835\udc52 \ud835\udc57 , \ud835\udc56 = \ud835\udc60 1 + . . . + \ud835\udc60 \ud835\udc58 and \ud835\udc60 1 > . . . > \ud835\udc60 \ud835\udc58 . Then, we use each \ud835\udc60 \ud835\udc57 to select a corresponding product \ud835\udc44 \ud835\udc57 from the matrix computed above. We observe that if",
                ". Otherwise, we compute the row \ud835\udc5f and column \ud835\udc50 of the product corresponding to \ud835\udc44 \ud835\udc57 , i.e., \ud835\udc44 \ud835\udc57 = \ud835\udc4e[\ud835\udc5f ] [\ud835\udc50] as follows:",
                "\u2022 we remark that if \ud835\udc60 \ud835\udc57 = 2 \ud835\udc52 , then the corresponding product lies in the row \ud835\udc5f = \ud835\udc52 of the matrix. \u2022 for the column, if \ud835\udc57 = 1, then it is the first column, i.e., \ud835\udc50 = 1 otherwise we compute the column as \ud835\udc50 = \u2308\ud835\udc61/\ud835\udc60 \ud835\udc57 \u2309 -1 where \ud835\udc61 = \ud835\udc60 1 + . . . + \ud835\udc60 \ud835\udc57 .",
                "Finally, we collect all the products (\ud835\udc44 1 , . . . , \ud835\udc44 \ud835\udc58 ) and apply again a multiplication with logarithmic depth to compute \ud835\udc44 1 \u2022 . . . \u2022 \ud835\udc44 \ud835\udc58 using the binary tree of products as above."
            ],
            "subsections": []
        },
        {
            "title": "E CHOICE OF AHE SCHEME",
            "paragraphs": [
                "For AHE, we choose ElGamal encryption [19] that we implement as elliptic curve ElGamal (ECE) [33,34]. We briefly describe it in the following and refer to the literature for more details. Let G be an elliptic curve group over F(\ud835\udc5d \ud835\udc5b ) generated by a point \ud835\udc43 of prime order \ud835\udc5d. ECE consists of the following algorithms:",
                "\u2022 Key Generation pk, sk \u2190 KGen(\ud835\udf06): This algorithm randomly chooses \ud835\udc60 \u2208 Z \ud835\udc5d and outputs sk = \ud835\udc60 and pk = \ud835\udc60 \u2022 \ud835\udc43 as private and public key. The above scheme is indeed AHE. If"
            ],
            "subsections": []
        },
        {
            "title": "Algorithm 13 Iterative Products Computation",
            "paragraphs": [
                "Require: array \ud835\udc67 = \ud835\udc67 1 , . . . , \ud835\udc67 \ud835\udc5b 1: let \ud835\udc43 be an array of \ud835\udc5b -1 elements 2: let \ud835\udc4e[(1, . . . , log(\ud835\udc5b) -1), (1, . . . , \ud835\udc5b/2)] be a matrix 3: for \ud835\udc56 = 1 to log(\ud835\udc5b) do 4:",
                "for \ud835\udc57 = 1 to \ud835\udc5b/2 \ud835\udc56 ; \ud835\udc57 = \ud835\udc57 + 2 do 5:",
                "if \ud835\udc57 + 1 < \ud835\udc5b then 6:",
                "\ud835\udc5f \u2190 \ud835\udc56 if \ud835\udc56 = 1 then 9:",
                "else 11:",
                "end if 39: return \ud835\udc43 While the decryption requires the computation of the discrete logarithm, we stress that in our comparison protocol, computing the discrete logarithm is not necessary since we are looking for a ciphertext of zero. A ciphertext of zero has the form c = (\ud835\udc5f \u2022\ud835\udc43, \ud835\udc5f \u2022 pk). Hence, checking if the random ciphertext c = (\ud835\udc44 1 , \ud835\udc44 2 ) is encrypting 0, is efficiently done by computing \ud835\udc44 = \ud835\udc44 2 -\ud835\udc44 1 \u2022 sk and then checking if \ud835\udc44 is the neutral element of G that for an elliptic curve is the point at infinity."
            ],
            "subsections": []
        },
        {
            "title": "F MOST RECENT WORK",
            "paragraphs": [
                "Most recent work include protocols [4,20,39] based on the arithmetic black-box (ABB) model. The ABB model allows addition"
            ],
            "subsections": []
        }
    ]
}