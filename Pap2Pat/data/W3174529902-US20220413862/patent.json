{
    "id": "US20220413862",
    "authors": [
        "Bin Ren",
        "Wei Niu"
    ],
    "title": "METHOD FOR ACCELERATING DEEP NEURAL NETWORKS EXECUTION WITH ADVANCED OPERATOR FUSION",
    "date": "2022-06-16 00:00:00",
    "abstract": "This disclosure has presented a new loop fusion framework called DNNFusion. The key advantages of DNNFusion include: 1) a new high-level abstraction comprising mapping type of operators and their combinations and the Extended Computational Graph, and analyses on these abstractions, 2) a novel mathematical-property-based graph rewriting, and 3) an integrated fusion plan generation. DNNFusion is extensively evaluated on 15 diverse DNN models on multiple mobile devices, and evaluation results show that it outperforms four state-of-the-art DNN execution frameworks by up to 8.8\u00d7 speedup, and for the first time allows many cutting-edge DNN models not supported by prior end-to-end frameworks to execute on mobile devices efficiently (even in real-time). In addition, DNNFusion improves both cache performance and device utilization, enabling execution on devices with more restricted resources. It also reduces performance tuning time during compilation.",
    "sections": [
        {
            "title": "DESCRIPTION",
            "paragraphs": [],
            "subsections": [
                {
                    "title": "BACKGROUND",
                    "paragraphs": [
                        "Deep Neural Networks (DNNs) have emerged as the core enabler of many major applications on mobile devices. To achieve high accuracy, DNN models have become increasingly deep with hundreds or even thousands of operator layers, leading to high memory and computational requirements for inference. Operator fusion (or kernel/layer fusion) is critical for optimization in many state of the art DNN execution frameworks that aim to improve the efficiency of the DNN inference. However, these frameworks usually adopt fusion approaches based on certain patterns that are too restrictive to cover the diversity of operators and layer connections, especially those seen in many extremely deep models. Polyhedral-based loop fusion techniques work on a low-level view of the computation without operator-level information, and can also miss potential fusion opportunities.",
                        "The past ten years have witnessed a resurgence of Machine Learning, specifically in the form of Deep Learning. Deep Neural Networks (DNNs) such as Convolution Neural Networks (CNN) and Recurrent Neural Networks (RNN) serve as the state-of-the-art foundation and core enabler of many applications that have only emerged within the last few years and yet have become extremely popular among all users of computing today. Behind the success of deep learning are the increasingly large model sizes and complex model structures that require tremendous computation and memory resources. There is a difficult trade-off between increasing complexity of DNNs (required for increasing accuracy) and deployment of these DNNs on resource constrained mobile devices (required for wider reach).",
                        "In recent years, there has been a significant emphasis on optimizing the execution of large DNNs. Operator fusion (or kernel/layer fusion) has been a common approach towards improving efficiency of DNN execution. The basic idea of such fusion is the same as the traditional loop fusion done by optimizing compilers, and they lead to the following benefits: (i) eliminating unnecessary materialization of intermediate results, (ii) reducing unnecessary scans of the input; and (iii) enabling other optimization opportunities. Traditional end-to-end frameworks like TensorFlow Lite, TVM, MNN, and Pytorch-Mobile all have operator fusion optimizations, which are broadly based on recognizing certain fusion patterns. These transformations have generally been based on a representation called computational graph, which views the application as a set of operations on tensors, and representation of dependencies in the form of consumption of tensor(s) output by an operation by another operation.",
                        "In this paper, we observe that the fusion patterns considered in the past work are too restricted to cover the diversity of operators and layer connections that are emerging. For example, ONNX (Open Neural Network Exchange) lists 167 distinct operators, and creating fusion patterns based on their combinations is unlikely to be a feasible approach. At the same time, traditional compiler loop transformations (including fusion) work on a low-level view of the computation, i.e., loop (indices) and dependence between array elements. More recent work on loop fusion has been based on polyhedral analysis, with several different resulting algorithms. Polyhedral analysis, while providing an excellent foundation to rigorously reason the legality of, and explore the space of, loop transformations, can be an \u201coverkill\u201d to capture the relatively simple data structures (tensors) and operations (without loop-carried dependencies) in DNNs. Moreover, polyhedral analysis is normally limited to affine-loop analysis and transformations (although latest efforts do extend it to certain non-affine loop optimizations), and cannot capture certain operation (combinations) in DNNs. An example will be a combination of Gather, which copies input to output indirectly using an index array followed by Flatten, which changes the dimensionality of a tensor. Finally, the operator view in computational graphs can enable us to exploit properties of these computations, which may be lost when a lower-level view of the computation is considered.",
                        "To address these challenges, we describe herein a novel and extensive loop fusion framework which we call DNNFusion."
                    ],
                    "subsections": [],
                    "outline_long": [
                        "introduce deep neural networks",
                        "motivate operator fusion",
                        "limitations of existing fusion approaches",
                        "describe resurgence of machine learning",
                        "motivate need for optimizing DNN execution",
                        "describe traditional operator fusion optimizations",
                        "limitations of polyhedral-based loop fusion",
                        "motivate need for novel fusion framework"
                    ],
                    "num_characters": 4288,
                    "outline_medium": [
                        "motivate deep neural networks",
                        "limitations of operator fusion approaches",
                        "importance of optimizing DNN execution",
                        "challenges of existing fusion techniques"
                    ],
                    "outline_short": [
                        "motivate deep neural networks",
                        "limitations of operator fusion approaches"
                    ]
                },
                {
                    "title": "SUMMARY",
                    "paragraphs": [
                        "Herein we describe a method for accelerating deep neural networks comprising the steps of: classifying operators into one of five high-level abstract types; performing a mapping type analysis for each paired input and input; classifying mapping types into one of three classes; providing a computational graph; rewriting said computational graph; and generating and optimizing the fusion code.",
                        "This approach works at an operator view of DNNs, but expands fusion opportunities by developing a classification of both individual operators and their combinations. In addition, DNNFusion includes (i) a novel mathematical property-based graph rewriting framework to reduce evaluation costs and facilitate subsequent operator fusion; (ii) an integrated fusion plan generation that leverages high-level analysis and accurate light-weight profiling, and (iiii) additional optimizations during fusion code generation.",
                        "The methods have been extensively evaluated on 15 DNN models with various types of tasks, model sizes, and layer counts. The evaluation results demonstrate that DNNFusion can identify up to 8.8\u00d7 higher fusion opportunities and can outperform prior art DNN execution frameworks with nearly 10\u00d7 speedup. The memory requirement reduction and speedups can enable the execution of many of the target models on mobile devices, and can even make them part of a real-time application.",
                        "When practical, similar reference numbers denote similar structures, features, or elements."
                    ],
                    "subsections": [],
                    "outline_long": [
                        "summarize method for accelerating DNNs",
                        "highlight advantages of DNNFusion approach"
                    ],
                    "num_characters": 1480,
                    "outline_medium": [
                        "summarize DNNFusion method"
                    ],
                    "outline_short": [
                        "outline DNNFusion method"
                    ]
                },
                {
                    "title": "DETAILED DESCRIPTION OF THE INVENTION",
                    "paragraphs": [
                        "This paper presents DNNFusion, a rigorous and extensive loop fusion framework that can exploit the operator view of computations in DNNs, and yet can enable a set of advanced transformations. The core idea is to classify operators into different types, and develop rules for different combinations of the types, as opposed to looking for patterns with specific combination of operations. Particularly, we first classify the existing operations in a DNN into several groups based on the mapping between their input and output, such as One-to-One, One-to-Many, and others. We also enhance the computational graph representation into the Extended Computational Graph (ECG) representation, where the type (and other properties) of the operation are explicitly noted. Then, we design a mapping type analysis to infer the profitability of fusing operations of different combinations of these types of operators, binning the combination into three groups: likely profitable (and legal), likely not profitable, and ones where profitability may need to be determined through profile information.",
                        "Next, on the ECG representation, we apply a series of graph rewriting rules that we have developed. These rules exploit the mathematical properties of the operations and have a similar flavor to the classical optimization called strength reduction. Unlike traditional compiler work, however, we apply these rules on operations on tensors (and not scalars) and our set of rules go well beyond the traditional ones. The rest of our framework comprises algorithms for determining fusion of specific operations (based on certain heuristics) and generating optimized fused code. Almost each fusion generates a new operator (and its implementation) that is not present in the original library; however, once a new operator is generated, its implementation can be reused when the same pattern is detected in the same or a different model. Overall, we show that an operator view of the DNN can enable rigorous optimizations, beyond what will be possible with a lower-level view of the computation or the existing (simplistic) work on applying a small set of fusion patterns on the operator view.",
                        "In summary, this paper makes the following contributions:\n\n\n- It designs high-level abstractions (including mapping type analysis\n  and ECG) for operator fusion by leveraging highlevel DNN operator\n  information. The approach can handle a diversity of operators and yet\n  enable aggressive optimizations.\n- It proposes a novel mathematical-property-based graph rewriting to\n  simplify ECG structure, optimize DNN computations, and facilitate\n  subsequent fusion plan generation.\n- It presents an integrated fusion plan generation by combining the\n  benefit of efficient machine-independent mapping type analysis while\n  leveraging a profiling result database.\n- It implements optimized fusion code generation, integrating the\n  approach into a state-of-the-art end-to-end DNN execution framework.\n  The optimized framework with operator fusion is called DNNFusion.",
                        "DNNFusion is extensively evaluated on 15 cutting-edge DNN models with 5 types of tasks, varied model sizes, and different layer counts on mobile devices. Comparing with four popular state-of-the-art end-to-end DNN execution frameworks, MNN, TVM, TensorFlow-Lite, and Pytorch-Mobile, DNNFusion achieves up to 8.8\u00d7 more loop fusions, 9.3\u00d7 speedup with our proposed advanced operator fusion. Particularly, DNNFusion for the first time allows many latest DNN models that are not supported by any existing end-to-end frameworks to run on mobile devices efficiently, even in real-time. Moreover, DNNFusion improves cache performance and device utilization\u2014thus, enabling execution on devices with more restricted resources\u2014and reduces performance tuning time during compilation.",
                        "This section presents a study that motivates our work, by demonstrating that it is challenging to execute deep(er) neural networks efficiently, particularly on resource-constraint mobile devices, due to the high memory and computation requirements.",
                        "As we stated earlier, there has been a trend towards deeper DNNs. With increasing amount of computation, there has also been a trend towards reducing the computation by reducing the weight size. Consider the well-known Natural Language Processing (NLP) model, BERT as an example. TFLite takes 985 ms to inference BERT on the latest CPU of Snapdragon 865. In recent efforts (MobileBERT, GPT-2), machine learning researchers have addressed this issue by reducing the weight size on each layer and thus training thinner and deeper models to balance the computation workload and model accuracy.",
                        "However, we have observed that the depth of the model is the critical impediment to efficient execution. Our experimental study has correlated execution efficiency with the total amount of computation and the number of layers (Table 2). Particularly, we can see that although DistilBERT and VGG-16 have a similar number of computations (while having 457 and 51 layers, respectively), DistilBERT's execution performance (78 GFLOPs/S) is much worse than VGG's (320 GFLOPs/S). This is mainly because of two reasons. First, models with more layers usually generate more intermediate results, thus increasing the memory/cache pressure. Second, deep models usually have an insufficient amount of computations in each layer, thus degrading the processor's utilization, particularly for GPUs. Operator fusion can be an effective technique to reduce memory requirements and improve efficiency, and is the focus of our study.",
                        "1. Classification of DNN Operators and Fusion Opportunity Analysis",
                        "This section establishes the basis for our approach, by classifying DNN operators and their combinations.",
                        "1.1 DNN Operators Classification",
                        "This work carefully studied all operators supported by a popular (and general) DNN ecosystem ONNX (Open Neural Network Exchange), and finds that the mapping relation between (each) input and output of each operator is critical to determine both the profitability and correct implementation of fusion optimization. Moreover, it is possible for us to classify all operators into five high-level abstract types based on the relationship between input elements and output elements. These five types are One-to-One, One-to-Many, Many-to-Many (which includes Many-to-One, but we do not consider it separately here), Reorganize, and Shuffle. This classification serves as the foundation of our proposed fusion framework. Table 1 shows more details of this operator classification and gives one or two representative examples for each mapping type. If an operator has only one input or multiple inputs with the same mapping type to the output, the mapping type of this operator is decided by its any input/output pair. If multiple input/output pairs with varied mapping types exist, this operator's mapping type is decided by the more complex mapping type.",
                        "Assuming each input element can be denoted as x [d1, . . . , dn], where x means the operand of an operator and d1, . . . , dn denotes the index for an element of an operand, the mapping types between one input and one output are classified as follows.\n\n\n- One-to-One: There is a set of functions F, \u0192\u2081, . . . , \u0192_(n), such\n  that",
                        "y[d1, . . . , dn]=F(x[\u01921(d1), . . . , \u0192n(dn)])",
                        "and there is a 1-1 mapping between each [d1, . . . , dn] and the corresponding [\u01921(d1,) . . . , \u0192n(dn)] used to compute it.\n\n\n- One-to-Many: There is a set of functions F, \u0192\u2081, . . . , \u0192_(n), such\n  that:",
                        "y[e1, . . . , em]=F(x[\u01921(d1), . . . , \u0192n(dn)])",
                        "where m>n, and there is a One-to-Many relationship between [\u01921(d1), . . . , \u0192n(dn)] and [e1, . . . , em].\n\n\n- Many-to-Many: There is a set of functions \u0192\u2081\u00b9, . . . , \u0192_(n)\u00b9, . . .\n  \u0192\u2081^(k), . . . , \u0192_(n)^(k), such that:",
                        "y[e1, . . . , em]=F(x1[\u019211(d1), . . . , \u0192n1(dn)], . . . , xk[\u01921k(d1), . . . , \u0192kk(dn)]).\n\n\n- Reorganize: We have",
                        "y[e1, . . . , em]=x[\u01921(d1), . . . , \u0192n(dn)]",
                        "and there is a 1-1 relationship between each [e1, . . . , em] and the corresponding [\u01921(d1), . . . , \u0192n(dn)].\n\n\n- Shuffle: There is a set of functions F, \u0192\u2081, . . . , \u0192_(n), where F is\n  a permutation function, such that,",
                        "y[e1, . . . , en]=x[\u01921(dF(1)), . . . , \u0192n(dF(n))].",
                        "1.2 Fusion Opportunity Analysis",
                        "Based on the mapping type of each operator, this work proposes a new fusion analysis. The basic idea is that given two fusion candidate operators with a certain combination of mapping types, it is possible to: 1) infer the mapping type of the resulting fused operation; and 2) simplify the profitability evaluation and correct implementation of this fusion.",
                        "Table 3 shows the details of this analysis. The first column and the first row (without any color) show the mapping types of the first and the second operator to be fused and the colored cells show the mapping type of the resulting operator. It further classifies the fusion of this combination of mapping types into three groups (shown as green, yellow, and red, respectively). Green implies that these fusions are legal and profitable and no further analysis is required. Red implies that these fusions are known to be either illegal or clearly not profitable. Yellow implies that these fusions are legal; however, further profiling is required to determine profitability. This analysis eliminates the need for anytime runtime analysis or autotuning for red and green cases. For remaining (yellow) cases, we can further accelerate compilation using a profiling database that stores the execution results of various fusion combinations collected offline.",
                        "These five mapping types have a range of what we call transformation impedance (which we informally define as a metric to qualitatively express the difficulty to fuse), i.e., when they are fused with another type, they have different capability of deciding the fused mapping type. One-to-One has the lowest transformation impedance among all five types, whereas Reorganize and Shuffle's transformation impedance is in the middle, i.e., they can transform One-to-One to their types while they cannot transform others. One-to-Many and Many-to-Many have the strongest transformation impedance, i.e., the resulted mapping type is decided by them solely when they are fused with other operators. Moreover, One-to-Many and Many-to-Many have the same capability, and Reorganize and Shuffle have the same as well.",
                        "We elaborate on the following representative combinations to provide intuition behind the Table 3.",
                        "One-to-One with others. When a One-to-One operator (Op1 with the input I and the output 0) is fused with an operator of any type (Op2), i.e., Op2 takes O as the input, the memory access to each element of 0 can be mapped to the access to each element of I, as long as this mapping function is known. Unlike general programs where the dependencies can be more complex, the use of tensors and a limited set of operators limits the type of mappings, and DNN operators carry this mapping information. Our analysis leverages this high-level operator information to ensure the correctness of these fusions. Moreover, this fusion usually requires limited number of registers and does not incur extra overhead like data copying or redundant computations, so they are profitable. Take a case that fuses Add and GEMM in either order. Each element in the output of Add can be replaced by two elements in the two inputs of Add, ensuring correct and profitable fusion, irrespective of the order of these operations.",
                        "Reorder or Shuffle with others. Both types are variants of One-to-One with a special mapping function between the input and the output. Above reasons for the correctness analysis are also applied here; however, when fusing with One-to-Many or Many-to-Many types operators, profitability needs to be validated with further profiling because of the possibility of introduced data copying, change in data access order, or redundant computations. As an example, consider Expand and Transpose operators\u2014Expand copies the input tensor with a continuous memory access pattern, whereas, Transpose transposes the input tensor to the output tensor according to the permutation in operator properties. Thus, the resulting fused operation may not have continuous memory accesses.",
                        "One-to-Many with Many-to-Many. Take the case that Expand followed by Conv\u2014as Conv reads the feature map input tensor with continuous access, while a One-to-Many operator can distribute the continuous input tensor elements. As it is very desirable for the (compute-intensive) Many-to-Many operators to read the input tensors in a continuous way, we consider this fusion unprofitable.",
                        "Many-to-Many with Many-to-Many. When a Many-to-One mapping operator is followed by a Many-to-One operator, e.g. Conv followed by another Conv, attempting a combined execution will be too complicated and will likely negatively impact register and cache usage. Thus, we consider them unprofitable.",
                        "Many-to-Many with One-to-Many. When a Many-to-One mapping operator is followed by a One-to-Many operator, e.g. Conv followed by Expand or Resize, a combined execution may or may not have a desirable data access pattern. When Conv is combined with Expand, as Expand operator only expands a single dimension of the input, so it will not adversely affect the computation pattern of Conv. On the other hand, if Conv is combined with a Resize that will copy the input tensor along different dimensions, it can negatively impact the computation of Conv. Thus, we consider such cases to be requiring further profiling.",
                        "Extended Computational Graph. Based on the analysis above and as a background for the methods we will present next, we introduce Extended Computational Graph (ECG) as our intermediate representation (IR). As the name suggests, this represents builds on top of the (traditional) Computational Graph, which captures the data-flow and basic operator information like the operator type and parameters. ECG contains more fusion-related information, including mapping type indicating the mapping type of each operator, IR_removable denoting if an intermediate result can be removed completely (which is true only if all its successors can be fused and which is calculated during fusion), and mathematical properties of the operations like whether the associative, commutative, and/or distributed properties hold.",
                        "2. DNNFusion's Design",
                        "2.1 Overview of DNNFusion",
                        "FIG. 1 shows an overview of DNNFusion. It takes the computational graph generated from compiler-based DNN execution frameworks (e.g., TVM, and MNN) as the input, and adds key information to create the Extended Computational Graph (ECG). Based on this ECG, the main compiler optimization and code generation stage of DNNFusion consists of three components: (1) mathematical-property-based graph rewriting (Section 2.2), (2) lightweight profile-driven fusion plan exploration (Section 2.3), and (3) fusion code generation and other advanced fusion-based optimizations (Section 2.4).",
                        "2.2 Mathematical-Property-Based Graph Rewriting",
                        "DNNFusion first employs a mathematical-property based graph rewriting pass to optimize the Extended Computational Graph (ECG). With this pass, DNNFusion is able to 1) remove unnecessary operations, 2) eliminate redundant intermediate data copies, and 3) replace costly (combination of) operators with more efficient ones. This graph rewriting carried out here is in the spirit of the classical compiler optimization of strength reduction; however, here it is performed on complicated operators on matrices or tensors rather than on scalar expressions. Moreover, the rules we present are more complex and involved, and are based on operations that are common in DNNs. More importantly, compared to existing efforts on computational graph substitution (e.g., TASO), our graph rewriting is designed to work in conjunction with operator fusion and identifies a set of operators and rules for that specific purpose. Our evaluation results (Section 3) show that with graph rewriting, there are 18% fewer fused layers left after fusion on GPT-2. We also do an experimental comparison against TASO later in this paper.",
                        "FIG. 2 shows specific examples of leveraged mathematical properties (distributive, communicative, and associative). Table\u2032\u00b1 shows a more complete set of rules. This table also shows the computation size (in #FLOPS) before and after the rewriting. Our rules mainly focus on operators in the One-to-One mapping type (e.g., element-wise multiplication, addition, reciprocal, square root, and others) and several reduction operators that are in Many-to-Many (e.g., Reduce Sum and ReduceProd)\u2014this is because these operators usually follow our defined mathematical properties. DNNFusion uses #FLOPs (rather than temporary output size or memory footprint) as the metric to drive graph rewriting mainly because of two reasons: first, in most of the applications scenarios of these rules, the temporary output size keeps the same before and after graph rewriting, and second, the size of the temporary output in a majority of other cases becomes a non-issue because fusion is applied after rewriting. For a small number of remaining cases, i.e., where temporary output size changes and the fusion is not applied, more sophisticated methods will be considered in the future.",
                        "We now elaborate on some of the rules presented in Table 4, which were also depicted in FIG. 2.",
                        "Associative: By leveraging the associative property, the graph rewriting pass can identify an optimized order of operators execution, and hence replace the expensive combination of operators with a new cheaper one. FIG. 2(a) shows an example, in which a combination of two Recip operators and two Mul operators is replaced by a combination of a Recip, a Square, and a Mul. The latter is more efficient as it eliminates a Mul operator and the intermediate result size is significantly reduced, leading to reduced register pressure after subsequent fusion.",
                        "Distributive: Following the same ideas as above, applying distributive property also enables optimization opportunities. As shown in FIG. 2(b), the combination of two Mul operators and an Add can be replaced by an Add followed by a Mul, thus eliminating an unnecessary operator.",
                        "Commutative: The property guaranties the legality of swapping the position of two operators, which usually results in computation reduction. As shown in FIG. 2(c), BitShift and ReduceSum satisfy communicative property, thus ReduceSum can be scheduled to execute before BitShift, reducing the number of elements on which BitShift is applied.",
                        "DNNFusion employs pattern matching to recognize rewriting candidates. However, associative and commutative matching is NP-complete. Therefore, DNNFusion first partitions the entire Extended Computational Graph into many sub-graphs by considering operators with neither of associative, communicative, or distributive properties as partitioning points within the original graph. Within each sub-graph, DNNFusion can explore all possible patterns and pattern combinations because these sub-graphs have limited number of operators. More specifically, all matching rules within a partition are considered and the rule leading to the largest reduction in #FLOPS is applied. This process is repeated till there are no additional matching rules within the partition. DNNFusion chooses this greedy scheme to keep the optimization overheads low.",
                        "2.3 Light-Weight Profile-Driven Fusion Plan Exploration",
                        "2.3.1 Overall Idea. Optimal fusion plan generation requires a large search space and has been shown to be NP-complete. To keep the process at manageable costs, DNNFusion explores fusion plans by employing a new light-weight (greedy) approach based on our proposed Extended Computational Graph (ECG) IR and our classification of operations into mapping types.",
                        "The high-level ideas are as follows. First, DNNFusion selects the starting operators (called fusion seed operators) from our ECG to restrict the search space. This is based on a key insight that operators of One-to-One mapping type have the potential to yield more benefits because they a) potentially result in fusion of more layers, including both with their predecessors and successors because of what we refer to as lower transformation impedance, and b) have lower memory requirements and need for fewer registers among all mapping types. Second, starting with these seed operators, DNNFusion explores fusion opportunities along the seed operator's successors and predecessors, respectively. Third, DNNFusion creates fusion plans based on an approach that combines machine-independent mapping type analysis and a profiling result database. The mapping type analysis follows Table 3 to check the operators' mapping type combination (in ECG) to decide if these operators should be fused. Such mapping eliminates unnecessary profile data lookup for most cases.",
                        "2.3.2 Fusion Plan Generation Algorithm. List 1 shows our detailed fusion plan exploration algorithm. Its goal is to generate candidate fusion blocks that are further optimized by subsequent intra-block optimizations (Section 2.4) before fusion code generation. FIG. 3 illustrates its basic idea with a simplified example. This algorithm consists of three main steps:",
                        "Step I: Fusion seed operator(s) selection. DNNFusion selects the One-to-One operator with the minimum intermediate result as the fusion seed operator (as shown in Listing 1 lines 1 to 5). This heuristic is used because a smaller intermediate result makes fusion more profitable. This may seem counter-intuitive because fusing the operators with larger intermediate results usually results in more benefits. However, DNNFusion has a different goal, i.e., to ultimately enable more fusions to occur. Starting with a pair of operators with smaller intermediate results creates opportunities to fuse more (smaller) operators together, increase overall computation granularity, and hence enable higher parallelism and better load balance for the entire DNN computation. If multiple seed operators with the same minimum size of intermediate results exist, DNNFusion initiates fusion with them one after another (unless another seed is grouped to the same candidate fusion block). In FIG. 3, Add, Relu, Mul, and Sub are in One-to-One type (with an identical intermediate result size), then Add is selected as the seed for the first round of fusion plan exploration.",
                        "Step II: Propagated exploration along seed's successors. Each operator may have one or multiple immediate predecessors and successors. DNNFusion first processes the seed operator's successors one by one (Listing 1 Lines 7 to 24). At any stage in this recursive exploration, if a node cannot be fused with any of its immediate successors, fusion is not considered any further. Broadly, this step proceeds as follows. First, mapping type analysis (Listing 1 Step 2.1) categorizes the potential fusion result into three types based on Table 3: 1) fuse_break indicates this is a Red case, and fusion should be aborted; 2) fuse_th rough indicates that this is a Green case, and should be proceeded without any further analysis; 3) fuse_depend indicates that this is a Yellow case, requiring a profile data lookup. Second, a constraints check (Listing 1 Step 2.2) is applied to analyze if further fusion is likely undesirable, i.e, it incurs too many overheads (e.g., can cause excessive register spills). Using an empirically determined threshold, the algorithm can decide to not consider any additional fusion candidates. Otherwise, DNNFusion continues exploring fusion candidates recursively. FIG. 3 shows an example of fusing Add with Conv and other operators with this step. After this step, the generated candidate fusion block has a mapping type of Many-to-One, and includes five operators (Add, Cony, Relu, Mul, and Sub).",
                        "Step III: Propagated exploration along seed's predecessors. After processing along the seed's successor direction, DNNFusion processes along the seed's predecessors direction with the same algorithm as Step II (In fact, Step III and Step II can be swapped). However, one difference is that if an operator has multiple immediate predecessors, there is an option of fusing with some, but not all, of these immediate predecessors. In the example in FIG. 3, the first attempt of fusing current candidate fusion block with GEMM fails because both of them are of many-to-one mapping type. Table 3 indicates this is a fuse_break case, so GEMM is not included in this candidate fusion block.",
                        "Iterate. DNNFusion completes a round of fusion plan generation with above steps. If more fusion seeds exist, it will iterate from Step II with the next seed until no additional fusion seed is available.",
                        "2.4 Fusion Code Generation and Optimizations",
                        "2.4.1 Fusion Code Generation. Once fusion blocks have been selected by our algorithm, DNNFusion generates fused code for each fusion block with a data-flow tree (DFT) built from the Extended Computational Graph (ECG) and a set of pre-defined code generation rules. DNNFusion generates C++ code for mobile CPU and OpenCL for mobile GPU, respectively. More specifically, DNNFusion traverses DFT and generates fused code for each pair of operators to be fused by leveraging the code generation rules that are based on abstract mapping types (e.g., One-to-One). 23 code generation rules are defined for each of mobile CPU and mobile GPU, with one rule corresponding to a green or yellow cell in Table 3. The basic idea is that as long as the operators are of the same type, the same rules lead to efficient code. While fusing more than two operators, these rules are invoked each time two operators are fused. Finally, the subsequent code optimizations (e.g, vectorization, unrolling, tiling, and memory/register optimizations, and auto-tuning of these optimizations) are handled by our existing framework called PatDNN, thus not a major contribution of this paper. Note that almost each fusion generates a new operator (and its codes) that is not present in the original operator library; however, once the new operator (and its code) is generated, it can be used for both the current model and future models.",
                        "FIG. 4 shows an example of the code generation. To elaborate, DNNFusion first generates a data-flow tree (DFT) from the Extended Computational Graph (ECG). This DFT represents the final output (Out), all intermediate results (IRS), and all inputs (A, B, C, and D) with the edges reversed as compared to the ECG (i.e., the parent node depends on the children nodes). During the fused code generation, DNNFusion traverses this DFT to recognize the input/output data dependence (and fuses corresponding ECG operations), recursively. The right-hand side of FIG. 4, shows an example of this DFT traversal (the fused code generation based on the pre-defined code generation rules is omitted in this Figure for readability and is introduced in the next paragraph). First, DNNFusion recognizes that Out depends on IRS3+IRS5; next, it recognizes that IRS3 depends on reciprocal of IRS2, and so on, until reaching the input of A, B, C, D. It is worth noting DNNFusion can also find redundant computations in DFT with a common sub-tree identification and eliminate them during code generation. In our example, both Mul operators use IRS1, resulting in a common sub-tree in DFT, so the recognition in two red boxes of FIG. 4 is only taken once.",
                        "During this DFT traversal, DNNFusion employs the pre-defined code generation rules to generate the code for each pair of operators to be fused. For the example shown in FIG. 4, DNNFusion first fuses Add with its left input branch Recip. Both Add and Recip belong to One-to-One mapping, and hence the fused operator is also One-to-One. DNNFusion keeps fusing Mul (One-to-One) with this newly fused operator, and the result is still One-to-One. Next, this newly generated operator is fused with GEMM (Many-to-One), generating a new Many-to-One operator. Similar steps are taken along the right input branch of Add until all operators are fused into a single new Many-to-One operator. DNNFusion relies on the DFT traversal introduced in the prior paragraph to figure out the input/output data dependence, and employs the operator mapping type to handle the index mapping relationship and generate proper nested loop structures.",
                        "To explain this further, here is an example with more complicated mapping types: GEMM (Many-to-Many)+Div (One-to-One)+Transpose (Shuffle). First, DNNFusion fuses Transpose and Div, a case of (\u201cShuffle+One-to-One\u201d) by first permuting the loop in the Transpose operator and then fusing it with the Div operator. It generates a new operator of the type Shuffle. Next, DNNFusion fuses GEMM (Many-to-Many type) with this new operator (Shuffle type), in which DNNFusion maps output elements of GEMM to the destination that is decided by this new operator.",
                        "2.4.2 Other Fusion-related Optimizations. DNNFusion also includes several advanced optimizations enabled by our fusion analysis and fused code generation. They broadly can be characterized into two groups, intra-fusion-block optimizations that are performed on Extended Computational Graph (ECG) immediately before the code generation and inter-fusion-block optimizations on the generated fused code.",
                        "Intra-block Optimizations: Operators in Shuffle and Reorganize mapping types usually involve intensive data movement. We observed many of these time/memory consuming data operations can be eliminated. In particular, consider the case when the transformed data is used by only one subsequent operator because the data locality improvement brought this data transformation cannot be compensated by the overhead of intermediate results generation and storage. FIG. 5 shows such examples\u2014particularly, in these, data transpose and data slicing operations bring more overheads than the benefit. Thus, in such cases, DNNFusion replaces them with operations that have a changed data index. These optimizations are performed after graph rewriting and result in an ECG that should have a more efficient implementation.",
                        "Inter-block Optimization: Different operators prefer different data formats. Without the proposed graph rewriting optimizations and operator fusion, normally such choices are made at the level of each individual operator\u2014however, this can result in redundant or unnecessary transformations. In contrast, DNNFusion considers the data format choice at a global level, thus avoiding redundant or unnecessary transformations. Currently, DNNFusion employs a heuristic approach to optimize the data format, which is as follows. For a specific fusion block, it identifies one dominant operator whose performance is impacted the most by the choice of the layout (e.g., CONV, GEMM, and Softmax are most likely to such operators). The optimal layout for this operation is then used for the entire fusion block. This heuristic approach works based on a key observation that most other non-dominant operators can employ any layout/format without their performance being significantly affected. A potential future work will be to consider more sophisticated cost models, including balancing the cost of reformatting the data with reductions in execution because of the optimized layout.",
                        "3. Evaluation",
                        "DNNFusion is implemented on top of an existing end-to-end DNN execution framework called PatDNN that supports both dense and sparse DNN execution. It has been shown in our previous work that PatDNN performs slightly better than TVM, MNN, and TFLITE even without our proposed operator fusion. For readability, we also call this optimized framework DNNFusion. Our evaluation has four objectives: 1) demonstrate that the proposed fusion framework (together with graph rewriting) is effective by showing how DNNFusion outperforms other state-of-the-art frameworks, and no-fusion and fixed-pattern fusion implementations on various DNN models; 2) validating DNNFusion's generality by showing its efficient execution on both CPU and GPU on a wide spectrum of DNNs (for 5 types of tasks, with varied sizes, and layer counts ranging from relatively shallow to extremely deep); 3) analyzing the impact of different compiler optimizations on both execution time and compilation time; and 4) demonstrating the effective portability of DNNFusion by evaluating it on three different mobile phones.",
                        "More specifically, DNNFusion (also called DNNF for short) is compared against four popular state-of-the-art end-to-end DNN execution frameworks: MNN, TVM, TensorFlow-Lite (TFLite), and Pytorch-Mobile (Pytorch). Because certain extremely deep neural networks are not supported by any of these existing frameworks (or just supported by their mobile CPU implementation), we also set a baseline by turning off DNNFusion's all fusion related optimizations (called OurB, i.e., our baseline version without fusion) and implement a version that optimizes OurB with fixed-pattern fusion (using operator fusion described in TVM (called OurB+), and compare DNNFusion against them.",
                        "3.1 Evaluation Setup",
                        "Models and datasets. DNNFusion is evaluated on 15 mainstream DNN models. Table S characterizes them with a comparison of their targeted task, number of parameters, total number of layers, and number of floating point operations (FLOPS). Particularly, we have 1) two image classification 2D CNNs (EfficientNet-B0 and VGG-16), 2) two object detection two-dimensional (2D) CNNs (MobileNetV1-SSD and YOLO-V4), 3) two action recognition three-dimensional (3D) CNNs (C3D and S3D), 4) one image segmentation 2D CNN (U-Net) and two image segmentation R-CNNs (Mask R-CNN and FasterRCNN), and 5) six natural language processing (NLP) models (TinyBERT, DistilBERT, ALBERT, BERTBASE, MobileBERT, and GPT-2).",
                        "Because the choice of datasets has a negligible impact on the final inference latency or relative execution speeds (and also because of space limitations), we report results from one dataset for each model. EfficientNet-B0 and VGG-16 are trained on ImageNet dataset; MobileNetV1-SSD and YOLO-V4 are trained on MS COCO; C3D and S3D are trained on UCF-101; U-Net, Faster R-CNN, and Mask R-CNN are trained on PASCAL VOC 2007 TinyBERT, DistilBERT, ALBERT, BERTbase, MobileBERT, and GPT-2 are trained on BooksCorpus and English Wikipedia. Because the model accuracy is identical among all frameworks, and also because of space limitations, we only focus on execution times and do not report accuracy.",
                        "Evaluation environment. The evaluations are carried out on a Samsung Galaxy S20 cell phone that has Snapdragon 865 processor, which comprises an octa-cores Kryo 585 CPU and Qualcomm Adreno 650 GPU yielding high performance with good power efficiency. For demonstrating portability, we further use a Samsung Galaxy S10 with a Snapdragon 855 (Qualcomm Kryo 485 Octa-core CPU and a Qualcomm Adreno 640 GPU), and an Honor Magic 2 with a Kirin 980 (ARM Octa-core CPU and a Mali-G76 GPU). All executions used 8 threads on mobile CPUs, and similarly all pipelines on mobile GPUs. 16-bit and 32-bit floating points are used for all GPU runs and CPU runs, respectively. All experiments were run 100 times but as the variance was very small, we only report averages.",
                        "3.2 Overall Mobile Inference Evaluation",
                        "Our comparison includes both fusion rate and execution latency.",
                        "Fusion rate. Table 5 shows detailed layer counts (including computation-intensive (CIL), memory-intensive (MIL), and all layers), and intermediate result sizes for models before fusion and after fusion with different frameworks. Note that DNNFusion is the only end-to-end framework that can support all of the target models on both mobile CPU and mobile GPU. In Table 5, \u201c-\u201d implies that this framework does not support this model. Certain extremely deep neural networks (e.g., Faster R-CNN and Masker R-CNN) are not supported by any other frameworks on mobile devices because these frameworks either lack the support of multiple key operators and/or limited optimization supported in them lead to a large model execution footprint. For transformer-based models, only TFLite can support execution on mobile CPU (without GPU support).",
                        "Table 5 shows that compared with the other frameworks, DNNFusion results in better fusion rates, with 1.3\u00d7 to 2.9\u00d7, 1.3\u00d7 to 8.1\u00d7, 1.3\u00d7 to 8.8\u00d7, and 1.3\u00d7 to 2.8\u00d7 over MNN, TVM, TFLite, and Pytorch, respectively. Particularly, compared with original models, DNNFusion yields more benefits for R-CNN and Transformer-based models (3.9\u00d7 to 10.0\u00d7 fusion rate) than 2D/3D CNNs (1.7\u00d7 to 3.6\u00d7 fusion rate). This is because 2D/3D CNNs have higher fractions of computation-intensive layers that are in either One-to-Many or Many-to-Many types, while transformer-based models have more memory-intensive layers that are in One-to-One, Shuffle, or Reorganize categories. The latter offers more fusion opportunities according to our mapping type analysis (Table 3). Because of the same reason, 3D CNNs have the lowest fusion rate because they are more compute-intensive. Moreover, comparing to TVM (that performs the best among all other frameworks), DNNFusion particularly yields more benefits for transformer-based models. This is because these models have more types of operators, and TVM's fixed pattern-based fusion cannot capture fusion opportunities among many types of operators while DNNFusion can. This result demonstrates that DNNFusion has a better generality.",
                        "Execution latency. Table 6 shows the execution latency evaluation results. Comparing with MNN, TVM, TFLite, and Pytorch, with fusion optimization, DNNFusion achieves the speedup of 1.4\u00d7 to 2.6\u00d7, 1.5\u00d7 to 3.5\u00d7, 1.4\u00d7 to 3.3\u00d7, and 1.6\u00d7 to 9.3\u00d7, respectively, on the mobile CPU. Focusing on mobile GPU, improvements over MNN, TVM, and TFLite are 1.7\u00d7 to 2.6\u00d7, 2.0\u00d7 to 3.1\u00d7, 1.6\u00d7 to 4.0\u00d7, respectively, whereas Pytorch does not support execution on this mobile GPU. The reason for speedups including the fact that our baseline implementation with a fixed-pattern fusion (OurB+) is already faster than other frameworks (with speedup of 1.04\u00d7 to 5.2\u00d7 on mobile CPU and 1.05\u00d7 to 1.7\u00d7 on mobile GPU), and with our more advanced fusion, DNNFusion achieves 1.4\u00d7 to 2.5\u00d7 speedup over OurB+ on mobile CPU and 1.5\u00d7 to 3.9\u00d7 speedup on mobile GPU. In addition, comparing DNNFusion (with fusion) and our baseline without fusion (OurB), our advanced fusion brings 1.5\u00d7 to 5.8\u00d7 speedup. Moreover, fusion optimization offered by DNNFusion brings more benefits for mobile GPU than CPU, particularly for extremely deep models (e.g., Faster R-CNN and GPT-2). This is because mobile GPU offers more parallelism but smaller cache capacity compared to CPU, and GPU kernel launch incurs certain overheads, so it is more sensitive to intermediate data reduction, kernel launch reduction, and processor utilization increase that are brought by DNNFusion's fusion.",
                        "To further validate DNNFusion's performance, FIG. 6 compares it with a state-of-the-art computational graph substitution approach mentioned earlier, TASO. We use TASO to optimize all eleven models (computational graphs) supported by TFLite among those listed in Table 6, including EfficientNet-B0 (ENT-B0), VGG-16 (VGG), MobileNetV1-SSD (MNT), YOLO-V4, U-Net, TinyBERT (TBERT), DistilBERT (DBERT), ALBERT (ABERT), BERTBase (BERT), MobileBERT (MBT), and GPT-2. Then, for our experiments, these models are executed under TFLite on mobile CPU (not GPU because TFLite lacks GPU support for many of these models). Compared with TASO, DNNFusion yields 1.4\u00d7 to 2.6\u00d7 speedup on mobile CPU. The graph rewriting in DNNFusion is designed to work in conjunction with operator fusion and identifies a set of operators and rules for that specific purpose, thus enabling more fusion opportunities. TASO does not emphasize the relationship between graph rewriting and fusion, resulting in less efficient execution as compared to DNNFusion.",
                        "3.3 Understanding Fusion Optimizations",
                        "This section studies the effect of our key optimizations.",
                        "Optimization breakdown. FIG. 7 shows the impact of our proposed optimizations on latency with four models (EfficientNet-B0 (ENT-B0), YOLO-V4, S3D, and GPT-2) on both mobile CPU and GPU. Experiments on other models show a similar trend and are omitted due to space constraints. We evaluate each compiler-based optimization speedup incrementally over the OurB version. Compared with OurB, graph rewriting brings 1.2\u00d7 to 1.5\u00d7 speedup, fusion brings additional 1.6\u00d7 to 2.2\u00d7 speedup, and other optimizations (intra-block optimizations like data movement operator optimizations and inter-block optimizations like data format optimizations introduced in Section 2.4.2) bring additional 1.3\u00d7 to 1.8\u00d7 speedup on mobile CPU. On mobile GPU, these numbers are 1.3\u00d7 to 1.5\u00d7, 2.1\u00d7 to 3.3\u00d7, and 1.7\u00d7 to 2.1\u00d7, respectively. Again, our fusion brings more benefit for mobile GPU than CPU due to the aforementioned reasons of memory, parallelism, and kernel launch overheads. Although graph rewriting by itself brings fewer benefits than the fusion, its hidden benefit is in enabling more fusion opportunities. Take GPT-2 as an example\u2014without graph rewriting, the generated fused layer count is 310, while after rewriting, it is 254 (18% reduction). This is because graph rewriting simplified the computational graph structure. To further assess this impact of graph rewriting on operator fusion, the last bar (in orange) of FIG. 7 reports the speedup of fusion with other optimizations only (i.e., without graph rewriting) over the baseline OurB. Compared with no graph rewriting, graph rewriting brings an additional 1.4\u00d7 to 1.9\u00d7 and 1.6\u00d7 to 2.0\u00d7 speedup (over OurB) on mobile CPU and GPU, respectively.",
                        "Memory and cache performance We compare memory (and cache) performance of DNNFusion with other frameworks on both mobile CPU and GPU. We only report YOLO-V4's results due to space constraint, and because it is one of the models supported by all frameworks. FIG. 8(a) left shows memory performance (measured in total memory accesses (MA) and memory consumption (MC))\u2014MA and MC are collected from Snapdragon Profiler, and FIG. 8(a) right shows cache miss count on data cache and TLB cache on mobile CPU. All values are normalized with respect to DNNFusion (i.e., our best version) for readability. DNNFusion outperforms other frameworks on both memory access count and memory consumption because it eliminates materialization of more intermediate results. FIG. 8(b) shows similar results on mobile GPU (excluding PyTorch because it does not support YOLO-V4 on mobile GPU). Mobile GPU results are generally better than CPU because mobile GPU has smaller cache capacity and simpler hierarchy (GPU only has L1/L2 v.s., CPU has L1/L2/L3). Thus, intermediate results reduction leads to more gains on mobile GPU.",
                        "CPU/GPU utilization. FIG. 9(a) reports the mobile CPU and GPU utilization on YOLO-V4. This result is collected by Snapdragon Profiler. It shows that DNNFusion results in the highest utilization on both CPU and GPU because its aggressive fusion groups more computation together, resulting in coarser-grained execution with less loop and parallel scheduling (and kernel launch for GPU only) overhead. Particularly, the GPU utilization is slightly higher than CPU because of its higher parallelism.",
                        "Compilation time. FIG. 9(b) compares the compilation time between TVM and DNNFusion for YOLO-V4 on mobile CPU. TVM's compilation time consists of operator fusion and other compiler optimizations (Fusion), and tuning for performance-critical parameters, e.g., tiling size, unrolling factors, and others (Tuning). Tuning dominates its compilation time, lasting for around 4 hours for YOLO-V4 on mobile CPU. DNNFusion's compilation time consists of operator fusion and other compiler optimizations (Fusion), profiling to analyze the fusion benefits (Profiling), and performance tuning (Tuning). DNNFusion's Tuning relies on an auto-tuner based on Genetic Algorithm (reported in our previous publication) to generate the exploration space. Compared with AutoTVM, our auto-tuning's Genetic Algorithm allows parameter search to start with initializing an arbitrary number of chromosomes. Without our pre-existing profiling database, Profiling and Tuning dominate the compilation, requiring around 3 hours. With a pre-computed database, Profiling becomes very fast, and only Tuning dominates the compilation, requiring around 1 hour. After evaluating 15 models in Table 5, the profiling database consists of around 22K profiling entries with each one including operators' information (e.g., operator types, shape, and their combinations) and the latency achieved.",
                        "3.4 Portability",
                        "FIG. 10 shows the execution latency on additional cell phones (Samsung Galaxy S10 and Honor Magic 2) to demonstrate effective portability. Only YOLO-V4 and GPT-2 are reported due to limited space. Other models show similar trends. In particular, DNNFusion shows a more stable performance on older generations of mobile devices. This is because our fusion significantly reduces the overall number of layers and intermediate result size, and older cell phones with more restricted resources are more sensitive to these.",
                        "4. Related Work",
                        "Operator fusion in end-to-end mobile DNN frameworks. Operator fusion is an important optimization in many state-of-the-art end-to-end mobile DNN execution frameworks that are based on computational graphs, such as MNN, TVM, TensorFlow-Lite, and Pytorch. However, they all employ fixed-pattern fusion that is too restricted to cover diverse operators and layer connections in deep models like BERT\u2014for example, ConvTranspose+ReLU+Concat cannot be recognized in TVM as it is not one of the specified patterns. Other examples that can be handled by DNNFusion and cannot be recognized by TVM include MatMul+Reshape+Transpose+Add in GPT-2, and Sub+Pow+ReduceMean+Add+Sq rt in TinyBERT. Comparing to these frameworks, DNNFusion works by classifying both the operators and their combinations, thus enabling a much larger set of optimizations.",
                        "Operator fusion on other ML frameworks. There are certain recent frameworks that rely on polyhedral analysis to optimize DNN computations and support operator fusion. R-Stream-TF shows a proof-of-concept adaptation of the R-Stream polyhedral compiler to TensorFlow. Tensor Comprehensions is an end-to-end compilation framework built on a domain-specific polyhedral analysis. These frameworks do not support mobile execution (i.e. ARM architecture), and thus we cannot perform a direct comparison between DNNFusion and them. As we have stated earlier, DNNFusion maintains an operator view but builds a higher-level abstraction on them. In the future, we can combine DNNFusion's high-level abstraction to existing domain-specific polyhedral analysis. Similarly, another promising direction will be to integrate DNNFusion into other compilation-based DNN frameworks or other popular general tensor/matrix/linear algebra computation frameworks, such as MLIR, Tiramisu, TACO, Halide, and LGen.",
                        "There also exist several other frameworks to optimize machine learning with operator fusion or fusion-based ideas. Closely related to DNNFusion-Rammer relies on fix-pattern operator fusion to further reduce kernel launch overhead of their optimized scheduling, Cortex proposes a set of optimizations based on kernel fusion for dynamic recursive models, TensorFlow XLA offers a more general fusion method than fix-pattern operator fusion by supporting reduce operations and element-wise operations, and TensorFlow Grapper provides an arithmetic optimizer that performs rewrites to achieve both fusion and arithmetic expression simplification (e.g., a\u00d7b+a\u00d7c=a\u00d7(b+c)). Comparing with these frameworks, DNNFusion works by classifying the operators and their combinations into several mapping categories, thus resulting in a more aggressive fusion plan and more performance gains. Elgamal and Boehm presently optimize general machine learning algorithms (e.g., SVM and Kmeans) with operator fusion. These efforts have both different targets and techniques compared to DNNFusion.",
                        "Polyhedral-based and other loop fusion methods. Polyhedral analysis is a prominent approach that offers a general and rigorous foundation for loop transformation and optimization.",
                        "Many existing efforts rely on a general polyhedral analysis to achieve optimized loop fusion. Pouchet et al. have demonstrated that polyhedral analysis can decompose the loop optimization problem into sub-problems that have much lower complexity, enabling optimal selection. The problem arising because of a large number of operators in our target applications (models) is quite different, and thus there does not seem to be a direct application of Pouchet et al.'s approach in our context. There have also been other loop fusion efforts targeting general programs. In contrast to these general efforts, DNNFusion is more domain-specific, leveraging the knowledge of DNN computations with a higher-level abstraction to explore more aggressive loop fusion opportunities."
                    ],
                    "subsections": [],
                    "outline_long": [
                        "introduce DNNFusion framework",
                        "classify operators into different types",
                        "develop rules for different combinations of operator types",
                        "enhance computational graph representation into ECG",
                        "design mapping type analysis",
                        "infer profitability of fusing operations",
                        "apply graph rewriting rules",
                        "determine fusion of specific operations",
                        "generate optimized fused code",
                        "show contributions of DNNFusion",
                        "design high-level abstractions for operator fusion",
                        "propose mathematical-property-based graph rewriting",
                        "present integrated fusion plan generation",
                        "implement optimized fusion code generation",
                        "evaluate DNNFusion on 15 cutting-edge DNN models",
                        "compare with four popular end-to-end DNN execution frameworks",
                        "motivate work by demonstrating challenges of executing deep neural networks",
                        "correlate execution efficiency with total amount of computation and number of layers",
                        "classify DNN operators and analyze fusion opportunities",
                        "classify operators into five high-level abstract types",
                        "define One-to-One mapping type",
                        "define One-to-Many mapping type",
                        "define Many-to-Many mapping type",
                        "define Reorganize mapping type",
                        "define Shuffle mapping type",
                        "analyze fusion opportunities based on mapping types",
                        "propose new fusion analysis",
                        "simplify profitability evaluation and correct implementation of fusion",
                        "classify fusion of combinations of mapping types into three groups",
                        "elaborate on representative combinations of mapping types",
                        "introduce Extended Computational Graph (ECG)",
                        "overview DNNFusion's design",
                        "employ mathematical-property-based graph rewriting",
                        "perform lightweight profile-driven fusion plan exploration",
                        "generate fusion code and perform advanced fusion-based optimizations",
                        "remove unnecessary operations",
                        "eliminate redundant intermediate data copies",
                        "replace costly operators with more efficient ones",
                        "introduce light-weight profile-driven fusion plan exploration",
                        "motivate greedy approach",
                        "define extended computational graph (ECG) IR",
                        "classify operations into mapping types",
                        "select fusion seed operators",
                        "explore fusion opportunities along seed operator's successors",
                        "create fusion plans based on machine-independent mapping type analysis",
                        "illustrate fusion plan generation algorithm",
                        "select One-to-One operator with minimum intermediate result as fusion seed operator",
                        "process seed operator's successors",
                        "apply mapping type analysis",
                        "check constraints",
                        "explore fusion candidates recursively",
                        "process seed operator's predecessors",
                        "iterate fusion plan generation",
                        "generate fused code for each fusion block",
                        "build data-flow tree (DFT) from ECG",
                        "generate code for each pair of operators to be fused",
                        "recognize input/output data dependence",
                        "fuse operators with common sub-tree identification",
                        "perform intra-fusion-block optimizations",
                        "perform inter-fusion-block optimizations",
                        "introduce evaluation objectives",
                        "describe evaluation setup",
                        "characterize models and datasets",
                        "compare DNNFusion with state-of-the-art frameworks",
                        "analyze impact of compiler optimizations",
                        "demonstrate effective portability of DNNFusion",
                        "introduce evaluation environment",
                        "describe mobile devices used",
                        "specify execution settings",
                        "report model training datasets",
                        "explain motivation for focusing on execution times",
                        "introduce fusion rate evaluation",
                        "describe table 5 contents",
                        "compare fusion rates with other frameworks",
                        "analyze benefits for R-CNN and transformer-based models",
                        "explain reasons for better fusion rates",
                        "introduce execution latency evaluation",
                        "describe table 6 contents",
                        "compare execution latency with other frameworks",
                        "analyze speedup on mobile CPU and GPU",
                        "explain reasons for speedup",
                        "compare with TASO approach",
                        "introduce optimization breakdown",
                        "describe figure 7 contents",
                        "evaluate each optimization's speedup",
                        "analyze benefits of graph rewriting",
                        "introduce memory and cache performance evaluation",
                        "describe figure 8 contents",
                        "compare memory performance with other frameworks",
                        "introduce CPU/GPU utilization evaluation",
                        "describe figure 9 contents",
                        "compare CPU/GPU utilization with other frameworks",
                        "introduce compilation time evaluation",
                        "describe figure 9(b) contents",
                        "compare compilation time with TVM",
                        "introduce portability evaluation"
                    ],
                    "num_characters": 49059,
                    "outline_medium": [
                        "introduce DNNFusion framework",
                        "motivate operator view of DNN computations",
                        "summarize contributions of DNNFusion",
                        "propose mathematical-property-based graph rewriting",
                        "present integrated fusion plan generation",
                        "implement optimized fusion code generation",
                        "evaluate DNNFusion on 15 DNN models",
                        "motivate study on executing deep neural networks efficiently",
                        "correlate execution efficiency with computation and layer count",
                        "classify DNN operators and analyze fusion opportunities",
                        "define five high-level abstract operator types",
                        "analyze fusion opportunities based on operator types",
                        "elaborate on representative fusion combinations",
                        "introduce Extended Computational Graph (ECG) representation",
                        "overview DNNFusion's design",
                        "describe mathematical-property-based graph rewriting",
                        "present lightweight profile-driven fusion plan exploration",
                        "generate fusion code and apply advanced fusion-based optimizations",
                        "elaborate on graph rewriting rules and examples",
                        "introduce light-weight profile-driven fusion plan exploration",
                        "describe fusion plan generation algorithm",
                        "motivate fusion seed operator selection",
                        "explain propagated exploration along seed's successors",
                        "explain propagated exploration along seed's predecessors",
                        "describe fusion code generation",
                        "explain data-flow tree traversal",
                        "describe code generation rules",
                        "motivate intra-fusion-block optimizations",
                        "explain inter-fusion-block optimizations",
                        "introduce evaluation objectives",
                        "describe evaluation setup",
                        "characterize models and datasets",
                        "outline comparison with state-of-the-art frameworks",
                        "introduce evaluation environment",
                        "describe mobile inference evaluation",
                        "present fusion rate results",
                        "present execution latency results",
                        "compare with TASO",
                        "study fusion optimizations",
                        "present optimization breakdown",
                        "discuss memory and cache performance",
                        "discuss CPU/GPU utilization",
                        "discuss compilation time",
                        "demonstrate portability",
                        "discuss related work on operator fusion",
                        "discuss related work on polyhedral-based loop fusion",
                        "discuss other related work on machine learning optimization",
                        "conclude related work"
                    ],
                    "outline_short": [
                        "introduce DNNFusion framework",
                        "motivate need for efficient DNN execution",
                        "classify DNN operators and analyze fusion opportunities",
                        "describe Extended Computational Graph representation",
                        "overview DNNFusion design",
                        "apply mathematical-property-based graph rewriting",
                        "perform lightweight profile-driven fusion plan exploration",
                        "generate optimized fusion code",
                        "evaluate DNNFusion on various DNN models",
                        "introduce light-weight profile-driven fusion plan exploration",
                        "describe fusion plan generation algorithm",
                        "explain fusion code generation and optimizations",
                        "discuss other fusion-related optimizations",
                        "introduce evaluation objectives",
                        "describe evaluation setup",
                        "outline models and datasets",
                        "introduce evaluation environment",
                        "present fusion rate results",
                        "present execution latency results",
                        "analyze fusion optimizations",
                        "discuss memory and cache performance",
                        "discuss CPU/GPU utilization and compilation time",
                        "discuss portability and related work"
                    ]
                }
            ],
            "outline_long": [],
            "num_characters": 0,
            "outline_medium": [],
            "outline_short": []
        }
    ],
    "claims": [
        "1. A method for classifying deep neural network (DNN) operators, wherein the method is implemented by at least one electronic processor, and comprises:\nobtaining DNN operators including a first DNN operator,\ndetermining an operand of the first DNN operator;\nobtaining input elements of the operand, x[d1, . . . , dn], wherein x represents an input and d1, . . . , dn denotes indexes for elements of the input; and\ndetermining a mapping type between the output and an input of the first DNN operator, wherein the mapping type includes a one-to-one type satisfying the following relationship:\ny[d1 . . . dn]=F(x[f1(d1),) . . . fn(dn)]), wherein F, f1, . . . fn denote a set of functions, and y represents the output, and there is a one-to-one mapping between each [d1 . . . , dn] and the corresponding [f(d1) . . . fn(dn)].",
        "2. The method of claim 1, wherein the DNN operators include a second DNN operators, and the method further comprises:\ndetermining a second operand of the second DNN operator;\nobtaining input elements of the second operand, x[d1, . . . , dn], wherein x represents an input of the second operand and d1, . . . , dn denotes indexes for elements of the input of the second operand; and\ndetermining a mapping type between the output and an input of the second DNN operator, wherein the mapping type includes a one-to-many type satisfying the following relationship:\ny[e1, . . . , em]=F(x[f1(d1),) . . . fn(dn)]), wherein m>n and there is a one-to-many relationship between [f1(d1), . . . , fn(dn)] and [e1, . . . , em].",
        "3. The method of claim 1, wherein the DNN operators include a second DNN operators, and the method further comprises:\ndetermining a second operand of the second DNN operator;\nobtaining input elements of the second operand, x[d1, . . . , dn], wherein x represents an input of the second operand and d1, . . . , dn denotes indexes for elements of the input of the second operand; and\ndetermining a mapping type between the output and an input of the second DNN operator, wherein the mapping type includes a many-to-many type satisfying the following relationship:\n\n\ny[e1, . . . , em]=F(x1[\u019211(d1), . . . , \u0192n1(dn)], . . . , xk[\u01921k(d1), . . . , \u0192kk(dn)].\n\n\n\n, where \u019211, . . . , \u0192n1, . . . \u01921k, . . . , \u0192nk, denote a set of functions.",
        "4. The method of claim 1, wherein the DNN operators include a second DNN operators, and the method further comprises:\ndetermining a second operand of the second DNN operator;\nobtaining input elements of the second operand, x[d1, . . . , dn], wherein x represents an input of the second operand and d1, . . . , dn denotes indexes for elements of the input of the second operand; and\ndetermining a mapping type between the output and an input of the second DNN operator, wherein the mapping type includes a reorganize type satisfying the following relationship:\n\n\ny[e1, . . . , em]=x[\u01921(d1), . . . , \u0192n(dn)],\n\n\n\nwherein there is a one-to-one relationship between each [e1, . . . , em] and the corresponding [\u01921(d1), . . . , \u0192n(dn)].",
        "5. The method of claim 1, wherein the DNN operators include a second DNN operators, and the method further comprises:\ndetermining a second operand of the second DNN operator;\nobtaining input elements of the second operand, x[d1, . . . , dn], wherein x represents an input of the second operand and d1, . . . , dn denotes indexes for elements of the input of the second operand; and\ndetermining a mapping type between the output and an input of the second DNN operator, wherein the mapping type includes a shuffle type satisfying the following relationship:\n\n\ny[e1, . . . , en]=x[\u01921(dF(1)), . . . , \u0192n(dF(n))]\n\n\n\n, wherein F is a permutation function.",
        "6. The method of claim 1, further comprising determining a transformation impedance of the mapping type, transformation impedance indicating a degree of a capability of deciding a fused mapping type when the first operator is fused with another operator.",
        "7. The method of claim 1, further comprising performing a mapping type analysis for the input and the output.",
        "8. The method of claim 7, wherein the method further comprises: based on a post-fusion matching type of the first operator, classifying the mapping type into one of three classifications from the group consisting of (i) legal and profitable, (ii) legal and maybe profitable, and (iii) illegal and/or not profitable.",
        "9. The method of claim 8, wherein the method further comprises: providing a computational graph.",
        "10. The method of claim 9, wherein the method further comprises: rewriting the computational graph.",
        "11. The method of claim 10, wherein the method further comprises: generating and optimizing the fusion code."
    ]
}