{
    "id": "US20230419027",
    "authors": [
        "Bo Pang",
        "Semih Yavuz",
        "Caiming Xiong",
        "Yingbo Zhou"
    ],
    "title": "SYSTEMS AND METHODS FOR SHARED LATENT SPACE PROMPT TUNING",
    "date": "2022-11-30 00:00:00",
    "abstract": "Embodiments described herein provide a prompt-based transfer learning method that employs shared latent space prompt tuning). Specifically, a shared latent space is assumed, among all source and target tasks, where each vector in the space captures a basis skill to do a particular task. Given an instance (from either a source task or a target task), it is first encoded into an instance representation vector and then queries the latent space, which yields a skill vector for this instance. This vector modulates a frozen model, via soft prompts which are a simple prompt transformation (the prompt generator in FIG. 3) of the basis skill vector, to generate an answer for the instance. The latent space and prompt transformation are learned end-to-end in upstream pre-training on source tasks.",
    "sections": [
        {
            "title": "DESCRIPTION",
            "paragraphs": [],
            "subsections": [
                {
                    "title": "CROSS REFERENCES",
                    "paragraphs": [
                        "The application is a nonprovisional of and claims priority to U.S. Provisional application No. 63/355,468, filed Jun. 24, 2022, which is hereby expressly incorporated by reference herein in its entirety."
                    ],
                    "subsections": [],
                    "outline_long": [
                        "claim priority"
                    ],
                    "num_characters": 203,
                    "outline_medium": [
                        "claim priority"
                    ],
                    "outline_short": [
                        "claim priority"
                    ]
                },
                {
                    "title": "TECHNICAL FIELD",
                    "paragraphs": [
                        "The embodiments relate generally to natural language processing (NLP) models and machine learning systems, and more specifically to systems and methods for shared latent pace prompt tuning in language models."
                    ],
                    "subsections": [],
                    "outline_long": [
                        "define technical field"
                    ],
                    "num_characters": 208,
                    "outline_medium": [
                        "define technical field"
                    ],
                    "outline_short": [
                        "define technical field"
                    ]
                },
                {
                    "title": "BACKGROUND",
                    "paragraphs": [
                        "Pre-trained language models (PLMs) may be finetuned to perform natural language processing tasks, such as question answering, sentiment classification, summarization, and/or the like. The finetuning often entails training the PLMs based on a training dataset that is specific to a certain NLP task, including updating all parameter weights of a PLM for a downstream task (i.e., MODELTUNING). This approach is however prohibitively expensive, especially given the growing sizes of PLMs, which may include tens of thousands of parameters.",
                        "Therefore, there is a need for efficient methods to adapt PLMs in various natural language processing tasks.",
                        "Embodiments of the disclosure and their advantages are best understood by referring to the detailed description that follows. It should be appreciated that like reference numerals are used to identify like elements illustrated in one or more of the figures, wherein showings therein are for purposes of illustrating embodiments of the disclosure and not for purposes of limiting the same."
                    ],
                    "subsections": [],
                    "outline_long": [
                        "motivate NLP task",
                        "limitations of model tuning"
                    ],
                    "num_characters": 1036,
                    "outline_medium": [
                        "motivate efficient adaptation"
                    ],
                    "outline_short": [
                        "motivate efficient adaptation"
                    ]
                },
                {
                    "title": "DETAILED DESCRIPTION",
                    "paragraphs": [
                        "As used herein, the term \u201cnetwork\u201d may comprise any hardware or software-based framework that includes any artificial intelligence network or system, neural network or system and/or any training or learning models implemented thereon or therewith.",
                        "As used herein, the term \u201cmodule\u201d may comprise hardware or software-based framework that performs one or more functions. In some embodiments, the module may be implemented on one or more neural networks.",
                        "Finetuning all parameter weights of a PLM on a downstream task (i.e., MODELTUNING) can be prohibitively expensive, especially given the growing sizes of PLMs. Instead of finetuning all parameters of language models for each downstream task, prompt models may be used to modulate a frozen LLM for a downstream task. For example, the input training text may be prepended with a prompt, which often consists of a task description and several examples, e.g., \u201cthe user intends to {check account balance, make a deposit, dispute a charge}.\u201d Such prompts can effectively adapt a large PLM, such as a frozen GPT-3. This approach, however, does not achieve comparable performance with MODELTUNING and is sensitive to choice of the wording of the prompt. Alternatively, instead of actual text (or hard prompt), a soft prompt, consisting of k tunable tokens, may be prepended to the input text. The soft prompt can be optimized with gradient-based methods for each downstream task. Soft prompt tuning may achieve comparable performance with MODELTUNING when the model size is large (e.g., over 10B parameters) but still underperforms with smaller models.",
                        "Some other existing approaches may leverage knowledge as encoded in soft prompts, shared across tasks. In particular, a task-specific soft prompt may be learnt for each task in a set of source tasks. Given a target task, the set of source prompts are searched and the best one or some weighted combination of the searches are used to initialize the prompt for the target task and then to tune the prompt. While these methods may further improve the performance with smaller models (e.g., 200M parameters), tuning and search prompts can be complicated and expensive to identify the source task that provides optimal prompts.",
                        "Embodiments described herein provide a prompt-based transfer learning method that employs shared latent space prompt tuning. Specifically, a shared latent space is assumed, among all source and target tasks, where each vector in the space captures a basis skill to do a particular task. Given an instance (from either a source task or a target task), it is first encoded into an instance representation vector and then queries the latent space, which yields a skill vector for this instance. This vector modulates a frozen model, via soft prompts which are a simple prompt transformation (the prompt generator in FIG. 3) of the basis skill vector, to generate an answer for the instance. The latent space and prompt transformation are learned end-to-end in upstream pre-training on source tasks.",
                        "In this way, the shared prompt-tuning improves parameter-efficiency by only updating a small amount of, e.g., 0.1% to 0.3% parameters of the frozen backbone model. As the instance encoder is always frozen, the embeddings of all instances can be pre-computed and only keep the embeddings. Thus, memory and time can be saved."
                    ],
                    "subsections": [
                        {
                            "title": "Overview",
                            "paragraphs": [
                                "FIG. 1 is an example block diagram illustrating a shared latent space prompt tuning framework, according to embodiments described herein. The prompt tuning framework shows an instance encoder 132, a prompt generator 133 and a pre-trained language model (PLM) 131 that are communicatively coupled and may be operated concurrently, independently or inter-dependently.",
                                "Traditionally, given a NLP task (e.g., summarization, question answering, intent classification, etc.) and corresponding training dataset T={(x,y)} and a PLM such as 131, the traditional MODULE TUNING method updates all parameters \u03b8 of the PLM to minimize a loss objective: L(\u03b8)=\u2014 log log P\u03b8(x), e.g., to maximize the conditional probability of generating an output y given an input x.",
                                "In the shared latent space prompt tuning framework as shown in FIG. 1, an input instance x 140 from the training set, as denoted by {X1, X2, X3} (e.g., a sequence of NLP tokens), is encoded by the instance encoder 132 into an encoded vector 112, denoted by ex(0). The discrete latent space 116 of the encoded vector ex(0) consists of a set of skill vectors E={ei \u2208Rm}i=1K. Given the input instance x, the encoded vector 112 may then be used to query the latent space E to find the nearest neighbor to the encoded vector ex(0), resulting in a skill vector ex(1) 118:",
                                "\\({e_{x}^{(1)} = e_{k}},{k = {\\arg\\arg\\min\\limits_{i \\in {\\lbrack K\\rbrack}}{{\uf605{e_{x}^{(0)} - e_{i}}\uf606}_{2}.}}}\\)",
                                "The skill vector ex(1) 118 is then transformed by a light-weight prompt generator 133 to generate soft prompt p=f\u03b1(ex(1)). For example, the prompt generator f\u03b1 is a light-weight multi-layer perceptron (MLP) that transforms the skill vector by:",
                                "ex(1)\u2032=Tan h(W1ex(1)+b1),pl=W2(zl+ex(1)\u2032)+b2,",
                                "where zl\u2208Rd is the position embedding for the lth token and W1\u2208Rd\u00d7m, W2\u2208Rd\u00d7d. Thus, the soft prompt generator 133 generates p={pl}l=1L soft prompts, where p\u2208RL\u00d7d has L vectors of size d.",
                                "The prompt tokens 136 are represented by {P1, P2} shown in FIG. 1. It is noted that soft tokens {P1, P2} are for illustrative purpose only. Any different number of tokens may be used for the soft prompts. The prompt tokens 136 are prepended to the instance tokens 140 to form an input sequence to the pre-trained model 131. The pre-trained model 131 then generates a task-specific output y 150. Then, for a target task, the loss module 142 computes a loss:",
                                "L(\u03b1)=\u2014 log log P\u03b8(f\u03b1(ek),x).",
                                "In target task training aforementioned, the latent space E 116 is known and fixed. However, for source tasks, the latent space needs to be learnt. For example, if the training dataset comprises data corresponding to N sources tasks, {Tj(s)}j=1N, the set of data of all tasks may be mixed together, T(s)=Uj=1NTj(s)). Given x\u2208T(s), its embedding ex(0) may be generated by the instance encoder 132. Then, without knowing the latent space for ex(0), a loss is computed to learn the latent space E:",
                                "L(E)=\u2225sg(ex(0))\u2212ek\u22252,",
                                "where sg( ) is a stop gradient operator and e k is the nearest neighbor for ex(0) as discussed above. The overall loss in source task learning is,",
                                "L(\u03b1,E)=L(\u03b1)+L(E).",
                                "Therefore, the forward pass for training on source and target tasks are exactly the same. For source task training data, the training loss objective is computed as L(\u03b1, E), while for target task training data, the loss is computed as L(\u03b1).",
                                "After the loss module 142 computes the respective losses, the instance encoder 132 and the pre-trained model 131 are frozen in all scenarios. The skill vectors in the latent space 116 and the prompt generator 133 are updated in source task training based on L(\u03b1, E). The skill vectors in the latent space 116 is frozen in target task training (as defined for each individual target task), and the prompt generator is updated based on L(\u03b1).",
                                "In this way, the shared latent space prompt tuning framework may train the prompt generator for a diverse set of tasks covering diverse domains and task categories. Specifically, a shared latent skill space which is learned end-to-end from a mixture of all source tasks in a single training run. Also, the tuning on the target task only requires a single run."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce shared latent space prompt tuning framework",
                                "describe instance encoder and prompt generator",
                                "describe pre-trained language model",
                                "describe loss computation and optimization",
                                "describe training on source and target tasks",
                                "describe updating prompt generator and latent space",
                                "describe freezing instance encoder and pre-trained model",
                                "describe training on target task"
                            ],
                            "num_characters": 4129,
                            "outline_medium": [
                                "describe shared latent space prompt tuning framework",
                                "illustrate prompt tuning framework",
                                "describe forward pass for training on source and target tasks",
                                "describe updating of skill vectors and prompt generator"
                            ],
                            "outline_short": [
                                "introduce shared latent space prompt tuning framework",
                                "describe components of the framework, including instance encoder, prompt generator, and pre-trained language model"
                            ]
                        },
                        {
                            "title": "Computer and Networked Environments",
                            "paragraphs": [
                                "FIG. 2 is a simplified diagram illustrating a computing device implementing the shared prompt-tuning model described in FIG. 1, according to one embodiment described herein. As shown in FIG. 2, computing device 100 includes a processor 110 coupled to memory 120. Operation of computing device 100 is controlled by processor 110. And although computing device 100 is shown with only one processor 110, it is understood that processor 110 may be representative of one or more central processing units, multi-core processors, microprocessors, microcontrollers, digital signal processors, field programmable gate arrays (FPGAs), application specific integrated circuits (ASICs), graphics processing units (GPUs) and/or the like in computing device 100. Computing device 100 may be implemented as a stand-alone subsystem, as a board added to a computing device, and/or as a virtual machine.",
                                "Memory 120 may be used to store software executed by computing device 100 and/or one or more data structures used during operation of computing device 100. Memory 120 may include one or more types of machine-readable media. Some common forms of machine-readable media may include floppy disk, flexible disk, hard disk, magnetic tape, any other magnetic medium, CD-ROM, any other optical medium, punch cards, paper tape, any other physical medium with patterns of holes, RAM, PROM, EPROM, FLASH-EPROM, any other memory chip or cartridge, and/or any other medium from which a processor or computer is adapted to read.",
                                "Processor 110 and/or memory 120 may be arranged in any suitable physical arrangement. In some embodiments, processor 110 and/or memory 120 may be implemented on a same board, in a same package (e.g., system-in-package), on a same chip (e.g., system-on-chip), and/or the like. In some embodiments, processor 110 and/or memory 120 may include distributed, virtualized, and/or containerized computing resources. Consistent with such embodiments, processor 110 and/or memory 120 may be located in one or more data centers and/or cloud computing facilities.",
                                "In some examples, memory 120 may include non-transitory, tangible, machine readable media that includes executable code that when run by one or more processors (e.g., processor 110) may cause the one or more processors to perform the methods described in further detail herein. For example, as shown, memory 120 includes instructions for shared prompt-tuning module 130 that may be used to implement and/or emulate the systems and models, and/or to implement any of the methods described further herein. A shared prompt-tuning module 130 may receive input 140 such as a text input via the data interface 115 and generate an output 150 which may be an answer to the question, and/or the like. Examples of the input data may include a textual question, a sentence and/or the like. Examples of the output data may include a text classification, an answer, and/or the like.",
                                "The data interface 115 may comprise a communication interface, a user interface (such as a voice input interface, a graphical user interface, and/or the like). For example, the computing device 100 may receive the input 140 (such as a training dataset) from a networked database via a communication interface. Or the computing device 100 may receive the input 140, such as an articulated question, from a user via the user interface.",
                                "In some embodiments, the shared prompt-tuning module 130 is configured to be trained for various NLU tasks. The shared prompt-tuning module 130 may further include a pretrained PLM submodule 131, an instance encoder 132 and a prompt generator submodule 133, which are all further described in relation to FIG. 3. In one embodiment, the shared prompt-tuning module 130 and its submodules 131-133 may be implemented by hardware, software and/or a combination thereof.",
                                "Some examples of computing devices, such as computing device 100 may include non-transitory, tangible, machine readable media that include executable code that when run by one or more processors (e.g., processor 110) may cause the one or more processors to perform the processes of method. Some common forms of machine-readable media that may include the processes of method are, for example, floppy disk, flexible disk, hard disk, magnetic tape, any other magnetic medium, CD-ROM, any other optical medium, punch cards, paper tape, any other physical medium with patterns of holes, RAM, PROM, EPROM, FLASH-EPROM, any other memory chip or cartridge, and/or any other medium from which a processor or computer is adapted to read.",
                                "FIG. 3 is a simplified diagram illustrating a networked system implementing the shared prompt-tuning framework described in FIG. 1, according to one embodiment described herein. In one embodiment, block diagram 200 shows a system including the user device 210 which may be operated by user 240, data vendor servers 245, 270 and 280, server 230, and other forms of devices, servers, and/or software components that operate to perform various methodologies in accordance with the described embodiments. Exemplary devices and servers may include device, stand-alone, and enterprise-class servers which may be similar to the computing device 100 described in FIG. 1, operating an OS such as a MICROSOFT\u00ae OS, a UNIX\u00ae OS, a LINUX\u00ae OS, or other suitable device and/or server-based OS. It can be appreciated that the devices and/or servers illustrated in FIG. 2 may be deployed in other ways and that the operations performed, and/or the services provided by such devices and/or servers may be combined or separated for a given embodiment and may be performed by a greater number or fewer number of devices and/or servers. One or more devices and/or servers may be operated and/or maintained by the same or different entities.",
                                "The user device 210, data vendor servers 245, 270 and 280, and the server 230 may communicate with each other over a network 260. User device 210 may be utilized by a user 240 (e.g., a driver, a system admin, etc.) to access the various features available for user device 210, which may include processes and/or applications associated with the server 230 to receive an output data anomaly report.",
                                "User device 210, data vendor server 245, and the server 230 may each include one or more processors, memories, and other appropriate components for executing instructions such as program code and/or data stored on one or more computer readable mediums to implement the various applications, data, and steps described herein. For example, such instructions may be stored in one or more computer readable media such as memories or data storage devices internal and/or external to various components of system 200, and/or accessible over network 260.",
                                "User device 210 may be implemented as a communication device that may utilize appropriate hardware and software configured for wired and/or wireless communication with data vendor server 245 and/or the server 230. For example, in one embodiment, user device 210 may be implemented as an autonomous driving vehicle, a personal computer (PC), a smart phone, laptop/tablet computer, wristwatch with appropriate computer hardware resources, eyeglasses with appropriate computer hardware (e.g., GOOGLE GLASS\u00ae), other type of wearable computing device, implantable communication devices, and/or other types of computing devices capable of transmitting and/or receiving data, such as an IPAD\u00ae from APPLE\u00ae. Although only one communication device is shown, a plurality of communication devices may function similarly.",
                                "User device 210 of FIG. 2 contains a user interface (UI) application 212, and/or other applications 216, which may correspond to executable processes, procedures, and/or applications with associated hardware. For example, the user device 210 may receive a message indicating an answer to a question from the server 230 and display the message via the UI application 212. In other embodiments, user device 210 may include additional or different modules having specialized hardware and/or software as required.",
                                "In various embodiments, user device 210 includes other applications 216 as may be desired in particular embodiments to provide features to user device 210. For example, other applications 216 may include security applications for implementing client-side security features, programmatic client applications for interfacing with appropriate application programming interfaces (APIs) over network 260, or other types of applications. Other applications 216 may also include communication applications, such as email, texting, voice, social networking, and IM applications that allow a user to send and receive emails, calls, texts, and other notifications through network 260. For example, the other application 216 may be an email or instant messaging application that receives a result message from the server 230. Other applications 216 may include device interfaces and other display modules that may receive input and/or output information. For example, other applications 216 may contain software programs for asset management, executable by a processor, including a graphical user interface (GUI) configured to provide an interface to the user 240 to view the answer.",
                                "User device 210 may further include database 218 stored in a transitory and/or non-transitory memory of user device 210, which may store various applications and data and be utilized during execution of various modules of user device 210. Database 218 may store user profile relating to the user 240, predictions previously viewed or saved by the user 240, historical data received from the server 230, and/or the like. In some embodiments, database 218 may be local to user device 210. However, in other embodiments, database 218 may be external to user device 210 and accessible by user device 210, including cloud storage systems and/or databases that are accessible over network 260.",
                                "User device 210 includes at least one network interface component 219 adapted to communicate with data vendor server 245 and/or the server 230. In various embodiments, network interface component 219 may include a DSL (e.g., Digital Subscriber Line) modem, a PSTN (Public Switched Telephone Network) modem, an Ethernet device, a broadband device, a satellite device and/or various other types of wired and/or wireless network communication devices including microwave, radio frequency, infrared, Bluetooth, and near field communication devices.",
                                "Data vendor server 245 may correspond to a server that hosts one or more of the databases 203a-n (or collectively referred to as 203) to provide training datasets including training images and questions to the server 230. The database 203 may be implemented by one or more relational database, distributed databases, cloud databases, and/or the like.",
                                "The data vendor server 245 includes at least one network interface component 226 adapted to communicate with user device 210 and/or the server 230. In various embodiments, network interface component 226 may include a DSL (e.g., Digital Subscriber Line) modem, a PSTN (Public Switched Telephone Network) modem, an Ethernet device, a broadband device, a satellite device and/or various other types of wired and/or wireless network communication devices including microwave, radio frequency, infrared, Bluetooth, and near field communication devices. For example, in one implementation, the data vendor server 245 may send asset information from the database 203, via the network interface 226, to the server 230.",
                                "The server 230 may be housed with the shared prompt-tuning module 130 and its submodules described in FIG. 2. In some implementations, module 130 may receive data from database 219 at the data vendor server 245 via the network 260 to generate an answer to a visual question. The generated answer may also be sent to the user device 210 for review by the user 240 via the network 260.",
                                "The database 232 may be stored in a transitory and/or non-transitory memory of the server 230. In one implementation, the database 232 may store data obtained from the data vendor server 245. In one implementation, the database 232 may store parameters of the multilingual model 130. In one implementation, the database 232 may store previously generated answers, and the corresponding input feature vectors.",
                                "In some embodiments, database 232 may be local to the server 230. However, in other embodiments, database 232 may be external to the server 230 and accessible by the server 230, including cloud storage systems and/or databases that are accessible over network 260.",
                                "The server 230 includes at least one network interface component 233 adapted to communicate with user device 210 and/or data vendor servers 245, 270 or 280 over network 260. In various embodiments, network interface component 233 may comprise a DSL (e.g., Digital Subscriber Line) modem, a PSTN (Public Switched Telephone Network) modem, an Ethernet device, a broadband device, a satellite device and/or various other types of wired and/or wireless network communication devices including microwave, radio frequency (RF), and infrared (IR) communication devices.",
                                "Network 260 may be implemented as a single network or a combination of multiple networks. For example, in various embodiments, network 260 may include the Internet or one or more intranets, landline networks, wireless networks, and/or other appropriate types of networks. Thus, network 260 may correspond to small scale communication networks, such as a private or local area network, or a larger scale network, such as a wide area network or the Internet, accessible by the various components of system 200."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce computing device",
                                "describe processor and memory",
                                "describe operation of computing device",
                                "describe memory types",
                                "describe processor types",
                                "describe arrangement of processor and memory",
                                "describe distributed computing resources",
                                "introduce shared prompt-tuning module",
                                "describe input and output data",
                                "describe data interface",
                                "describe user interface",
                                "describe communication interface",
                                "describe networked database",
                                "describe computing device components",
                                "describe executable code",
                                "describe machine-readable media",
                                "describe computing device types",
                                "describe server types",
                                "describe device and server deployment",
                                "describe network communication",
                                "describe user device components",
                                "describe data vendor server components",
                                "describe server components",
                                "describe database components",
                                "describe network interface components",
                                "describe network types",
                                "describe system components"
                            ],
                            "num_characters": 13657,
                            "outline_medium": [
                                "describe computing device implementing shared prompt-tuning model",
                                "illustrate computing device",
                                "describe processor and memory",
                                "describe memory",
                                "describe shared prompt-tuning module",
                                "describe data interface",
                                "describe input data",
                                "describe output data",
                                "describe training for various NLU tasks",
                                "illustrate networked system implementing shared prompt-tuning framework",
                                "describe user device",
                                "describe data vendor servers and server",
                                "describe network"
                            ],
                            "outline_short": [
                                "describe computing device implementing shared prompt-tuning model",
                                "detail components of computing device, including processor and memory",
                                "describe data interface and input/output operations",
                                "introduce shared prompt-tuning module and its submodules",
                                "describe networked system implementing shared prompt-tuning framework",
                                "detail components of networked system, including user device, data vendor servers, and server"
                            ]
                        },
                        {
                            "title": "Example Work Flows",
                            "paragraphs": [
                                "FIGS. 4A-4B provide an example logic flow diagram illustrating a method of shared prompt-tuning in language models, according to some embodiments described herein. One or more of the processes of method 400 may be implemented, at least in part, in the form of executable code stored on non-transitory, tangible, machine-readable media that when run by one or more processors may cause the one or more processors to perform one or more of the processes. In some embodiments, method 400 corresponds to the operation of the shared prompt-tuning module 230 (e.g., FIGS. 2-3).",
                                "At step 402, a training dataset of instances and corresponding labels are received, via a data interface (e.g., 215 in FIG. 2). Each pair of instance and corresponding label corresponds to a source natural language processing (NLP) task or a target NLP task.",
                                "At step 404, an instance encoder (e.g., 132 in FIG. 1) may encode a first instance from the training dataset into a first embedding (e.g., 112 in FIG. 1) in a latent space (e.g., 116 in FIG. 1).",
                                "At step 406, a tunable set of skill vectors are retrieved in the latent space (e.g., 116 in FIG. 1).",
                                "At step 408, the first embedding (e.g., 112 in FIG. 1) may query the tunable set of skill vectors on the first embedding by determining a nearest neighbor to the first embedding as a first skill vector (e.g., 118 in FIG. 1) for the first instance.",
                                "At step 410, a prompt generator (e.g., 133 in FIG. 1) may transform the first skill vector into a set of prompt tokens (e.g., 136 in FIG. 1).",
                                "At step 412, a pretrained language model (e.g., 131 in FIG. 1) may generate a task output (e.g., 150 in FIG. 1) conditioned on an input of the first instance (e.g., 140 in FIG. 1) prepended with the set of prompt tokens (e.g., 136 in FIG. 1).",
                                "At step 414, a first training objective (e.g., L(a)) may be computed as a cross-entropy loss between a conditional distribution of the generated task output and a first label from the training dataset.",
                                "At step 416, a second training objective (e.g., L(E)) may be computed based on a difference between the first embedding and the first skill vector.",
                                "At step 418, a third training objective (e.g., L(\u03b1, E)) may be computed as a weighted sum of the first training objective and the second training objectives.",
                                "At step 420, the method 400 determines whether the first instance belongs to a source task. When the first instance is selected from a mixture of source NLP tasks, method 400 proceeds to step 422, where both the prompt generator and the tunable set of skill vectors are updated based on the third training objective (e.g., L(\u03b1, E)) via backpropagation while the pre-trained language model and the instance encoder are frozen. When the first instance is selected only for the target NLP task, method 400 proceed to step 424, where only the prompt generator is updated based on the first training objective (e.g., L(\u03b1)) via backpropagation while the tunable set of skill vectors, the pre-trained language model and the instance encoder are frozen."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "receive training dataset",
                                "encode instance into embedding",
                                "retrieve skill vectors",
                                "query skill vectors",
                                "transform skill vector into prompt tokens",
                                "generate task output and compute training objectives"
                            ],
                            "num_characters": 3023,
                            "outline_medium": [
                                "describe receiving training dataset",
                                "describe encoding instance and querying skill vectors",
                                "describe generating task output and computing training objectives"
                            ],
                            "outline_short": [
                                "outline method of shared prompt-tuning in language models"
                            ]
                        },
                        {
                            "title": "Example Data Experiments Performance",
                            "paragraphs": [
                                "For high-to-low resource transfer, the target tasks may be low-resource tasks (less than 10K training examples), while the source tasks are high-resource tasks. The testing dataset consists of 25 tasks in total. There are 15 source tasks (e.g., DocNLI, DROP) and 10 target asks (e.g., BoolQ, ColA). The data test setting are kept almost the same as a major experiment in Vu et al., SPoT: Better frozen model adaptation through soft prompt transfer, in Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 5039-5059, 2022, for a fair comparison, with the exception that C4 is excluded from the source task since it is much a larger dataset than other tasks. Excluding C4 does not affect SPOT performance since it does not provide an optimal source prompt for any target task.",
                                "In transfer across different task categories, the transferability from datasets is investigated in some task categories to datasets in other held-out task categories. Following Sanh et al., Multi-task prompted training enables zero-shot task generalization, in International Conference on Learning Representations, 2022, datasets are assumed in each category to measure a general NLP ability, and use the same taxonomy defined in Sanh et al. The source tasks include (1) QA tasks: ReCoRD, SQuAD, DROP, MultiRC, and RACE; (2) sentiment analysis tasks: Yelp-2 and SST-2; (3) a paraphrase detection task: QQP; (4) a semantic similarity task: CXC. The target tasks include (1) a sentence completion task: COPA; (2) NLI tasks: CB and RTE; (3) a coreference resolution tasks: WSC; (4) a word sense disambiguation task: WiC.",
                                "In training, all datasets are converted to a text-to-text format. All experiments are con-ducted with T5-base as the backbone unless stated.",
                                "SimCSE (Gao et al., SimCSE: Simple contrastive learning of sentence embeddings, in Empirical Methods in Natural Language Processing (EMNLP), 2021) model (BERT-base) are used as the instance encoder. Since the instance encoder is always frozen, the embeddings of all instances are pre-computed and only keep the embeddings. In source task training, the model (skill latent space and prompt generator) is simply tuned on the mixture of all source tasks for each setting. The model is tuned for 80K steps for the high-to-low setting, and 40K steps for the other setting. In learning and testing on target tasks, the model is tuned for 100K on each target task. A checkpoint every 500 steps, which is saved and report results on the checkpoint with the highest validation performance. The prompt generator generates 64 soft tokens in all experiments. The following hyperparameters are also shared in all target and source task training: learning rate (0.3), the number of warmup steps (4000), optimizer (Adam).",
                                "For high-to-low resource transfer, Table 1 in FIG. 5 shows the example results. The proposed method (referred to as SHARPT) are compared to methods with a comparable compute- and parameter-efficiency, PROMPT-TUNING (Lester et al., the power of scale for parameter-efficient prompt tuning, in Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing, pages 3045-3059, 2021) and SPOT-Retrieval (see Vu et al.). SHARPT demonstrates a clear improvement over the two methods across most tasks and on the average performance. SHARPT is also compared with much more expensive methods, SPOT-Oracle (see Vu et al.) and MODELTUNING. Note that SPOT-Oracle is significantly more expensive than SHARPT method since it tunes on each target task with each possible task prompt (e.g., it requires roughly 48 times more training time). While being much more efficient, SHARPT matches or outperforms SPOT-Oracle. Also, SHARPT performance is on par with the MODELTUNING performance which requires to tune the entire model. Together, these results indicate SHARPT is an efficient and competitive approach.",
                                "In transfer across different task categories, the results are shown in Table 2 of FIG. 6. SHARPT outperforms both PROMPTTUNING and SPOT methods. The improvement over SPOT methods is larger in this setting than in the high-to-low transfer setting. This might be because SPOT relies more on knowledge shared by tasks within in the same category, while SHARPT learns a shared latent space across all source tasks and is more able to leverage knowledge shared across datasets of different categories.",
                                "In across model scales, SHARPT can close the performance gap between full model tuning and prompt-based methods on a mid-sized model, T5-base (220M). Here conducts experiments with larger models, T5-large (800M) and T5-xl (3B) and compare SHARPT to MODELTUNING and PROMPTTUNING. As shown in FIG. 8, SHARPT matches or slightly outperforms MODELTUNING under the three model scales. Our method also shows considerable improvements over PROMPTTUNING.",
                                "Two key components of SHARPT are ablated: (1) training on source tasks; (2) skill latent space that captures shared knowledge. Example results are shown in Table 3 of FIG. 7. Clearly, knowledge learned from source tasks and encoded in the latent space is critical for target task performance.",
                                "For task relations, it is investigated if the latent space captures source and target task relations to allow knowledge transfer. Each instance queries the latent space and selects one latent skill. This selection is converted to a one-hot vector and treat it as an instance encoding. A task representation is the average of instance encodings in the task. The cosine similarity between two task representations is computed as their relation. The relations between source and target tasks are visualized in FIG. 9. It seems that more complicated source tasks such as QA and NLI tasks transfer more knowledge to target tasks via the skill latent space.",
                                "This description and the accompanying drawings that illustrate inventive aspects, embodiments, implementations, or applications should not be taken as limiting. Various mechanical, compositional, structural, electrical, and operational changes may be made without departing from the spirit and scope of this description and the claims. In some instances, well-known circuits, structures, or techniques have not been shown or described in detail in order not to obscure the embodiments of this disclosure. Like numbers in two or more figures represent the same or similar elements.",
                                "In this description, specific details are set forth describing some embodiments consistent with the present disclosure. Numerous specific details are set forth in order to provide a thorough understanding of the embodiments. It will be apparent, however, to one skilled in the art that some embodiments may be practiced without some or all of these specific details. The specific embodiments disclosed herein are meant to be illustrative but not limiting. One skilled in the art may realize other elements that, although not specifically described here, are within the scope and the spirit of this disclosure. In addition, to avoid unnecessary repetition, one or more features shown and described in association with one embodiment may be incorporated into other embodiments unless specifically described otherwise or if the one or more features would make an embodiment non-functional.",
                                "Although illustrative embodiments have been shown and described, a wide range of modification, change and substitution is contemplated in the foregoing disclosure and in some instances, some features of the embodiments may be employed without a corresponding use of other features. One of ordinary skill in the art would recognize many variations, alternatives, and modifications. Thus, the scope of the invention should be limited only by the following claims, and it is appropriate that the claims be construed broadly and, in a manner, consistent with the scope of the embodiments disclosed herein."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce experiment settings",
                                "define high-to-low resource transfer tasks",
                                "describe data test settings",
                                "exclude C4 from source tasks",
                                "introduce transfer across different task categories",
                                "define task categories",
                                "convert datasets to text-to-text format",
                                "describe training process",
                                "introduce SimCSE model",
                                "describe hyperparameters",
                                "present high-to-low resource transfer results",
                                "compare SHARPT to other methods",
                                "present transfer across different task categories results",
                                "ablate key components of SHARPT",
                                "discuss task relations and knowledge transfer"
                            ],
                            "num_characters": 7892,
                            "outline_medium": [
                                "introduce experiment settings",
                                "describe data test settings",
                                "motivate transfer across task categories",
                                "present results for high-to-low resource transfer",
                                "present results for transfer across task categories",
                                "ablate key components of SHARPT",
                                "discuss task relations and limitations of disclosure"
                            ],
                            "outline_short": [
                                "describe experiment setup",
                                "present results of SHARPT method",
                                "discuss implications and variations"
                            ]
                        }
                    ],
                    "outline_long": [
                        "define network and module terms",
                        "introduce finetuning and prompt models",
                        "describe soft prompt tuning",
                        "introduce shared latent space prompt tuning framework",
                        "describe instance encoder and prompt generator",
                        "describe loss computation and optimization"
                    ],
                    "num_characters": 3345,
                    "outline_medium": [
                        "define network and module",
                        "describe finetuning and soft prompt tuning",
                        "introduce shared latent space prompt tuning framework"
                    ],
                    "outline_short": [
                        "define terms and concepts related to neural networks and natural language processing"
                    ]
                }
            ],
            "outline_long": [],
            "num_characters": 0,
            "outline_medium": [],
            "outline_short": []
        }
    ],
    "claims": [
        "1. A method of shared prompt-tuning in language models, the method comprising:\nreceiving, via a data interface, a training dataset of instances;\nencoding, by an instance encoder, a first instance from the training dataset into a first embedding in a latent space;\nquerying a skill latent space on the first embedding to obtain a first skill vector;\ntransforming, by a prompt generator, the first skill vector into a set of prompt tokens;\ngenerating, by a pretrained language model, an answer in response to an input of the first instance prepended with the prompt tokens;\ncomputing a training objective based on the generated answer conditioned on the prompt generator and the first instance; and\nupdating the prompt generator based on the training objective via backpropagation while the pre-trained language model and the instance encoder are frozen.",
        "2. The method of claim 1, wherein the training dataset includes instances and corresponding labels, wherein each pair of instance and corresponding label corresponds to a source natural language processing (NLP) task or a target NLP task.",
        "3. The method of claim 1, wherein the querying the skill latent space includes:\nretrieving a tunable set of skill vectors in the latent space; and\nquerying the tunable set of skill vectors on the first embedding by determining a nearest neighbor to the first embedding as a first skill vector for the first instance.",
        "4. The method of claim 1, wherein the training objective comprises a first training objective that is computed as a cross-entropy loss between a conditional distribution of the generated answer conditioned on the prompt generator and the first instance and a first label corresponding to the first instance from the training dataset.",
        "5. The method of claim 4, further comprising:\ncomputing a second training objective based on a difference between a stop gradient operator over the first embedding and the first skill vector; and\ncomputing a third training objective as a weighted sum of the first loss training objective and the second training objective.",
        "6. The method of claim 5, further comprising:\nupdating both the prompt generator and the tunable set of skill vectors based on the third training objective via backpropagation while the pre-trained language model and the instance encoder are frozen,\nwhen the first instance is selected from a mixture of source NLP tasks.",
        "7. The method of claim 5, further comprising:\nupdating only the prompt generator based on the first training objective via backpropagation while the tunable set of skill vectors, the pre-trained language model and the instance encoder are frozen,\nwhen the first instance is selected only for the target NLP task.",
        "8. The method of claim 1, wherein the prompt generator is a light-weight multilayer perceptron (MLP).",
        "9. The method of claim 1, wherein the set of prompt tokens are generated by at least a tangent transformation of a linear transformation of the first skill vector.",
        "10. The method of claim 1, further comprising:\npre-computing, by the instance encoder, embeddings for instances in the training dataset; and\nretrieving the first embedding for the first instance at training stage.",
        "11. A system of shared prompt-tuning in language models, the system comprising:\na data interface that receives a training dataset of instances;\na memory storing an instance encoder, a skill vector generator, a prompt generator and a pretrained language model, and a plurality of processor-executable instructions; and\none or more processors reading and executing the plurality of processor-executable instructions to perform:\nencoding, by the instance encoder, a first instance from the training dataset into a first embedding in a latent space;\nquerying a skill latent space on the first embedding to obtain a first skill vector;\ntransforming, by the prompt generator, the first skill vector into a set of prompt tokens;\ngenerating, by the pretrained language model, an answer in response to an input of the first instance prepended with the prompt tokens;\ncomputing a training objective based on the generated answer conditioned on the prompt generator and the first instance; and\nupdating the prompt generator based on the training objective via backpropagation while the pre-trained language model and the instance encoder are frozen.",
        "12. The system of claim 11, wherein the training dataset includes instances and corresponding labels, wherein each pair of instance and corresponding label corresponds to a source natural language processing (NLP) task or a target NLP task.",
        "13. The system of claim 11, wherein an operation of querying the skill latent space includes:\nretrieving a tunable set of skill vectors in the latent space; and\nquerying the tunable set of skill vectors on the first embedding by determining a nearest neighbor to the first embedding as a first skill vector for the first instance.",
        "14. The system of claim 11, wherein the training objective comprises a first training objective that is computed as a cross-entropy loss between a conditional distribution of the generated answer conditioned on the prompt generator and the first instance and a first label corresponding to the first instance from the training dataset.",
        "15. The system of claim 14, wherein the operations further comprise:\ncomputing a second training objective based on a difference between a stop gradient operator over the first embedding and the first skill vector; and\ncomputing a third training objective as a weighted sum of the first loss training objective and the second training objective.",
        "16. The system of claim 15, wherein the operations further comprise:\nupdating both the prompt generator and the tunable set of skill vectors based on the third training objective via backpropagation while the pre-trained language model and the instance encoder are frozen,\nwhen the first instance is selected from a mixture of source NLP tasks.",
        "17. The system of claim 15, wherein the operations further comprise:\nupdating only the prompt generator based on the first training objective via backpropagation while the tunable set of skill vectors, the pre-trained language model and the instance encoder are frozen,\nwhen the first instance is selected only for the target NLP task.",
        "18. The system of claim 11, wherein the prompt generator is a light-weight multilayer perceptron (MLP).",
        "19. The system of claim 11, wherein the set of prompt tokens are generated by at least a tangent transformation of a linear transformation of the first skill vector.",
        "20. A non-transitory processor-readable storage medium storing a plurality of processor-executable instructions for shared prompt-tuning in language models, the instructions being executed by one or more processors to perform operations comprising:\nreceiving, via a data interface, a training dataset of instances;\nencoding, by an instance encoder, a first instance from the training dataset into a first embedding in a latent space;\nquerying a skill latent space on the first embedding to obtain a first skill vector;\ntransforming, by a prompt generator, the first skill vector into a set of prompt tokens;\ngenerating, by a pretrained language model, an answer in response to an input of the first instance prepended with the prompt tokens;\ncomputing a training objective based on the generated answer conditioned on the prompt generator and the first instance; and\nupdating the prompt generator based on the training objective via backpropagation while the pre-trained language model and the instance encoder are frozen."
    ]
}