# I. INTRODUCTION

In recent years, significant experimental progress has been made towards building a large-scale quantum computer. In platforms such as superconducting qubits and trapped ions, the error rates for small systems have been successfully suppressed below the threshold error rate of the surface code [1][2][3]. Using newly developed techniques for neutral atoms trapped in optical tweezer arrays, the coherence time, gate fidelity, and readout fidelity for large assemblies of qubits are being rapidly improved [4][5][6][7]. These advances give us hope that we will one day be able to perform fault-tolerant quantum computation by scaling up these systems while maintaining low error rates.

However, the scalability of leading approaches remains an important issue. Current estimates suggest that the engineering effort needed to build even a single logical qubit with logical error rate low enough for useful quantum computation could be enormous [8]. Quantum algorithms with practical ramifications can involve applying at least about 10 8 logical gates to about 100 logical qubits [9,10]. To ensure that the outcome of the computation is correct with high probability, the logical error rate would then need to be below about 10 -8 . Based on the subthreshold error scaling in Ref. [11], this would require at least about 400 physical qubits per logical qubit if the physical error rate is half the threshold.

Manufacturing, calibrating, and controlling physical qubits in such large numbers will be tremendously difficult. The fabrication process for components of solid-state quantum devices, such as quantum dots or superconducting circuits [1], is inevitably imperfect, leading to variations in the properties of individual qubits and their interactions. Even in systems where qubits are encoded in identical particles, e.g., trapped ions [2,3,12] or neutral atoms [4][5][6][7], experimental control parameters such as the strengths of laser excitation pulses or trapping potentials may exhibit inhomogeneity. Thus, in order to control these qubits with high fidelity, an experimental system needs to be accurately calibrated across the entire quantum computer. In superconducting circuits, for instance, inhomogeneity is unavoidable, and stray couplings between ideally independent qubits are an experimental fact of life that must be mitigated through control logic (see, e.g., Ref. [1]). The difficulty of doing so increases significantly with the number of qubits [13].

To circumvent these challenges, we propose a novel approach to fault-tolerant quantum computation, in which a well-protected logical qubit can be built using only a handful of experimental components. Consequently, the engineering effort required to develop the computer's components can be significantly reduced, potentially opening a simpler and more easily scalable route to fault-tolerant quantum computation. At a high level, our approach succeeds by shedding the limitations implicit in two assumptions that usually guide fault-tolerant circuit design: first, that the computer's qubits are all of the same type so are fairly homogeneous, and second, that good fault-tolerant gates should not propagate errors.

Specifically, we construct a fault-tolerant protocol for generating the three-dimensional cluster state of Ref. [14], using which universal fault-tolerant computation can be performed via adaptive single-qubit measurements. While there are already well-known procedures for preparing this state [14][15][16][17][18][19], our method has the advantage of being compatible with a much simpler experimental setup than what was originally envisaged in Refs. [14,20,21]. We take an approach similar to existing proposals for building large one-and two-dimensional cluster states using a small number of physical components [22][23][24][25][26]. However, while two-dimensional cluster states are universal for quantum computation, they are not known to support fault-tolerant quantum computation [27]. The step from universality to fault tolerance is not obvious and, in fact, quite surprising considering the architecture of the system.

Our protocol is built around a special ancilla qubit, Q, which interacts sequentially with a stream of data qubits propagating through a delay line. These data qubits are encoded in degrees of freedom sharing a common physical implementation, e.g., different temporal modes of photons or phonons in a waveguide. The only interactions are between Q and data qubits (and not between data qubits themselves), and these interactions are fixed and periodic, requiring a modest amount of calibration. We show, moreover, that all of the operations required in our protocol can be implemented using existing technologies in quantum photonic and phononic systems.

To demonstrate fault tolerance, we analyze the robustness of our protocol against both circuit errors and memory errors. We use a standard depolarizing model to describe circuit errors, which are associated with imperfect gates, measurements, and state initialization. Memory errors refer to errors that occur while qubits are idle, for which we study the effect of dephasing and qubit loss.

In the absence of memory errors, there is a threshold of 0.39% for the circuit error rate, below which the logical error can be arbitrarily suppressed by increasing the number of physical qubits. In the presence of memory errors, the logical error rate cannot be arbitrarily suppressed. However, provided that the circuit error rate is below threshold, the logical error rate decays rapidly with the inverse of the memory error rate. More precisely, suppose that the coherence time of the data qubits is lower bounded by T. Then, for a sufficiently large but finite T, the logical error rate can be made exponentially small in √ T/τ . Here, τ is the inverse of the frequency with which gates are applied, which is ultimately limited by the timescale for interactions between Q and data qubits. The number of logical gates that can be reliably executed will therefore scale exponentially with √ T/τ . A large separation between T and τ is often observed in certain experimental platforms, such as trapped ions or neutral atoms utilizing atomic clock transitions [4][5][6]12]. Indeed, because of the strict separation in the roles of Q and the data qubits, maximizing the ratio T/τ while maintaining high gate fidelity is an invitation to design a hybrid system consisting of two types of qubits with different physical substrates. That is the context in which we expect our scheme to be the most promising. Photonic [28] and phononic [29] delay lines are known to be good quantum memories, and can be coupled to controllable qubits capable of playing the role of Q.

To illustrate the potential of our scheme, suppose that memory errors are dominated by loss. Then, if the circuit error rate is 10 -3 -an aspirational but realistic target-our protocol can in principle attain a logical error rate of 10 -8 for τ/T ≈ 1.4 × 10 -5 , and 10 -15 for τ/T ≈ 3.2 × 10 -6 . Although these numbers are beyond the reach of current experiments, these estimates suggest that extremely low logical error rates can be achieved by improving a very small number of experimental components. In particular, if the operations involving Q can be calibrated such that circuit error rate is below the threshold value of 0.39%, incremental improvements of a single component-the delay line-can lead to drastic reductions in the logical error rate.

Although our scheme was primarily motivated by the aforementioned experimental considerations, it also has a novel feature that is counterintuitive from the point of view of fault tolerance. The design of fault-tolerant protocols usually aims to prevent the propagation of single-qubit errors to many qubits. This is achieved, naturally enough, by applying gates that do not spread errors, e.g., transversal gates, or "long" gates that are interspersed with errorcorrection steps, such as in lattice surgery [30]. In all of these methods, one actively avoids interacting one qubit with many others in a code block, since errors occurring on that qubit could propagate to the others, exceeding the error-correcting capabilities of the code.

In our protocol, we are actually deliberately taking this seemingly ill-advised approach: a single qubit (Q) is coupled to every data qubit. The depth of the circuit scales linearly with the number of data qubits, and no error detection or correction is performed during the process. Nevertheless, the procedure is fault tolerant in that any single-qubit error occurring in the circuit results in a constant-weight error on the final state. An interesting subtlety is that even though a single-qubit circuit-level error can in general be propagated by the subsequent gates to a highly nonlocal error, this nonlocal error is always equivalent under stabilizers of the prepared cluster state to some geometrically local error. More generally, we show that any m-qubit circuit-level error results in at most m geometrically local errors on the final state.

To summarize, our proposal and analysis indicate that fault-tolerant quantum computation could be achieved through the incremental improvement of a small number of key components, avoiding most of the systems engineering challenges inherent in leading approaches. This is possible because of three important features of our scheme. First, it only requires manufacturing and calibrating a constant number of experimental components, independent of the number of data qubits. Second, there are readily available experimental platforms that can realize our protocol. Third, any constant-weight error occurring during our protocol results in a constant-weight error on the prepared cluster state.

The rest of this paper is structured as follows. We provide the necessary background and a summary of our main results in Sec. II. We then present a hardware-independent description of our protocols in Sec. III. In Sec. IV, we analyze how errors propagate through our circuits, and numerically calculate thresholds for the circuit error rate. In Sec. V, we outline possible experimental implementations of our proposal in photonic and phononic systems. In Sec. VI, we study the effect of memory errors, estimating the logical error rates we can expect to achieve in various experimental platforms. We conclude with a discussion in Sec. VII.

# II. SUMMARY

We start by briefly reviewing the subject of fault-tolerant measurement-based quantum computation using cluster states in Sec. II A, focusing on the aspects that are relevant to this paper. We then summarize our main results in Sec. II B.

# A. Background

The cluster state |ψ G corresponding to an undirected graph G = (V, E) is defined as [31]  where each vertex i ∈ V is identified with a qubit, and Z a,b denotes the controlled-Z gate on qubits a and b. 

Here, X a and Z a denote Pauli X and Z on qubit a. The importance of cluster states in the theory of faulttolerant quantum computation was established by the seminal works of Raussendorf, Harrington, and Goyal [14,20,21], which demonstrated that universal faulttolerant quantum computation can be performed via singlequbit measurements on a particular cluster state. This cluster state corresponds to the body-centered cubic (bcc) lattice shown in Figs. 1 and2. Their scheme (for constructing this cluster state and extracting the syndrome) boasts a high threshold of p th ≈ 0.58% [33] under the standard depolarizing model for circuit errors, making it one of the most promising approaches for building a large-scale quantum computer.

To prepare the cluster state |ψ G bcc corresponding to the bcc lattice G bcc , Refs. [14,33] considered a simple constant-depth circuit, which follows directly from Eq. (1). Each qubit is initialized in the state |+ , and the controlled-Z gates in Eq. ( 1) for G = G bcc are applied in four layers. It is straightforward to see that any single-qubit error in this circuit propagates to a constant-weight error on |ψ G bcc . Together with the fact that |ψ G bcc is a foliation of the surface code [34], this implies that there is a finite threshold for the circuit error rate below which the logical error rate decays exponentially with the system size.

Given a cluster state on an L × L × N bcc lattice, one can perform fault-tolerant quantum computation by adaptively measuring the qubits in one of three bases (the eigenbases of the operators X , Z, and e iπ Z/8 Xe -iπ Z/8 ), depending on the logical gates that are to be executed. Note that a qubit can be measured before the full cluster state has been prepared, provided that all of the controlled-Z gates in Eq. ( 1) involving that qubit have been applied. Thus, FIG.

2. An example of a bcc lattice G bcc , with L = M = 5, and an ordering of its vertices. As discussed in the main text, certain labels are skipped, so that the neighbors of vertex i are given by {i ± 1, i ± L, i ± LM } ∩ V bcc . Labels after 30 have been omitted.

the cluster state could alternatively be prepared and measured in such a way that only O(L 2 ) physical qubits are in use at any given time. Roughly speaking, L determines the number of logical qubits that can be encoded and the distance of the underlying code, while N is related to the length of the logical computation. We refer the reader to Refs. [8,14,20,21] for further details.

Even though fault-tolerant computation can be in principle performed on such a cluster state, in this paper, we focus on realizing a fault-tolerant quantum memory. In particular, we consider using a cluster state on an L × L × L bcc lattice to store a single logical qubit. From the perspective of quantum error correction, this cluster state can be viewed as a spacetime history of the surface code [35,36] with L rounds of syndrome measurements, the bottom and the top boundaries of the cluster state corresponding to the surface codes at the initial and final steps of the errorcorrection protocol. Our estimates for the logical error rate, which decays exponentially with L under local noise models (cf. Secs. IV and VI), quantifies the probability that there is a logical bit or phase flip between the bottom and top layers.

The leading architecture for implementing this scheme is based on a two-dimensional array of physical qubits [11,20,21]. This approach suffers from an important practical problem, however. The space overhead, which is the ratio between the number of physical qubits and the number of logical qubits, is quite large in practice. For instance, the space overhead for running Shor's algorithm [37], assuming a physical error rate of 10 -3 , is estimated to be at least a few hundred [8,38]. Thus, building even a single logical qubit with low enough error rate will require hundreds if not thousands of physical components. Moreover, these components will need to be carefully calibrated to ensure that the physical error rates across all of the qubits are sufficiently low. While this is not impossible, it certainly requires a Herculean effort.

# B. Main results

Generally speaking, large space overhead is undesirable because the effort to build a fault-tolerant quantum computer may grow proportionately with the number of physical qubits. However, for the purpose of assessing the feasibility of a given architecture, it is important to distinguish the mathematical definition of space overhead from the engineering difficulty of building a quantum computer. We believe that a useful figure of merit for the latter is the component overhead, which is the number of basic experimental components used to build a single logical qubit. Of course, the precise definition of "experimental component" depends on the degrees of freedom that encode the quantum information. Once those degrees of freedom are identified, one can compare different protocols in terms of the required experimental components. This information can be related more directly to the feasibility of the protocol.

Component overhead can be an informative metric because the basic building blocks that constitute a largescale fault-tolerant quantum computer may be difficult to mass manufacture. Even though there are several experiments that report error rates below the thresholds of various fault-tolerant quantum computing schemes [8,14,20,21,39], these numbers are often obtained in a manner that is incompatible with scalability. This is due to the practical reality that, when the components are manufactured, they have sample-to-sample variations that lead to imperfect gates. Often, the reported numbers come from the very best of those samples, but if the variation is not negligible, many of the other samples will generally suffer from higher error rates. Therefore, given that high-quality components are difficult to come by, scalable fault-tolerant quantum computing protocols should aim to minimize the number of such components.

Motivated by this observation, we construct simple abstract protocols for fault-tolerant quantum computation that are amenable to extremely low component overhead. We also present concrete experimental proposals for realizing the protocols using a single transmon qubit interacting with a stream of phonons, or alternatively, an atom interacting with a stream of photons. Our protocols may be applicable more generally, e.g., to systems consisting of ions or neutral atoms. There are two distinguishing features of all these systems that are crucial. First, the degrees of freedom that encode the quantum information are either identical by nature or can be made to be nearly identical. Second, the qubits have long coherence times, leading to low memory error rates.

For systems that fulfill these conditions, we describe a simple method for preparing cluster states corresponding to the bcc lattice. A schematic illustration of the setup is given in Fig. 3. The procedure involves two types of qubits, a single actively controlled qubit Q and a large number of data qubits. Each data qubit interacts with Q several times, and these interactions are separated by time delays determined by the size of the bcc lattice. The data qubits do not interact with each other. The gates applied between Q and the data qubits are specified in Sec. III, and experimental techniques for realizing these gates are described in Sec. V. The procedure is an extension of the photonic machine gun proposal of Ref. [40] and variants thereof [25]. These works advocated methods for creating cluster states on one-and two-dimensional lattices, respectively, neither of which are known to be useful resources for fault-tolerant quantum computation. In contrast, our protocol prepares the cluster state on the bcc lattice, which (as discussed in Sec. II A) can be straightforwardly used as a resource state for fault-tolerant measurement-based quantum computation.

Independent of the precise sequence of gates between the control qubit Q and the data qubits, any protocol of the form depicted in Fig. 3 is at risk of being strongly susceptible to noise. There are two potential sources of concern. The first is that Q interacts with every single data qubit, without any intermediate syndrome measurements being performed. This creates the danger that an error occurring on Q could propagate to all of the data qubits that subsequently interact with Q. The second issue is that there is a time delay between successive interactions of the same data qubit with Q. For generating an L × L × N bcc lattice, the total time delay is proportional to L 2 . Thus, the total memory error accumulated during these time delays may be significant. The first of these is actually a nonissue. As discussed in Sec. IV, an important feature of our protocols is that even though single-qubit errors, including those on Q, may propagate to highly nonlocal errors, the effect of these errors on the prepared cluster state is always equivalent to that of geometrically local errors. Hence, using the standard depolarizing noise model for circuit errors and the usual minimum-weight perfect matching decoder, there is a finite threshold for the circuit error rate. We find threshold values of 0.23% and 0.39%, depending on the details of the protocol (see Secs. III B and IV B). Therefore, if memory errors are negligible, the logical error rate can be arbitrarily suppressed by increasing L.

In contrast, for non-negligible memory error rates, the logical error rate cannot be made arbitrarily small, since increasing L also leads to an increase in the total error incurred during the time delays. We study these effects in Sec. VI by assuming a nonzero error rate η per time step. As long as the circuit error rate is below threshold, we argue that by judiciously choosing L, the logical error rate can be made exponentially small in η -1/2 . We perform extensive numerical simulations, whose results show excellent agreement with this prediction. Since the logical error rate decays significantly faster than η for small values of η, the effect of memory error can be mitigated.

The fact that our scheme leads to small but not arbitrarily small logical error rates is reminiscent of the fault-tolerant quantum computing schemes using anyons [35,[41][42][43] or 0-π qubits [44][45][46]. In these approaches, the logical error rate is exponentially small in some large physical parameter. In ours, this parameter is η -1/2 .

# III. CLUSTER STATE PREPARATION

In this section, we present a general algorithm for preparing cluster states associated with arbitrary graphs G = (V, E) (Sec. III A). We then apply this algorithm in two different ways to prepare cluster states on the bcc lattice of Ref. [14] (Sec. III B). The standard procedure for preparing cluster states is to initialize each qubit in the |+ state and apply controlled-Z gates according to Eq. ( 1). Since a controlled-Z gate between qubits a and b is required for every (a, b) ∈ E, this approach involves |E| distinct gates. All of these gates must be carefully calibrated and implemented, making the experimental realization of this protocol daunting.

In contrast, our protocols bypass the need to calibrate and implement a large number of physically distinct operations, allowing for simple experimental realizations, as explained in Sec. V. In our algorithm, there is a single ancilla Q that interacts with the data qubits (which correspond to the vertices V of G) one by one. Physically, Q is an actively controlled qubit, while the data qubits are identical degrees of freedom (e.g., phonons or photons generated from a single source, ions, or neutral atoms) that passively interact with Q. The data qubits do not ever need to interact with each other. In this setting, one can simply tune a constant number of interactions between the controllable qubit and the physical system representing the data qubits to calibrate every gate.

# A. Algorithm for arbitrary graphs

In this subsection, we provide an algorithm, Algorithm 1, for preparing cluster states |ψ G on arbitrary graphs G. The correctness proof for this algorithm is given in Appendix 2.

First, we define some notation. Here and throughout the paper, H a denotes the Hadamard gate acting on qubit a, and P a the Pauli operator P ∈ {X , Y, Z} on qubit a. We write X a,b to represent the controlled-X gate with control qubit a and target qubit b, and Z a,b the controlled-Z gate between qubits a and b, with

We also use the convention that the operators A j in the product k j =1 A j are ordered as

and that an empty product of operators acts as the identity.

The main idea behind Algorithm 1 is to generate progressively larger cluster states related to subgraphs of G = (V, E) by adding in one qubit at a time. Specifically, let n := |V| be the number of data qubits and fix an ordering of the qubits by labeling them from 1 to n. For a given ordering, the qubit labeled 1 is added first, followed by the qubit labeled 2, and so on.

To explain the algorithm, it will be convenient to define graphs G[k] as follows. For each k ∈ [n] := {1, . . . , n}, let E[k] denote the set of edges in the subgraph of G induced by the vertex subset [k], i.e.,

Then, let As shown in Appendix B 2, the purpose of applying Z j in line 8 is to "fix" the cluster state in the case where Q is measured in line 6 of the j th iteration and the outcome is |1 . Observe that all of the necessary Z j corrections could be deferred to the end of the procedure, instead of being implemented immediately. Alternatively, the Z j need not be applied at all if we keep track of all of the measurement outcomes and the modified cluster state stabilizers in the subsequent computation.

Note that different orderings of the qubits (i.e., different assignments of the labels 1 through n to the vertices in V) give rise to different circuits via Algorithm 1, but every such circuit correctly produces the same state |ψ G . One may choose an ordering that is more conducive to experimental realization of the algorithm. Furthermore, in the case where G contains a Hamiltonian path, Algorithm 1 does not require any intermediate measurements of Q. By ordering the qubits such that (i, i + 1) ∈ E for all i ∈ [n -1], lines 6-9 are skipped in every iteration of the main loop, which simplifies the procedure.

# B. Three-dimensional cluster states

In this subsection, we describe two protocols, Protocols A and B, for preparing cluster states on the bcc lattice G bcc of Ref. [14] (cf. Figs. 1 and2). Protocol B involves first using Algorithm 1 to prepare the cluster state on a cubic lattice, then measuring out certain qubits to obtain |ψ G bcc . Protocol B applies Algorithm 1 to G bcc directly. We propose experimental implementations of both protocols in Sec. V. . Note that H Q X Q,i has the effect of swapping the state of Q onto qubit i and adding an edge between Q and i; see Eq. (B4) in Appendix B 1.

These protocols have different strengths and weaknesses. Unlike Protocol B, Protocol A requires no intermediate measurements of the controllable qubit Q, and is therefore expected to be simpler to implement. However, as we show in Sec. B, the error threshold of Protocol A is lower than that of Protocol B.

# Protocol A

Protocol A consists of two main steps. First, we use Algorithm 1 to prepare the cluster state |ψ G c on a certain cubic lattice G c , defined below, that contains G bcc as a subgraph (line 1). Second, we obtain |ψ G bcc from |ψ G c by removing the qubits that are not in G bcc via single-qubit Z measurements (lines 2-5).

The cubic lattice we consider is the graph

If n = LMN for some N ∈ N then G c is an L × M × N cubic lattice with shifted periodic boundary conditions; G c differs from a standard cubic lattice with open boundary conditions only in that G c has various additional edges between vertices on the boundary. Note from Eq. ( 5) that, for every i ∈ [n -1], (i, i + 1) is an edge in G c . Consequently, when we apply Algorithm 1 to G c , the if condition of line 5 is never satisfied and lines 6-9 are not executed, except in the very last iteration (j = n) of the for loop. Thus, Algorithm 1 reduces to a unitary circuit that prepares |ψ G c [n] , together with a single measurement of Q at the end to change |ψ G c [n] to |ψ G c . This circuit is shown in Fig. 5.

Since the bcc lattice G bcc is a subgraph of G c , we can then measure the qubits of |ψ G c that are not in G bcc in the Z basis to remove them. We also need to measure all of the qubits on the boundary in G c in the Z basis, in order to get rid of the shifted periodic boundary conditions [47]. After applying the appropriate Pauli corrections based on the outcomes of these measurements, we obtain the desired cluster state |ψ G bcc .

# Protocol B

Protocol B prepares |ψ G bcc by directly applying Algorithm 1 to G bcc .

For notational convenience in Sec. IV, we adopt the following convention for the bcc lattice. We label the qubits of an L × M × N bcc lattice as we would an

if the outcome is |1 then 5:

# Zj

Protocol A Prepare the cluster state |ψ G bcc on the bcc lattice G bcc = (V bcc , E bcc ) of Ref. [14] 1: apply Algorithm 1 to G bcc Protocol B Prepare the cluster state |ψ G bcc on the bcc lattice G bcc = (V bcc , E bcc ) of Ref. [14] cubic lattice, omitting the numbers corresponding to the cubic lattice sites that are "missing"-see Fig. 2 for an example illustrating this convention. This is a slight departure from the notation in Algorithm 1 (which assumes that the qubits are numbered from 1 through n), but the instructions of Algorithm 1 can be adapted straightforwardly. Figure 6 shows part of the resulting circuit for the lattice in Fig. 2.

Using our labeling convention, the nearest neighbors of a qubit i are simply {i ± 1, i ± L, and/or i ± LM } ∩ V bcc . Each of the qubits, except those on the boundary, has four nearest neighbors, all of which lie in the same plane. Thus, we divide the qubits into three groups, V xy , V yz , and V zx , where qubit i is in V xy (respectively V yz , V zx ) if the nearest neighbors of i are in the x-y (respectively y-z, z-x) plane. Letting N bcc (i) denote the set of nearest neighbors of i in G bcc , we have (cf. Fig. 2)

For qubits i that are in the bulk of the lattice, the above holds with equality.

# IV. ERROR ANALYSIS

The protocols described in Sec. III are useful only insofar as they are fault tolerant. The operations used in the protocols will generally be noisy, resulting in the preparation of imperfect cluster states. Since the ancilla qubit Q interacts with every data qubit in Algorithm 1, singlequbit errors occurring during the procedure may propagate through the subsequent operations to highly nonlocal errors. We show, however, that the effect of these errors on the target cluster state is always equivalent to that of geometrically local errors. This allows us to demonstrate that, for both Protocols A and B, there is a threshold for the circuit error rate below which the logical error rate rapidly decays with the system size.

To make our reasoning precise, let g 1 , . . . , g D denote the sequence of Clifford gates in Algorithm 1 [48], and for j , k ∈ [D], let C k j := k i=j g i . Then, if a Pauli error P a occurs on some qubit a between the gates g -1 and g , the erroneous circuit implements C D P a C -1

1 . The prepared state is

where |φ initial is the input state, |φ final = C D 1 |φ initial denotes the state prepared by the error-free circuit, and

In other words, the circuit-level error P a propagates to an error Q, which may be highly nonlocal in general. In fact, for certain choices of P a and , the weight of Q scales with the total number of qubits.

However, Eq. ( 7) holds for arbitrary |φ initial , with Q independent of the initial state. The fact that errors propagate nonlocally for generic input states is not necessarily an issue-the purpose of Algorithm 1 is not to perform some computation on arbitrary inputs, but rather, to prepare a fixed resource state. Therefore, the only relevant analysis is that for the particular input state |φ initial := |+ Q n i=1 |0 i to Algorithm 1, which leads to the particular output state |φ final = |+ Q |ψ G . Clearly, Q|φ final = QS|φ final for any stabilizer S of |φ final . Therefore, even if Q is a high-weight operator, it may have the same effect on |φ final as a low-weight operator.

It will hence be useful to define the notion of effective errors. We say that a circuit-level Pauli error P a occurring

FIG. 5. Algorithm 1 applied to the cubic lattice G c [cf. Eq. ( 5)] for L = 3, M = 2, and n = 2LM . This circuit prepares |ψ Gc on the data qubits, and is the first step of Protocol A. The last operation could be replaced by Z Q,n .

FIG. 6. Part of Protocol B for the bcc lattice in Fig. 2. Only the first ten iterations of the for loop in Algorithm 1 are shown. This abridged circuit prepares |ψ G bcc [12] [cf. Eq. ( 4)]. Note that all Pauli-Z corrections conditioned on the outcomes of the measurements of Q can be deferred to the end of the circuit. at depth results in an effective error E if

This definition generalizes straightforwardly to arbitrary circuit-level errors. Note that, unlike Eq. ( 7), Eq. ( 8) is not a gate identity, as it may depend crucially on the input state |φ initial . Note also that E is not unique.

If multiple Pauli errors occur in the circuit, their joint effect is multiplicative up to a sign. To see this, consider two Pauli errors P a and P b occurring at depths 1 and 2 , respectively, with 1 ≤ 2 . Suppose that the circuit-level error P a (at depth 1 ) results in an effective error E 1 , in the sense of Eq. ( 8), and P b (at depth 2 ) results in an effective error E 2 . Then, the circuit containing both errors prepares

where the second and fourth equalities use Eq. ( 8), and the phase (-1) s is either +1 or -1 depending on whether E 1 and C D 2 P b (C D 2 ) † (which are both Pauli products) commute or anticommute. Thus, the two circuit-level errors collectively result in an effective error E 1 E 2 , up to a sign. Analogous results hold for more than two errors.

It follows that in order to study a stochastic noise model involving Pauli errors, it suffices to analyze the effective errors resulting from single-qubit circuit-level errors. The effect of multiqubit circuit-level errors can then be inferred from Eq. ( 9).

As we discuss in Sec. IV A, any single-qubit error occurring during Protocol A or B results in a local effective error on the final state. This is a special case of the more general result, proven in Appendix C 1, for Algorithm 1 applied to arbitrary graphs. In Sec. IV B, we estimate the threshold circuit error rates for both protocols, obtaining 0.23% for Protocol A and 0.39% for Protocol B.

# A. Effective errors

In this subsection, we consider the effect of errors that occur during Protocols A and B, both of which prepare the cluster state |ψ G bcc on the bcc lattice G bcc . These protocols both apply Algorithm 1 (but to different graphs). In Appendix 1, we prove that, for any graph G = (V, E), any single-qubit error occurring between the elementary operations of Algorithm 1 results in an effective error [cf. Eq. (8)] that is geometrically local, in the sense that it is supported within {i} ∪ N (i) for some data qubit i ∈ [n], where N (i) := {j : (i, j ) ∈ E} denotes the nearest neighbors of i in G.

The proof uses the following key observations.

(1) First, it is clear from Figs. 5 and 6 that any Z i error on a data qubit i ∈ [n] either occurs before the X Q,i gate and has no effect, as the initial state of i is |0 , or it occurs after the X Q,i , in which case it commutes with all subsequent operations and ends up as a Z i error on the final state. Thus, any single-qubit Z error on a data qubit results in either no error or a Z error on the same qubit. (2) Second, the instantaneous state of the qubits at any point in the procedure is a cluster state [49], as illustrated by Fig. 4(b). In the underlying graph of any of these intermediate cluster states, every edge between data qubits is also an edge in the graph G of the target state |ψ G , and the only edges involving the ancilla Q are between Q and j ∈ S for a subset S of N (i) for some i ∈ [n]. It then follows from the stabilizer condition, Eq. ( 2), that any single-qubit X error in the circuit has the same effect as a set of Z TABLE I. A complete list of X and Z errors that could occur during line 1 of Protocol A, which prepares a cluster state on the cubic lattice G c , and their effect on the final state [cf. Eq. ( 8)] up to a sign. The notation A j is defined in Eq. (10). We use the convention that Z j ≡ I for any j / ∈ [n]. Additionally, any Z i error occurring during lines 2-5 results in a Z i error, while an X i error results in either X i or j ∈S Z j for some S ⊆ N c (i), depending on its precise location.

# Circuit-level

Effective error on error Location in circuit final state (|ψ Gc )

Immediately after

Immediately after B k (i.e., after

errors confined to the neighbors of some data qubit (and possibly Q).

Combining these two observations with Eq. ( 9), it can be shown that any single-qubit Pauli error leads to an effective error of the form j ∈S Z j , where S ⊂ {i} ∪ N (i) for some i ∈ [n]. We fill in the details in Appendix C 1. Here, we simply summarize the results that are relevant to the threshold calculations in the following subsection. We start by considering the effective errors in Protocol A. Recall that the first step (line 1) applies Algorithm 1 to the cubic lattice G c defined by Eq. ( 5), yielding a circuit of the form of Fig. 5. Table I lists all of the X and Z errors that may occur in this circuit and the effective errors they give rise to. Note that it suffices to consider the effect of single-qubit X and Z errors, as the effect of arbitrary errors can then be inferred by decomposing them in terms of Pauli operators and using Eq. (9). To clearly distinguish between the gates in the circuit, we use A j to denote the j th "block" of gates (cf. line 4 of Algorithm 1) [50],

Spatially, circuit-level errors may occur on the ancilla Q or a data qubit i ∈ [n], and temporally, they may be located between two blocks A j and A j +1 , before the first block A 1 , after the last block A n , or between two gates in the same block. Table I covers all of these possibilities.

By Eq. ( 5), the set

Hence, we can see from Table I [and Eq. ( 2)] that any single-qubit X error results in an effective error of the form j ∈S Z j up to a sign, where S ⊂ N c (i) for some i ∈ [n], while any Z error results in either no effective error or a single-qubit Z error. Moreover, X and Z errors occurring at the same spacetime location in the circuit result in effective (Z) errors supported within {i} ∪ N c (i) for the same i, which implies that any single-qubit error occurring at that location leads to an effective error supported within {i} ∪ N c (i). This is easily verified using Table I. As an example, an X error on Q between gates Z Q,k-LM and Z Q,k-L in A k results in an effective error Z k-LM Z k-1 , while a Z error at this location results in a Z k error, and

Therefore, at the end of line 1 of Protocol 1, the effective error induced by any single-qubit error can be decomposed into Z operators supported within some neighborhood of G c . Note that the remaining steps, lines 2-5, of Protocol A do not propagate this effective error further, as Z errors commute with Z gates and do not affect Z measurements. By the same argument, a single-qubit Z error occurring during lines 2-5 does not propagate to other qubits. It is also clear that a single-qubit X error on qubit i occurring during these steps is equivalent to Z errors on a subset of N c (i). It follows that the effective error on |ψ G bcc resulting from any single-qubit error in Protocol A is geometrically local with respect to G c , i.e., supported within the neighborhood {i} ∪ N c (i) of some qubit i ∈ [n]. Such an error is also geometrically local with respect to G bcc if i ∈ V bcc , while if i ∈ V bcc , it is still confined to an elementary cell of G bcc (cf. Fig. 1.)

An even stronger result holds for Protocol B, which directly prepares |ψ G bcc using Algorithm 1. Table II lists the effective errors resulting from all possible single-qubit X and Z errors. In the table, B j denotes the block of gates applied in the for loop iteration of Algorithm 1 (for G = G bcc ) corresponding to qubit j . Recalling the labeling convention for G bcc described in Sec. III B 2,

As shown in Fig. 6, Q is measured and reset between certain gate blocks, and Table II includes the effects of measurement and reset errors as well. It is clear from Table II and Eq. ( 6) that the effective error induced by any single-qubit Pauli error is equivalent to a product of Z operators supported within {i} ∪ N bcc (i) for some i ∈ V bcc .

TABLE II. A complete lists of X and Z errors that could occur during Protocol B, which prepares a cluster state on the bcc lattice G bcc , and their effect on the final state [cf. Eq. ( 8)] up to a sign. The qubits are labeled according to the convention described in Sec. 2, and B j is defined in Eq. (11). For any indices j that are out of range, Z j ≡ I . The results for X Q errors occurring immediately after X Q,k (row 3) hold for all qubits k that are in the bulk of the bcc lattice. However, as can be seen from Fig. 2, there are certain qubits k ∈ V xy , V zx on the boundary for which (k, k + 1) ∈ E. In these cases, Q is measured after B k (line 6 of Algorithm 1) and there is no effective error.

# Circuit-level error Location in circuit

Effective error on final state (|ψ G bcc )

Thus, single-qubit errors occurring at any spacetime location in Protocol B result in effective errors on |ψ G bcc that are geometrically local with respect to G bcc . Since all vertices in G c and G bcc have constant degree, it follows [from Eq. ( 9)] that any m-qubit circuit-level error results in an effective error of weight cm for some constant c independent of the system size. Standard arguments then imply that, for both Protocols A and B, there is a finite threshold for the circuit error rate [51,52]. We compute these thresholds in the following subsection.

We make a side remark on the role of intermediate measurements. It is tempting to guess that these measurements are responsible for the locality of the effective errors, but that is emphatically not the case. In Protocol A, no intermediate measurements are ever performed during the preparation of |ψ G c , yet all of the effective errors are geometrically local with respect to G c (cf. Table I). It is surprising that there is a nontrivial extensive-depth faulttolerant protocol without intermediate measurements; the usual approach involves frequent intermediate measurements to extract syndrome information, so that one can catch the errors. In contrast, we only perform error correction at the very end, after an extensive-depth circuit has been executed. Finding necessary and sufficient conditions under which this is possible is an important open problem left for future work.

# B. Thresholds

Using the results of the previous subsection, we can calculate error thresholds for our protocols via Monte Carlo simulations. In order to compare Protocols A and B to the standard cluster state preparation circuit in Ref. [14], we consider the standard depolarizing model (Error Model 1 below) and use the minimum-weight perfect matching (MWPM) decoder [14,53]. We also study the effect of qubit loss (Error Model 2) using the decoder of Ref. [33], which is also based on MWPM.

For various values of the circuit error rate p, loss error rate p loss , and size L, we estimate the logical error rate p for generating an L × L × L cluster state |ψ G bcc (storing one logical qubit). We average over at least 10 6 independent instances and at least 10 4 logical errors for each set of parameters. For each p loss , we then estimate the threshold circuit error rate p th by fitting the data to a quadratic scaling ansatz

where d = (L + 1)/2.

# Error Model 1

Error Model 1 is the standard depolarizing model. In this model, every single-qubit gate on a qubit a is followed by a single-qubit depolarizing channel

on a. In addition, every (re)initialization of a is followed by D (p) a , and every measurement of a is preceded by D (p) a . Here, measurements include not only those in Protocols A and B, but also the eventual X -measurements on data qubits that are required for extracting the syndrome. Similarly, every two-qubit gate on qubits a and b is followed by a two-qubit depolarizing channel We refer to p as the circuit error rate.

For Protocols A and B, we can simulate the effect of each of these depolarizing errors on the final state using Tables I and II. Our results [along with the fits to Eq. ( 12)] are plotted in Fig. 7. The threshold circuit error rate p th is found to be 0.23% for Protocol A and 0.39% for Protocol B.

In comparison, the threshold for the scheme of Ref. [14] under the same error model is 0.58%. Refs. [20,21] improved this to 0.75% by exploiting sublattice correlations, and Ref. [33] obtained 0.63% by accounting for the degeneracies of different matchings. We do not exploit correlations nor account for degeneracy in our decoder.

We surmise that the threshold for Protocol A is lower than that for Protocol B due to the following reasons. First, Protocol A uses substantially more qubits and operations than Protocol B to prepare a cluster state of the same size, giving rise to more error locations under Error Model 1. Second, all of the effective errors in Protocol B are geometrically local with respect to the bcc lattice G bcc , whereas some of the effective errors in Protocol A are only geometrically local with respect to the cubic lattice G c . For example, suppose that an X error occurs on a qubit i ∈ V c \ V bcc immediately before the Z measurement of i in line 3 of Protocol A. By Eq. ( 2), this results in a Z error on all of the neighbors of i in G c , which constitutes a weight-6 error on the face qubits of an elementary cell of G bcc (cf. Fig. 1). In contrast, all of the effective errors resulting from single-qubit errors in Protocol B are geometrically local with respect to G bcc , and, moreover, have weight at most 4 (when restricted to either the primal or dual lattice).

# Error Model 2

Next, we add detectable loss errors to the standard depolarizing noise model. In Error Model 2, every elementary operation is followed or preceded by a depolarizing channel with error rate p in exactly the same way as in Error Model 1. In addition, each data qubit is lost by the end of the procedure with probability p loss . Hence, Error Model 2 reduces to Error Model 1 for p loss = 0. We assume that if a qubit i is lost at some point then any subsequent operation on i is replaced by the identity operator followed by depolarizing noise with rate p. The assumption that losses are detectable and that operations involving lost qubits implement the identity is consistent with the experimental setup considered in Sec. V. Figure 8 shows our estimates for the threshold circuit error rate p th at various values of p loss . The solid line in each plot is a quadratic fit to the data. Extrapolating to p th = 0, these fits give rough estimates for the loss threshold of 5.7% for Protocol A and 21.6% for Protocol B. Both plots have the same structure as Fig. 1 in Ref. [33], which provides thresholds for the circuit of Ref. [14] under the same error model (but using a slightly better decoder, as discussed above).

The loss threshold for Protocol A is significantly lower than that for Protocol B due to the fact that in our simulations, losing a qubit in V c \ V bcc amounts to losing (up to) six qubits in V bcc . This is because if a qubit i ∈ V c \ V bcc is lost, we would not know whether the correction j ∈N c (i) Z j should be applied in line 5 of Protocol A. Instead of simulating this as a weight-6 Z error (with probability 1/2), we simply treat all of the qubits in N c (i) as having been lost in the decoding algorithm. Thus, the total probability of "losing" a qubit in V bcc is greater than p loss for Protocol A.

While Error Model 2 allows for a direct comparison to Ref. [33], and may be an informative model for settings where the total loss probability is constant, it does not properly capture the structure of the noise expected when storing the data qubits in delay lines. Informed by the description of possible experimental implementations in the next section, we revisit the effect of delay line noise in Sec. VI.

# V. EXPERIMENTAL REALIZATION

In this section, we outline potential experimental realizations of the abstract protocols in Sec. B, focusing on implementations in quantum nanophotonic and acoustic systems [54,55]. Recent advances in the deterministic generation of single photons and single phonons [56,57] and their coherent interactions with a single quantum emitter [29,[58][59][60][61][62][63][64]] make these systems promising platforms for quantum information processing. Indeed, single and double chains of one-dimensional cluster states have already been produced in experiments using photons emitted from quantum dots [65]. These experiments implement modified versions of the circuit in Ref. [40], which is a specific instance of Algorithm 1. The techniques detailed in Refs. [25,40] can be adapted to our more general protocols, to create cluster states on different graphs. In particular, the experimental setup considered in Ref. [25] can be directly extended to implement the first step of Protocol A (cf. Fig. 5), providing a simple procedure for preparing a three-dimensional cluster state on a cubic lattice. Universal fault-tolerant quantum computation can then be performed by making adaptive single-qubit measurements on this state [14].

There are several key ingredients required for realizing Protocols A and B. First, we must be able to implement the elementary operations in these protocols, namely, the single-qubit operations on Q, the controlled-X gates X Q,i and controlled-Z gates Z Q,i between Q and data qubits, and single-qubit measurements of the data qubits. Second, we must be able to coordinate the interactions between Q and the data qubits such that these operations are applied in the correct order. Additionally, to be able to perform error correction when the loss rate is significant, the qubit states must be encoded in such a way that losses are detectable.

These capabilities can be naturally achieved in a system consisting of a single quantum emitter (e.g., an atom, ion, transmon, or quantum dot) coupled to a photonic or phononic waveguide [cf. Fig. 9(a)]. In such a system, any stable internal states of the emitter can be used to encode qubit degrees of freedom for Q, while any radiative states of the emitter that are coupled to the waveguide can be leveraged to realize certain gates between Q and a photon or phonon propagating in the waveguide. We show below that the set of available gates is sufficient for Algorithm 1. Moreover, the routing of the photons or phonons required to realize the geometry of the target graphs of Protocols A and B is rather simple.

# A. Encoding schemes and elementary gates

In this subsection, we describe two encoding schemes and the gates that can be implemented in each. We refer to these as the single-rail and the dual-rail encoding schemes, summarized in Figs. 9 and 10, respectively.

# (a)

Quantum emitter

9. Schematic diagrams illustrating the implementation of required gates in quantum photonic or acoustic systems. (a)

The quantum emitter Q has three relevant quantum states. Two stable states, |0 and |1 , form a qubit, while an extra unstable excited state |e is used to generate propagating photons or phonons in a guided mode. (b) The operation X Q,i , which has the same effect as X Q,i when acting on |0 i [cf. Eq. ( 15)], can be implemented via selective emission of a photon or phonon to the guided mode. (c) A controlled-Z gate Z Q,i can be implemented via the scattering of a photon or phonon against the emitter.

# Single-rail encoding

In the single-rail scheme, the |0 (respectively |1 ) state of each data qubit i is encoded by the absence (respectively presence) of a photon or phonon. Multiple data qubits can be encoded in a single waveguide by controlling the rate of the excitation pulses, in the so-called time multiplexing technique. More specifically, if the pulse-to-pulse time separation τ is sufficiently long compared to the temporal extent of an emitted photon or phonon mode, different modes separated by τ have exponentially small overlap [25]. We note that the temporal extent of each emitted mode, or, equivalently, the effective emission rate γ , can be controlled using advanced techniques such as pulse shaping [25,56].

For the emitter Q, we consider a three-level system consisting of two stable states, |0 and |1 , along with a radiative state, |e [cf. Fig. 9(a)]. Arbitrary single-qubit gates on Q can be realized via resonant coherent excitations between |0 and |1 .

Then, for the two-qubit gates X Q,i , note that each X Q,i in Algorithm 1 is applied when data qubit i is in its initial state |0 . This means that instead of implementing a controlled-X gate X Q,i that correctly transforms arbitrary states of i, we can use an operation X Q,i that has the same effect as X Q,i when i is in the specific state |0 (i.e.,

for any state |ϕ of Q, potentially entangled with the rest of the system). The operation X Q,i can be realized by applying a rapid resonant excitation pulse |1 → |e , which is followed by the spontaneous emission of a photon or phonon into the waveguide [cf. being |1 . Thus, the net effect is

where |φ 0 rest and |φ 1 rest are (unnormalized) states of the rest of the system. The controlled-Z gate Z Q,i can be naturally realized by scattering a propagating photon or phonon against the emitter Q [59-63] [cf. Fig. 9(c)]. If Q is in the state |0 , the propagating photon or phonon remains unaffected due to the absence of any resonant couplings. On the other hand, if Q is in the state |1 , the propagating photon (phonon) is scattered by Q owing to the resonant transition |1 ↔ |e , giving rise to a scattering phase e iθ . By engineering γ γ , this scattering phase approaches e iθ ≈ -1, and this process effectively applies Z Q,i .

# Dual-rail encoding

In the dual-rail scheme, a qubit degree of freedom is encoded in two distinct internal modes of a single photon or phonon, such as different polarizations or frequencies. When photon or phonon loss is the dominant source of error, the dual-rail scheme can be advantageous since the detection of a single photon or phonon heralds the absence of loss errors (assuming no false-positive detections). As shown in Sec. B, the threshold for loss errors is significantly higher than that for depolarizing noise, for both Protocols A and B.

The gate implementations proposed for the single-rail scheme can be readily extended to the dual-rail scheme. For example, we can use two additional internal quantum states |0 and |e of the emitter Q [cf. Fig. 10(a)]. Similar to the states |1 and |e , we assume that |0 and |e are stable and radiative, respectively. In particular, |e rapidly decays into |0 by emitting a photon or phonon into the waveguide. In general, the photons or phonons emitted from |e and |e are distinguishable by their internal modes. We denote these modes using two distinct annihilation operators, b 1 and b 0 .

Then, the realization of the X Q,i gate (more precisely, the preparation of the state X Q,i |ϕ Q |0 i for arbitrary |ϕ ) in the dual-rail scheme can be achieved via a sequence of resonant π pulses between the |0 ↔ |0 , |1 ↔ |e , and |0 ↔ |e transitions [cf. Fig. 10(b)]. First, a rapid resonant excitation |0 → |0 is applied, leading to the process

where |∅ i is the vacuum initial state of the ith temporal bin in the waveguide and |φ 0 rest and |φ 1 rest are unnormalized states of the rest of the system. Second, resonant excitation pulses are applied to both the |1 → |e and |0 → |e transitions, which is followed by the emission of a photon or phonon at the ith bin in b 1 or b 0 , depending on the internal state of the emitter. The state of the system after this emission is

Finally, another resonant π pulse is used to move the population from |0 to |0 . The net effect of these processes is the map

these operations achieve the desired effect.

The realization of the controlled-Z gate remains unmodified from Sec. V A 1. That is, Z Q,i can be implemented via a simple resonant photon or phonon scattering process, since a photon or phonon in the mode b 0 does not interact with the |0 or |1 states of the emitter.

# B. Implementation details

We now explain how to use the encoding schemes and elementary operations described in Sec. A to implement Protocols A and B. On top of being able to realize the required gates individually, we need to route the data qubits so that these gates are applied in the correct order. Moreover, for Protocol B, we require the ability to perform intermediate measurements on the emitter Q. We provide the details below.

For both protocols, we must control the ordering of the sequential interactions between Q and the photons or phonons representing the data qubits. This can be achieved by introducing time-delayed feedback. In the proposal of Ref. [25], a single delay line is used to generate a cluster state on a two-dimensional square lattice with shifted periodic boundary conditions. This procedure can be generalized to prepare the cluster state on the cubic lattice G c defined in Sec. 1, by introducing two delay lines of appropriate lengths to realize the circuit of line 1 of Protocol A (cf. Fig. 5).

Specifically, consider the setup illustrated in Fig. 3, which involves two routers and two delay lines. The routers are configured such that a propagating photon or phonon travels through each delay line only once before being measured at the output port. By setting the delay times for delay 1 and delay 2 to τ D1 = (3L -1)τ and τ D2 = [3L(M -1) -1]τ , respectively, where τ is the pulse-to-pulse time separation between distinct data qubit modes, one obtains a cluster state on an L × M × N cubic lattice G c . The multiplicative factor of 3 accounts for the fact that there are up to three interactions in every block [cf. Eq. ( 10)]. The delay times τ D1 and τ D2 can be effectively tuned using well-established techniques such as electromagnetically induced transparency [66] for coherent atomic media or band-structure engineering for photonic or phononic crystals [67]. Figure 11 shows the "circuit diagram" for L = 3, M = N = 2 implemented in a quantum photonic or acoustic system (compare to Fig. 5), in the single-rail encoding scheme. The data qubits are initialized in vacuum |∅ = |0 , and the X Q,i gates in Fig. 5 are implemented via selective photon or phonon emissions, represented by b † . The diagram for the dual-rail scheme is analogous, with the controlled-b † operations replaced by the process in Eq. (16).

Protocol B can be implemented in a similar way, with the following modifications. First, since the bcc lattice G bcc is a subgraph of the cubic lattice G c , a subset of the cubic lattice sites should not host data qubits. Second, one needs to perform projective measurements on the emitter Q, followed by reinitializations of Q in a predetermined state, e.g., |+ . The first task can be easily achieved by simply skipping the excitation pulses for the X Q,i gates at the appropriate times. The data qubits at the corresponding locations then remain in the vacuum state, decoupled from the rest of the system throughout the procedure.

The measurements of Q can be implemented via quantum nondemolition measurements. A practical challenge is that the time duration τ meas of the measurement and reinitialization process can be substantial, constraining the minimum separation τ > τ meas /3 between the temporal modes of consecutive data qubits. In turn, a longer τ implies that fewer data qubits can be stored in delay lines with nonnegligible loss rates. It may therefore be more practical to use Protocol A in some settings, to avoid intermediate measurements of Q altogether [68].

# VI. EFFECT OF DELAY LINE ERRORS

In the experimental proposals of Sec. V, the amount of time a photon or phonon spends in the delay lines grows with the size of the target cluster state (more precisely, with the cross-sectional area of the underlying bcc lattice). As a result, the cumulative effect of delay line errors may be non-negligible. If the cluster state size becomes too large, the total error incurred in the delay lines overwhelms the improved error-correction properties due to the increased code distance, leading to high logical error rates. In this section, we study two phenomenological models that incorporate the effect of delay line errors, and determine how the optimal logical error rate depends on the delay line error rate in each model. These models address the increase in loss probability with delay line length as well as dephasing errors on the data qubits, two effects that were ignored in Sec. IV.

# A. Analysis

The dominant sources of error in delay lines (for photons and phonons) are dephasing and loss, which we consider in Error Models 3a and 3b, defined below. We parametrize these models using the delay line error per time step.

Here, the time it takes to execute the block of gates in line 4 of Algorithm 1 constitutes one time step, and the time to measure and reset Q in lines 6 and 9 constitutes another time step. We assume that the time steps are equal [69]. In Protocol B, for instance, each time step consists either of a controlled-X gate, a Hadamard gate, and up to two controlled-Z gates, or of a measurement and reinitialization of Q. Thus, for preparing a cluster state on an L × M × N lattice, there are L time steps in delay 1 and L(M -1) time steps in delay 2 (cf. Figs. 3 and11). We use η Z and η loss to represent the dephasing error and loss per time step, respectively.

Let us make a brief comment on how these delay line errors change the analysis in Sec. IV. Dephasing errors are generally equivalent to stochastic Pauli-Z errors, while the effect of losing a qubit during the procedure depends on the encoding scheme and gate implementations. In the experimental setup described in Sec. V, the loss of a data qubit simply results in any subsequent gates involving that qubit not being applied. This is because these gates are realized via interactions between a photon or phonon wavepacket with the emitter. If the wavepacket is not present, the interaction does not occur. Moreover, in the dual-rail scheme of Sec. V A 2, losses are detectable. We can therefore use the decoder of Ref. [33] as we did in Sec. IV B.

For circuit errors, we use the same depolarizing noise model, Error Model 1, as in Sec. IV B, but with one modification. We omit the depolarizing channel that occurs after the initialization of each data qubit. This is motivated by the fact that in our experimental setup, each photon or phonon is created by the process that implements the controlled-X gate [cf. Eq. ( 16)]. Strictly, this differs from Algorithm 1 (as it is formally stated), in which a data qubit i is initialized first, before X Q,i is applied to it in a separate step. In order to be able to suppress error, the circuit error rate p should be below the threshold for this modified error model. Since the threshold for Error Model 1 was estimated to be p th = 0.39% (for Protocol B), we assume that p = 10 -3 , which is a standard number used in the literature for studying the subthreshold behavior of the surface code [11].

With the above considerations in mind, we define Error Models 3a and 3b as follows. We fix p = 10 -3 . In both models, every single-qubit gate on a qubit a is followed by a single-qubit depolarizing channel D (p)  a [cf. Eq. ( 13)]. Every measurement of a qubit a is preceded by D (p)  a , and every (re)initialization of Q is followed by D (p)  Q . Similarly, every two-qubit gate on qubits a and b is followed by a two-qubit depolarizing channel D (p)  a,b [cf. Eq. ( 14)]. In Error

11. Explicit implementation of the circuit of Protocol A for L = M = 3 in a quantum nanophotonic or acoustic system (compare to Fig. 5). The quantum emitter Q sequentially creates and interacts with the data qubits, whose states in the single-rail scheme are encoded by the absence or presence of a photon or phonon in a guided, propagating mode. The generalization of this procedure to the dual-rail scheme is straightforward. As detailed in Sec. A, the X Q,i gates in Fig. 5 can be implemented via selective photon or phonon emission, while the Z Q,i gates can be realized via resonant scattering. The colors correspond to those in Fig. 3, indicating which delay lines the photons or phonons are propagating through in the setup therein.

Model 3a, in addition to these circuit errors, a dephasing channel

is applied to every data qubit in each time step. In Error Model 3b, each data qubit is lost by the end of the procedure with probability 1exp(-η loss ), where is the total number of time steps the qubit spends in the delay lines. If a qubit i is lost at some point then any subsequent operation on i is replaced by the identity operator followed by D (p) i . In the following discussion, we often refer to the delay line error rate as η, where η is η Z for Error Model 3a and η loss for Error Model 3b [70].

For each of these error models, we estimate the logical error rate p for generating a cluster state on an L × L × L bcc lattice (storing one logical qubit) using Protocol B for various values of L and η. As in Sec. IV B, we infer the effect that each physical error has on the final state using Table II and Eq. ( 9), and we use the generalized MWPM decoder of Ref. [33] (without accounting for degeneracies) in our simulations. The results are shown in Fig. 12. Each data point is an average of at least 10 6 independent instances and at least 10 4 logical errors.

For an L × L × L bcc lattice, the total number of delay line time steps is L 2 . Hence, as we increase L for a fixed delay line error rate η, there is a trade-off between the better error suppression due to a larger code distance, given by d = (L + 1)/2, and the larger cumulative delay line error. Therefore, for each η, there is an optimal value L * of L that minimizes the logical error rate p. We find the minimum logical error rate, which we denote by p * , by increasing L until p starts to increase.

While we do not have an analytic expression for L * , we can make an educated guess as to the scaling of p * as a function of η. Since the circuit error rate p = 10 -3 in our models is well below threshold, there should be a threshold p delay,th for the cumulative delay line error below which the logical error rate p decays exponentially with L. For small η, the cumulative error is ηL 2 to leading order, so p decays exponentially with L for ηL 2 p delay,th . In particular, provided that ηL 2 * p delay,th , which can be achieved by L * = c(p delay,th /η) 1/2 for some constant c, we expect p * to roughly scale as

where c and c are constants. Numerically, we observe excellent agreement with Eq. ( 17), as can be seen from Fig. 13. Fitting Eq. ( 17) to the data gives the following estimates for c and c :

From Eqs. (18), we can determine the "break-even point" beyond which it is advantageous to use the delay lines. That is, since the depolarizing noise rate is assumed to be p = 10 -3 , using the experimental setup of Sec. V would make sense only when the logical error rate p is below this value. If the delay line error is dominated by dephasing, the break-even point occurs at η Z = 6.5 × 10 -5 . If the delay line error is dominated by loss, the break-even point occurs at η loss = 7.4 × 10 -4 .

As discussed in the following subsection, current experimental estimates for delay line error rates are not below this break-even point. However, the above results show that small reductions in these error rates can lead to very large reductions in the logical error rate. As an example, consider Error Model 3b, in which delay line errors are dominated by qubit loss. For circuit error rates as high as 10 -3 , Eqs. ( 17) and (18) give logical error rates p * = 10 -5 , 10 -10 , 10 -15 for η loss ≈ 1.4 × 10 -4 , 2.4 × 10 -5 , 9.5 × 10 -6 , respectively. Assuming that L * ∝ η -1/2 loss as above, the values of L required can be estimated to be L * ≈ 30, 75, 115, respectively. Thus, even if the circuit error rate is relatively high, with continued improvements in the error rates and storage capacities of delay lines, extremely low logical error rates can potentially be achieved using our protocol.

# B. Experimental prospects

We believe that three different experimental platforms are particularly appealing for our purposes: (1) a system of optical photons in a waveguide coupled to an atom or an artificial atom, (2) an integrated superconducting circuit in which single microwave photons can be deterministically generated via a superconducting qubit, (3) a quantum acoustic system based on fabricated nanostructures coupled to a nonlinear quantum emitter, e.g., a transmon qubit piezoelectrically coupled to a phononic waveguide.

In the optical domain, commercially available optical fibers can provide excellent delay times, in principle allowing for an extremely large number of photons in the delay lines. For instance, Tamura et al. reported a loss rate of 1.4 × 10 -4 dB/m [28]. Assuming that a single time step lasts 50 ns, we obtain a loss rate of 1.4 × 10 -3 dB per time step, which amounts to η loss ≈ 9.6 × 10 -4 . This is close to the break-even point 7.4 × 10 -4 estimated above.

However, weak coupling strengths between a quantum emitter and relevant photon modes can be a limitation of this approach. In particular, the cooperativity C is the ratio between the probabilities that Q emits a photon into a guided mode versus into unwanted modes. In order to obtain logical error suppression, C needs to be sufficiently large, such that the total loss probability is below the loss thresholds found in Sec. B. Achieving a high cooperativity, e.g., C 100, is one of the major experimental challenges in the field and is yet to be accomplished. Reducing photon loss at the interfaces of different optical elements and improving the qubit coherence time (in the case of quantum dots) would be another challenge.

In microwave photonics with integrated superconducting circuits, a significantly higher cooperativity C ≈ 172 has been achieved [71]. In fact, more recently, coherent interactions between a quantum emitter and a single timedelayed photon that has propagated through a waveguide have been demonstrated experimentally [72]. In Ref. [72], an array of microwave resonators is used to realize a onedimensional waveguide with delay time τ ≈ 227 ns. The waveguide is coupled to a qubit with photon emission rate 1D ≈ 2π × 21 MHz. This capability implies that around τ 1D ≈ 30 propagating photons can be stored inside the waveguide. We believe that, with further improvements, integrated superconducting circuits can potentially provide a proof-of-principle demonstration of our protocols in the near future.

Finally, quantum acoustic systems with phononic crystals are also rapidly emerging as a promising platform for our scheme. A single-mode phononic waveguide [29] and an extremely long phonon lifetime (T 1 ≈ 1.5 s and T 2 0.3 ms) [64] have already been demonstrated in two separate experiments. Assuming that a strong coupling regime with a high cooperativity can be achieved by fabricating integrated nanostructures (similar to superconducting circuits [71]), we expect that quantum acoustic systems can realize our protocols for reasonably large system sizes in the near future. For example, with optimistic but reasonable estimates T 2 ≈ 1 ms and γ ≈ 100 MHz, where γ is the coupling strength, one can choose a pulse-to-pulse time separation τ ≈ 160 ns to realize high-fidelity gates with error rates below our threshold of p th ≈ 0.39%. [Here, we assumed that the gate fidelity scales as 1 -1/(τ γ ) 2 based on symmetric wavepackets of phonons [25].] This choice [73] of τ would lead to a delay line error rate per time step of η Z ≈ 3τ/T 2 ≈ 4.8 × 10 -4 . Although this is above the break-even point 6.5 × 10 -5 , we note that the experimental technology for quantum acoustic systems is in its early stages and advancing rapidly. Through improving fabrication methods for integrated circuits and lowering the temperature, the coherence times of both qubits and a delay lines may be substantially increased.

# VII. DISCUSSION

In this paper, we proposed a method for preparing the well-known three-dimensional cluster state of Ref. [14] using a simple experimental setup. The main advantage of our proposal is that it has low component overhead, meaning that we only need a handful of experimental components to build a well-protected logical qubit. In contrast, standard protocols based on three-dimensional cluster states or the surface code [11,20,21,32,74] are expected to require hundreds if not thousands of experimental components.

If memory errors are non-negligible, our protocols do not have finite thresholds for the circuit error rate. Nevertheless, the logical error rate can be made exponentially small in η -1/2 , where η represents the memory error rate. Although our estimates suggest that the error rates that have been attained experimentally are not yet small enough, the low component overhead of our approach means that improvements in only a few physical components can lead to extremely large reductions in the logical error rate.

While the most mature approaches to quantum computation have high component overhead, ours is not the first proposal aiming to reduce component overhead. For example, the promise of anyon-based quantum computation in topological materials [35,41,43] is that natural physical interactions would greatly reduce the component overhead. Likewise, the reader may wonder how our scheme fares in comparison to those based on the Gottesman-Kitaev-Preskill (GKP) code [75]. This quantum error-correcting code for a qubit in an oscillator was recently used to demonstrate error suppression [76] by coupling cavity modes that form a GKP code to a transmon. For the protocol used, the logical error rate is determined by (i) a number that decays exponentially with σ -2 , where σ is the standard deviation of the Gaussian displacement channel [77] modeling the dominant source of error on the modes, and (ii) the transmon error rate p. The dominant source of error in Ref. [76] limiting the logical error rate is (ii), leading to a logical error rate that is significantly higher than what (i) might naïvely suggest. The contribution from (ii) can be reduced to O(p 2 ) by using a recently proposed faulttolerant method for preparing GKP states [78], in which case we expect the logical error rate to be limited by O(p 2 ).

In contrast, in an analogous setting, the logical error rate of our protocols decays exponentially with η -1/2 , even if the transmon error rate is significantly higher. Specifically, it suffices for the transmon error rate to be lower than some threshold value, which we have estimated to be 0.39% in the standard depolarizing noise model for circuit errors. Therefore, while approaches based on the GKP code may seem advantageous at the moment, with improved gate fidelities our scheme may be able to outperform them in the future.

From a more theoretical perspective, our protocols have a remarkable fault-tolerance property. Even though there is one physical qubit that interacts with every other qubit during the preparation of the cluster state, the procedure is nonetheless fault-tolerant because any single-qubit circuitlevel error results in a constant-weight error on the final state. What is interesting about this phenomenon is that the propagated error may actually be highly nonlocal, yet its effect on the specific state we wish to prepare is always the same as that of a geometrically local error. Similarly, the effect of any m-qubit circuit-level error on the final state is equivalent to that of at most m geometrically local errors. In fact, this applies not only to our protocols (Protocols A and B) for preparing the specific cluster state of Ref. [14], but to our general algorithm (Algorithm 1), which can be used to prepare the cluster state corresponding to any graph. (For general cluster states, geometric locality is defined with respect to the underlying graph; see Appendix C.)

By leveraging this fact, we were able to construct faulttolerant quantum circuits whose depth necessarily scales with the total number of qubits. This is certainly unusual. Fault-tolerant quantum computing protocols usually avoid circuits structured like ours because of the danger that they will spread errors too widely. This often restricts the design of these protocols, leading them to rely on a small number of trusted and manifestly fault-tolerant building blocks, such as transversal gates or "catch-and-correct" [79]. Our work shows that there can be a subtle form of fault tolerance in which physical errors spread but without adverse effects. This observation may prove useful for generalizing our methods to other fault-tolerance schemes. Indeed, Algorithm 1 can immediately be used to generate cluster states obtained by foliating arbitrary stabilizer codes [34,80,81].

There are several directions for improvement to explore. For one, the decoder we used in our simulations was the most basic MWPM decoder, which did not take into account matching degeneracies nor the anisotropy of the underlying error model. Decoders that exploit additional information may well obtain better logical error rates and thresholds. Also, there has been a recent flurry of work on using so-called flag techniques to make error-correction schemes more efficient [79,[82][83][84]. It would be interesting to investigate whether these techniques could be used to improve our protocols as well. More generally, it could be advantageous to trade a slowly growing component overhead for improved error tolerance. For instance, one could adapt our protocols to build cluster states on an L × L × N lattice using O(L) emitters instead of the single emitter we studied here. Such a scheme would still have component overhead parametrically smaller than the O(L 2 ) physical qubits live in the system. An analogous trade-off was found in Ref. [85] between the number of emitters and the entanglement generation rate in the context of quantum communication using cluster states [86,87]. Another strategy would be to concatenate our scheme, replacing our bare single-or dual-rail qubits with qubits protected by error correction, using, e.g., GKP [75] or binomial codes [88]. Conversely, our scheme could be used as the inner code, choosing a small value of L to make the logical error rate sufficiently small, e.g., 10 -5 . We can then concatenate this with a lower-overhead outer code, which may have a low pseudothreshold. All of these possibilities are left for future work.

Lastly, we note that we focused on the problem of storing a single logical qubit using a small number of experimental components. A natural future direction is to determine how best to perform logical computation using our architecture. A straightforward approach would be to create n logical qubits using n emitters, and implement logical gates between them using lattice surgery techniques [30]. We leave the detailed analysis of such a scheme, as well as the exploration of potentially lower-overhead protocols for fault-tolerant computation, to followup work.  1). In Appendix 1, we prove that, for any k ∈

where Observe that if, for a given j , (j -1, j ) is an edge (line 4 of Algorithm 2) then

so we do not apply Z Q,j -1 at all (instead of applying it twice in succession). Algorithm 2 correctly prepares |ψ G for any ordering of the qubits, which is implicitly chosen by labeling the vertices in V from 1 to n. The proof of correctness is given in Appendix B 1.

# Correctness of Algorithm 2

The correctness of Algorithm 2 follows immediately from Eq. (A1), which we prove. For any graph G, 1) and ( 4)],

First, we prove by induction that

where

Here, SWAP a,b denotes SWAP gate between a and b. For the base case

since G [1] contains the edge {Q, 1}. Assume that Eq. holds for k -1. Then,

where the third equality uses the identity SWAP Q,k Z Q,l = Z k,l SWAP Q,k for l = k, and the fourth equality follows from the fact that

Next, we observe from Eqs. (B3) and (B2) that, for every j ∈ [n], when SWAP Q,j is applied to Q and j , the qubit j is in the fixed initial state |+ . This implies that we do not need to implement a SWAP gate that works correctly on arbitrary states. We can instead use an operation that has the same effect when one of the qubits is in the state |+ [90]. In particular, we use the identity

for any arbitrary state |ϕ of Q (potentially entangled with other qubits). follows

and the fact that the state prepared in the dashed box is invariant under the SWAP gate for any |ϕ . Substituting Eq. (B4) into Eq. (B2), we arrive at Eq. (A1), which forms the basis for Algorithm 2.

# Correctness of Algorithm 1

To prove the correctness of Algorithm 1, we show by induction that, for every k ∈ [n], after line 4 in the kth iteration of the for loop has been executed, the state of Q and the first k data qubits is |ψ G[k] [cf. Eq. (B1)].

For the base case k = 1, E [1] = ∅, so in line 4, H Q X Q,1 is applied to Q and qubit 1, which are in their initial states |+ and |0 , respectively. By Eq. (A1) with k = 1, this yields the state

For the inductive step, there are two cases to consider,

For both cases, it will be useful to observe from Eq. (A1) that for any 1

Also note from the definition of E[j ] in Eq. ( 3) that the controlled-Z gates applied in line 4 can be equivalently written as

In the first case (k -1, k) ∈ E, lines 5-9 in the (k -1)th iteration are skipped, so by the inductive hypothesis, the state at the start of the kth iteration is |ψ G[k-1] . Then, lines 3 and 4 in the kth iteration produce the state

This follows from Eq. (B5), noting that Eq. (A2) holds since (k -1, k) ∈ E.

In the second case (k -1, k) ∈ E, the if condition of line 5 is satisfied and Q is measured in the Z basis. By the inductive hypothesis, Q and the first k -1 data qubits are in the state |ψ G[k-1] immediately before this measurement. By Eqs. ( 2) and ( 4), the stabilizers of |ψ G

Hence, the stabilizer generators of postmeasurement state of the first k -1 data qubits are

Here, the + sign corresponds to the postmeasurement state of Q being |0 , and thesign to |1 . If the outcome is |1 , line 8 applies Z k-1 , which negates S k-1 and leaves the other stabilizer generators unchanged. Thus, the state of Q (which is reinitialized in |+ by line 9) and the first k -1 data qubits at the end of the (k -1)th iteration is the cluster state

Applying lines 3 and 4 in the kth iteration then leads to the state

by Eq. (B5 

# APPENDIX C: ERROR ANALYSIS FOR ARBITRARY GRAPHS

In this appendix, we analyze how errors propagate through Algorithms 1 and 2, both of which can be used to prepare cluster states |ψ G defined by arbitrary graphs G = (V, E). We show that, for any G, any single-qubit error occurring during either algorithm results in an effective error [cf. Eq. ( 8)] whose weight scales with the maximum degree of G. For Algorithm 1 and for certain instances of Algorithm 1, the effective error resulting from a singlequbit error is always geometrically local, meaning that it is supported on some subset of {i} ∪ N (i) for some qubit i ∈ V, where

A crucial feature of both algorithms-and one of the main intuitions behind the proof below-is that at any point in the procedure, the ancilla qubit Q is entangled with a restricted number of data qubits (depending on the maximum degree of G). Moreover, all or almost all of the qubits with which Q is entangled at a given point are close to each other in G. As a result, even though Q interacts at least once with every data qubit in V, most (and in some cases, all) of the errors that could occur on Q lead to effective errors on the final state that are localized to neighborhoods of G.

# Error analysis for Algorithm 1

In this subsection, we prove that, for any input graph, single-qubit errors occurring during Algorithm 1 induce geometrically local effective errors. Claim 1.-Consider an arbitrary graph G = (V, E), and choose any ordering of the qubits in Algorithm 1 by labeling the vertices in V from 1 to n. Then, any singlequbit error occurring between the elementary operations in Algorithm 1 results in an effective error [cf. Eq. ( 8)] that is supported on some (possibly empty) subset of {i} ∪ N (i) for some i ∈ [n].

Proof. For each j ∈ [n], let

denote the block of gates applied in the j th iteration of the for loop in Algorithm 1 (line 4). We consider the effect of all possible X and Z errors that could occur during Algorithm 1. [The support of arbitrary errors can then be deduced using Eq. ( 9).] Spatially, these errors may inflict the ancilla Q or one of the data qubits 1, . . . , n, and temporally, they may occur between two blocks B j and B j +1

[92], before the first block B 1 , after the last block B n , or between two elementary gates in the same block. We do not consider where the errors occur relative to the Z j corrections that may be applied for certain j (line 8), as a Pauli error P immediately before Z j is equivalent to P immediately after Z j up to a sign. Z i errors. Suppose that a Z error occurs on a data qubit i ∈ [n]. Clearly, Z i commutes with every operation in Algorithm 1 except for the X Q,i gate in B i . This X Q,i gate is the first gate that acts on qubit i, which is initially in the state |0 . Therefore, if the Z i error occurs somewhere before the X Q,i , it has no effect, whereas if it occurs after the X Q,i , it is equivalent to a Z i error on the final state.

X Q errors. We first show that an X Q error occurring immediately after B k results in an effective error Z k on the final state, in the sense of Eq. ( 8). This is a consequence of the fact (proven in Appendix 2) that immediately after B k has been applied, Q and the first k data qubits are in the cluster state |ψ G[k] (and the rest of the qubits are still in their initial state, |0 ⊗n-k ). Recall from Eq. ( 4

Hence, an X Q error immediately after B k is equivalent to a Z k error immediately after B k , and we know from above that the latter results in a Z k error on the final state.

Trivially, an X Q error occurring at the beginning of the circuit, i.e., before B 1 , has no effect since the initial state |+ of Q is stabilized by X . The same goes for X Q errors that occur immediately after the reinitialization of Q (to |+ ) in the iterations where Q is measured.

It remains to consider X Q errors that occur between two consecutive gates in the same block B k . Suppose that an X Q error occurs somewhere in B k before the X Q,k gate. At this point, the first k -1 iterations of the for loop have been performed, followed by some subset of the controlled-Z gates in B k . To be precise, let J denote the subset of qubits j for which Z Q,j is in B k and is located before the X Q error. From Eq. (C2), we have [93]

As shown in Appendix 2, the state of the first k -1 qubits at the end of the

The state of the first k -1 qubits at the point where the

. This state is a cluster state in which Q shares an edge with k -1 [cf. Eq. ( 4)] and with every j ∈ J , and is therefore stabilized by X Q Z k-1 j ∈J Z j . It follows that the X Q error is equivalent to Z k-1 j ∈J Z j , which commutes with all subsequent operations in the circuit. The effective error on the final state is therefore Z k-1 j ∈J Z j . Similarly, in the case (k -1, k) ∈ E, the state at the point where the

. This is stabilized by X Q j ∈J Z j , so, by the same argument, the X Q error results in an effective error j ∈J Z j . The only other possibility is that an X Q error occurs after the X Q,k and before the H Q in B k . Since H a X a = Z a H a , this is equivalent to a Z Q error occurring after the H Q , i.e., immediately after B k . As shown directly below, such an error results in a Z k+1 error on the final state if (k, k + 1) ∈ E, and no error if (k, k + 1) ∈ E.

Z Q errors. The identities Z a,b Z a = Z a Z a,b and H a Z a = X a H a imply that a Z Q error occurring immediately before B k or within B k (i.e., between any two of the gates in B k ) is equivalent to an X Q error immediately after B k , which in turn results in a Z k error on the final state [cf. Eq. (C3)].

A Z Q error could also occur immediately after B k . If (k, k + 1) ∈ E, this is equivalent to a Z Q error immediately before B k+1 , and therefore results in a Z k+1 error on the final state. On the other hand, if (k, k + 1) ∈ E, Q is measured in the Z basis before B k+1 is applied. In this case, the Z Q error has no effect since it directly precedes a Z measurement.

X i errors. Finally, consider the effect of X i errors. The only gates in Algorithm 1 (besides the Z j corrections) with which X i does not commute are the Z Q,i . From Eq. (C2), we see that a Z Q,i gate appears in block B j for every j > i + 1 such that (i, j ) ∈ E. Hence, for each i ∈ [n], define the index set

so that B j includes a Z Q,i gate if and only if j ∈ I i . Suppose that an X i error occurs before B k (but after B k-1 ) for some k. It can be checked using the identities Z a,b X b = X b Z a Z a,b and H a X a = Z a H a that this is equivalent to an X i error at the end of the circuit, along with an X Q error immediately after each block B j for all j ∈ I i such that j ≥ k. As proven above, X Q immediately after B j results in an effective error Z j on the final state. Therefore, it follows from Eq. ( 9) that an X i occurring immediately after B k results in an effective error X i j ∈I i :j ≥k Z j on the final state, up to a sign.

These results are summarized in Table III. Note that the effect of any circuit-level Z error is at worst a single-qubit Z error, while the effective error resulting from any X error is (equivalent under stabilizers to) a product of Z errors supported within N (i). It can be verified using Table III that X and Z errors occurring at the same spacetime location in the circuit result in effective errors supported within {i} ∪ N (i) for the same i. This implies via Eq. ( 9) that any TABLE III. A complete list of X and Z errors that could occur during Algorithm 1 [applied to an arbitrary graph G = (V, E)] and their effect on the final state [cf. Eq. ( 8)], up to a sign. The notation B j is defined in Eq. (C2). Note from Eqs. (C4) and (C5) that, for each B k , J is always a subset of N (k) and that, for all i ∈ [n], I i ⊂ N (i).

# Circuit-level error

Location in circuit Effective error on final state  

single-qubit error at that location leads to an effective error supported within {i} ∪ N (i), as claimed.

Tables I and II, which are used in our simulations in Secs. B and A, are both special cases of Table III. Specifically, Table III reduces to Table I (which corresponds to the first step of Protocol A) for G = G c and B j = A j [cf. Eq. (10)], and to Table II (which corresponds to Protocol B) for G = G bcc and B j = B j [cf. Eq. (11)].

We remark that unlike Algorithm 1, not all cluster state preparation circuits have the property that any single-qubit circuit-level error results in a geometrically local effective error. For instance, Algorithm 2 can likewise be used to generate |ψ G for any graph G = (V, E). However, as discussed in the following subsection, there exist single-qubit errors in Algorithm 2 that lead to nonlocal effective errors [94] unless the n qubits are ordered such that (i, i + 1) ∈ E for every i ∈ [n -1]. It follows that, for any graph that does not contain a Hamiltonian path, Algorithm 2 does not yield-for any possible ordering of the qubits-a preparation circuit for which the effective errors are all geometrically local. As another example, certain singlequbit errors occurring in the circuit given by Eq. 2 of Ref. [25], which prepares a two-dimensional cluster state, would lead to nonlocal errors. This results from the inclusion of several redundant controlled-Z gates. (It should be noted, however, that the experimental protocol proposed in Ref. [25] does not actually apply these redundant gates.) More generally, by adding redundant controlled-Z gates, it is in fact possible to construct circuits in which certain single-qubit errors induce effective errors whose weights necessarily scale with the number of qubits.

# Error analysis for Algorithm 2

A similar result holds for Algorithm 2. However, in contrast to Algorithm 1, the effective errors resulting from single-qubit errors occurring during Algorithm 2 are not all geometrically local for every instance. Claim 2.-Consider an arbitrary graph G = (V, E), and choose any ordering of the qubits in Algorithm 2 by labeling the vertices in V from 1 to n. Then, any single-qubit error occurring between the elementary gates in Algorithm 2 results in an effective error [cf. Eq. (8)] that is supported on some (possibly empty) subset of {i} ∪ N (i) ∪ {i ± 1} for some i ∈ [n].

Specifically, Table IV gives the effect of all possible single-qubit X and Z errors that could occur during Algorithm 2. In this table, B j is used to denote the j th block of gates applied in Algorithm 2:

The proof of Claim 2 is essentially the same as that of Claim 1, requiring only the following modifications. First, there are no intermediate measurements of Q in Algorithm 2, so unlike for Algorithm 1 there is no need to consider errors occurring before a measurement or after a reinitialization of Q. Second, the index sets J and I i [cf. Eqs. (C4) and (C5)] considered in the proof of Claim 1 are slightly different for Claim 2. Specifically, I i should be replaced by its analogue I i , defined as I i := {j > i + 1 : (i, j ) ∈ E}, (i, i + 1) ∈ E, {i + 1} ∪ {j > i : (i, j ) ∈ E}, (i, i + 1) ∈ E, (C7) so that the gate block B j includes a Z Q,i gate if and only if j ∈ I i , as can be seen from Eq. (C6). [Note that in contrast to I i , which is always contained within the nearest neighbors N (i) of i, I i may contain i + 1 even if (i, i + 1) ∈ E.] Similarly, if J is a subset of the controlled-Z gates in B k , it follows from Eq. (C6) that

It can then be verified using Table IV [in conjunction with Eq. ( 9)] that any single-qubit error occurring in Algorithm 1 results in an effective error supported within {i} ∪ N (i) ∪ {i ± 1}. These effective errors are not geometrically local in general, as i -1 and i + 1 are not necessarily nearest neighbors of i.

It is worth noting, however, that the effective errors would always be geometrically local if (i, i + 1) ∈ E for all i ∈ [n -1]. This is possible if and only if (1) the underlying graph G of the target cluster state contains a Hamiltonian path, and (2) we use the ordering of the vertices along the Hamiltonian path as the ordering of qubits in Algorithm 2.

For instance, the cubic lattice G c prepared in Protocol A contains a Hamiltonian path, and the vertices are ordered in Eq. ( 5) such that (i, i + 1) is an edge for every i ∈ [n -1].

For G = G c , Algorithms 1 and 2 reduce to the exact same circuit when we use this ordering of the vertices, and Table I shows that all of the effective errors are indeed geometrically local. More generally, even if the graph G does not contain a Hamiltonian path, Claim 2 shows that every effective error has weight at most D(G) + 3, where D(G) is the maximum degree of G, regardless of the ordering of vertices that we choose.

# ACKNOWLEDGMENTS

We thank Agnetta Cleland, Sophia Economou, Kevin Multani, Marek Pechal, Hannes Pichler, Amir Safavi-Naeini, Alp Sipahigil, and Zhaoyou Wang for useful discussions. K.W. is supported by the Stanford Graduate Fellowship. S.C. acknowledges support from the Miller Institute for Basic Research in Science. I.K. is supported by the Simons Foundation It from Qubit Collaboration and by the Australian Research Council via the Centre of Excellence in Engineered Quantum Systems (EQUS) project number CE170100009. N.S. is supported by the National Science Foundation Graduate Research Fellowship under Grant No. DGE-1656518. acknowledges the support of 10.13039/100000181AFOSR (award FA9550-19-1-0369), CIFAR, and the Simons Foundation. Our implementation of the minimum-weight perfect matching decoder uses Blossom V [89].

# APPENDIX A: ALTERNATIVE ALGORITHM

In this appendix, we present an alternative algorithm, Algorithm 1, for preparing cluster states |ψ G [cf. Eq. ( 1)] on arbitrary graphs G. Algorithm 1 is similar in to Algorithm 1. The main difference is unlike Algorithm

# APPENDIX B: CORRECTNESS

In this appendix, we prove that Algorithms 1 and 2 correctly prepare cluster states |ψ G on arbitrary graphs G = (V, E). We begin with Algorithm 2.

[89] V. Kolmogorov, Blossom V: A new implementation of a minimum cost perfect matching algorithm, Math. Programming Comput. 1, 43 (2009).

[90] Of course, if the SWAP gate were experimentally available, this transformation would be unnecessary. We were primarily motivated to replace the gates in Eq. (B2) by ones that are more amenable to experimental implementation in the setup considered in Sec. V.

[91] In the context of quantum error correction, the notion of geometric locality often applies only to graphs that can be embedded into finite-dimensional space. The definition we use here extends to arbitrary graphs, including, e.g., expander graphs.

[92] Recall that if (j , j + 1) ∈ E, Q is also measured in the Z basis and reset to |+ (lines 6 and 9) in the j th iteration, between B j and B j +1 . In this case, we consider errors (on Q) both before the measurement (i.e., immediately after B j ) and after the reinitialization (i.e., immediately before B j +1 ).

[93] The qubits that are included in J depend on the location of the X Q error as well as on the order in which the controlled-Z gates in B k are actually applied (since they mutually commute, they can be applied in any order).

[94] More precisely (since multiple operators fit the definition of an effective error resulting from a particular circuit-level error [cf. Eq. ( 8)], none of the effective errors corresponding to these single-qubit circuit-level errors are geometrically local.

[95] D. Gottesman, 333 (2000), ArXiv:quant-ph/9903099. 

