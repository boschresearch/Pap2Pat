{
    "id": "US20180269906",
    "authors": [
        "Jeongwan Haah",
        "David Wecker",
        "Matthew Hastings",
        "David Poulin"
    ],
    "title": "MAGIC STATE DISTILLATION WITH LOW SPACE OVERHEAD AND ASYMPTOTIC INPUT COUNT",
    "date": "2017-06-19 00:00:00",
    "abstract": "Disclosed herein are example embodiments of protocols to distill magic states for T-gates. Particular examples have low space overhead and use an asymptotically optimal number of input magic states to achieve a given target error. The space overhead, defined as the ratio between the physical qubits to the number of output magic states, is asymptotically constant, while both the number of input magic states used per output state and the T-gate depth of the circuit scale linearly in the logarithm of the target error. Unlike other distillation protocols, examples of the disclosed protocol achieve this performance without concatenation and the input magic states are injected at various steps in the circuit rather than all at the start of the circuit. Embodiments of the protocol can be modified to distill magic states for other gates at the third level of the Clifford hierarchy, with the same asymptotic performance. Embodiments of the protocol rely on the construction of weakly self-dual Calderbank-Shor-Steane codes (\u201cCSS codes\u201d) with many logical qubits and large distance, allowing one to implement control-Swaps on multiple qubits. This code is referred to herein as the \u201cinner code\u201d. The control-Swaps are then used to measure properties of the magic state and detect errors, using another code that is referred to as the \u201couter code\u201d. Alternatively, one can use weakly-self dual CSS codes which implement controlled Hadamards for the inner code, reducing circuit depth. Several specific small examples of this protocol are disclosed herein.",
    "sections": [
        {
            "title": "DESCRIPTION",
            "paragraphs": [],
            "subsections": [
                {
                    "title": "FIELD",
                    "paragraphs": [
                        "This application relates generally to quantum computing. In particular, this application discloses example architectures for quantum circuits that perform magic state distillation protocols."
                    ],
                    "subsections": [],
                    "outline_long": [
                        "relate to quantum computing"
                    ],
                    "num_characters": 190,
                    "outline_medium": [
                        "relate to quantum computing"
                    ],
                    "outline_short": [
                        "relate to quantum computing"
                    ]
                },
                {
                    "title": "SUMMARY",
                    "paragraphs": [
                        "Disclosed herein are example embodiments of protocols to distill magic states for T-gates. Particular examples have low space overhead and use an asymptotically optimal number of input magic states to achieve a given target error. The space overhead, defined as the ratio between the physical qubits to the number of output magic states, is asymptotically constant, while both the number of input magic states used per output state and the T-gate depth of the circuit scale linearly in the logarithm of the target error. Unlike other distillation protocols, examples of the disclosed protocol achieve this performance without concatenation and the input magic states are injected at various steps in the circuit rather than all at the start of the circuit. Embodiments of the protocol can be modified to distill magic states for other gates at the third level of the Clifford hierarchy, with the same asymptotic performance. Embodiments of the protocol rely on the construction of weakly self-dual Calderbank-Shor-Steane codes (\u201cCSS codes\u201d) with many logical qubits and large distance, allowing one to implement control-Swaps on multiple qubits. This code is referred to herein as the \u201cinner code\u201d. The control-Swaps are then used to measure properties of the magic state and detect errors, using another code that is referred to as the \u201couter code\u201d. Alternatively, one can use weakly-self dual CSS codes which implement controlled Hadamards for the inner code, reducing circuit depth. Several specific small examples of this protocol are disclosed herein."
                    ],
                    "subsections": [],
                    "outline_long": [
                        "introduce magic state distillation protocols",
                        "summarize protocol performance",
                        "outline protocol embodiments"
                    ],
                    "num_characters": 1556,
                    "outline_medium": [
                        "summarize magic state distillation protocols"
                    ],
                    "outline_short": [
                        "summarize magic state distillation protocols"
                    ]
                },
                {
                    "title": "DETAILED DESCRIPTION",
                    "paragraphs": [],
                    "subsections": [
                        {
                            "title": "I. General Considerations",
                            "paragraphs": [
                                "Disclosed below are representative embodiments of methods, apparatus, and systems for magic state distillation in quantum computing devices, including quantum computing circuit architectures for performing such distillation.",
                                "Any of the disclosed example embodiments can be performed by a system comprising a classical processor and memory and/or at least in part by a quantum computing device (quantum computer) itself. The disclosed methods, apparatus, and systems should not be construed as limiting in any way. Instead, the present disclosure is directed toward all novel and nonobvious features and aspects of the various disclosed embodiments, alone or in various combinations and subcombinations with one another. Furthermore, any features or aspects of the disclosed embodiments can be used in various combinations and subcombinations with one another. For example, one or more method acts or features from one embodiment can be used with one or more method acts or features from another embodiment and vice versa. The disclosed methods, apparatus, and systems are not limited to any specific aspect or feature or combination thereof, nor do the disclosed embodiments require that any one or more specific advantages be present or problems be solved.",
                                "Although the operations of some of the disclosed methods are described in a particular, sequential order for convenient presentation, it should be understood that this manner of description encompasses rearrangement, unless a particular ordering is required by specific language set forth below. For example, operations described sequentially may in some cases be rearranged or performed concurrently. Further, some of the methods described herein can be altered by changing the ordering of the method acts described, by splitting, repeating, or omitting certain method acts, etc. Moreover, for the sake of simplicity, the attached figures may not show the various ways in which the disclosed methods can be used in conjunction with other methods. Additionally, the description sometimes uses terms like evaluate, \u201cdetermine\u201d, or \u201cchoose\u201d to describe the disclosed technology. Such terms are high-level abstractions of the actual operations that are performed. The actual operations that correspond to these terms may vary depending on the particular implementation and are readily discernible by one of ordinary skill in the art.",
                                "As used in this application and in the claims, the singular forms a, an, and the include the plural forms unless the context clearly dictates otherwise. Additionally, the term includes means comprises. Further, as used herein, the term and/or means any one item or combination of any items in the phrase."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce magic state distillation",
                                "describe system components",
                                "discuss method variations",
                                "clarify terminology",
                                "explain figure simplicity"
                            ],
                            "num_characters": 2696,
                            "outline_medium": [
                                "introduce patent scope",
                                "describe patent structure"
                            ],
                            "outline_short": [
                                "introduce patent scope and limitations"
                            ]
                        },
                        {
                            "title": "II. Introduction to Disclosed Technology",
                            "paragraphs": [
                                "Large scale quantum computers rely on fault-tolerant architectures, in which errors are corrected faster than they are created. The standard approach is to use stabilizer codes to protect logical qubits from noise, and perform quantum gates at the encoded level. The overhead of the fault-tolerance is only polynomial in the logarithm of the desired accuracy, but in practice the overhead is estimated to be overwhelmingly large.",
                                "Particularly expensive operations are non-Clifford gates such as the \u03c0/4-rotation (T-gate) and Toffoli gate. A compelling approach is to inject a special state, called a magic state, into a Clifford-only circuit, and pass the cost of implementing the non-Clifford operation to the preparation of the magic states, which are distilled from noisy ones.",
                                "There exist several distillation protocols for the magic state for T gate using specialized quantum error correcting codes. See, e.g., E. Knill, \u201cFault-tolerant postselected quantum computation: Schemes,\u201d (2004), quant-ph/0402171v1; Sergei Bravyi and Alexei Kitaev, \u201cUniversal quantum computation with ideal Clifford gates and noisy ancillas.\u201d Phys. Rev. A 71, 022316 (2005), quant-ph/0403025; Adam M. Meier, Bryan Eastin, and Emanuel Knill. \u201cMagic-state distillation with the four-qubit code,\u201d Quant. Inf. Comp. 13, 195 (2013), 1204.4221; Sergey Bravyi and Jeongwan Haah, \u201cMagic state distillation with low overhead,\u201d Phys. Rev. A 86, 052329 (2012), 1209.2426. Each code can provide a fixed degree of fidelity improvement that is given by the code distance. In order to achieve arbitrary good fidelity, one typically concatenates small routines. In terms of the number of input magic states of low fidelity per one output magic state of high fidelity, some protocols are those in Sergey Bravyi and Jeongwan Haah, \u201cMagic state distillation with low overhead,\u201d Phys. Rev. A 86, 052329 (2012), 1209.2426; and Cody Jones, \u201cMultilevel distillation of magic states for quantum computing,\u201d Phys. Rev. A 87, 042305 (2013), 1210.3388v2. However, these protocols require a large batch of thousands of magic states to be useful.",
                                "In this disclosure, a family of distillation protocols is disclosed (e.g., an infinite family). Example embodiments of the disclosed protocol produce n T-magic states using at most en qubits and achieve at least c\u2032n-th order error suppression under the assumption that the sole noise source is the T gate, where c, c\u2032 are small universal constants. Since the degree of error suppression is high, there is no need to concatenate small routines, reducing the space overhead significantly.",
                                "Example embodiments of the disclosed protocol are also asymptotically superior (conjectured to be optimal) in terms of noisy T count. For any fixed odd d\u22655, it is shown that the number of noisy T gate per one output magic state with error suppressed to d-th order converges to d exactly in the large code length limit.",
                                "Beyond the magic states for T gates, examples of the disclosed protocol can distill magic states for rotation by \u03c0/2k for k=3,4, . . . adapting the idea of Cuillaume Duclos-Cianci and David Poulin, \u201cReducing the quantum computing overhead with complex gate distillation,\u201d Phys. Rev. A 91, 042315 (2015), 1403.5280v1 and any gate in the third level of Clifford hierarchy (see Isaac L. Chuang and Daniel Gottesman, \u201cDemonstrating the viability of universal quantum computation using teleportation and single-qubit operations,\u201d Nature 402, 390393 (1999)) For the latter, the asymptotic performance is similar to the T gate case.",
                                "Small instances of the disclosed family appear to outperform any other previous protocols. If noisy \u03c0/4 rotations can be directly done on qubits, an instance of the disclosed family operates on 34 qubits including measurement ancillas, produces 15 T-magic states with 5th order error suppression, and requires 29 noisy T gates per output.",
                                "Recent innovations show that the \u03c0/4-rotation and Toffoli gate can be implemented transversally on a class of error correcting codes. See Adam Paetznick and Ben W. Reichardt. \u201cUniversal fault-tolerant quantum computation with only transversal gates and error correction,\u201d Phys. Rev. Lett. 111, 090505 (2013), 1304.3709; Sergey Bravyi and Andrew Cross, \u201cDoubled color codes,\u201d 1509.03239v1; Theodore J. Yoder, Ryuji Takagi. and Isaac L. Chuang, \u201cUniversal fault-tolerant gates on concatenated stabilizer codes,\u201d Physical Review X 6, 031039 (2016), 1603.03948. Transversal gates are inherently fault-tolerant, and hence this approach removes the need for magic states.",
                                "The organization of the remainder of the disclosure is as follows. In Section III, a basic explanation of the disclosed technology is given by exhibiting examples of small sizes. Section IV explains how to convert magic state distillation protocols for T gates into those for Toffoli gates. In section V, it is shown that any weakly self-dual CSS code can be used in distillation protocols by implementing measurement of Clifford operators. In section VI, asymptotic constructions of the codes are given, in the limit of either large distance or large code length. In section VII, results of numerical simulations are given; in this section, some specific additional small size protocols are disclosed that are not described elsewhere in the disclosure. Section IX provides some further discussion of the disclosed technology. In Section X, details are given, including stabilizer checks, for some of the specific codes used in this disclosure. Section XI gives circuits for some of the protocols used. Section XII describes unexpected relations among different, distillation protocols. Section XIII explains an extension to qudits using classification of symmetric forms over finite fields in Section XIV.",
                                "Throughout this disclosure, all classical codes that are considered will be linear codes over the binary field 2 and all quantum codes will be qubit stabilizer codes. Given a bit vector v, |v| is used to denote its Hamming weight. Our magic state is the",
                                "\\({{{{{{\\left( {+ 1} \\right)\ue89e\\text{-}\ue89e{eigenstate}}\ue85cH}\\rangle} = {{\\cos \ue89e\\mspace{11mu} \ue89e\\frac{\\pi}{8}\ue89e{\uf6030\\rangle}} + {\\sin \ue89e\\mspace{11mu} \ue89e\\frac{\\pi}{8}}}}\uf604}\ue89e1}\\rangle\\)",
                                "of the Hadamard operator H. The following matrices are used",
                                "\\(\\quad\\begin{matrix}\n\\begin{matrix}\n{{X = \\begin{pmatrix}\n0 & 1 \\\\\n1 & 0\n\\end{pmatrix}},} & {{Y = \\begin{pmatrix}\n0 & {- i} \\\\\ni & 0\n\\end{pmatrix}},} & {Z = {\\begin{pmatrix}\n1 & 0 \\\\\n0 & {- 1}\n\\end{pmatrix}.}}\n\\end{matrix} & \\left( {{II}\ue89e{.1}} \\right) \\\\\n\\begin{matrix}\n{{H = {\\frac{1}{\\sqrt{2}}\ue89e\\begin{pmatrix}\n1 & 1 \\\\\n1 & {- 1}\n\\end{pmatrix}}},} & {T = {e^{{- {i\\pi Y}}/8} = {\\begin{pmatrix}\n{\\cos \ue89e\\mspace{11mu} \ue89e\\frac{\\pi}{8}} & {{- \\sin}\ue89e\\mspace{11mu} \ue89e\\frac{\\pi}{8}} \\\\\n{\\sin \ue89e\\mspace{11mu} \ue89e\\frac{\\pi}{8}} & {\\cos \ue89e\\mspace{11mu} \ue89e\\frac{\\pi}{8}}\n\\end{pmatrix}.}}}\n\\end{matrix} & \\left( {{II}\ue89e{.2}} \\right)\n\\end{matrix}\\)",
                                "A self-orthogonal subspace of some vector space is a subspace such that the inner product of any two vectors in the subspace vanishes. A weakly self-dual CSS code is a quantum code whose stabilizer group is invariant under conjugation by the product of the Hadamard operator on all qubits; this is product is called a \u201ctransversal Hadamard\u201d."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "motivate quantum computing",
                                "describe fault-tolerant architectures",
                                "introduce magic states",
                                "discuss distillation protocols",
                                "summarize prior art",
                                "introduce disclosed protocol",
                                "describe error suppression",
                                "discuss asymptotic performance",
                                "introduce other gate applications",
                                "describe small instance performance",
                                "discuss transversal gate implementation",
                                "outline disclosure organization",
                                "define notation conventions",
                                "introduce Hadamard operator"
                            ],
                            "num_characters": 7211,
                            "outline_medium": [
                                "motivate magic state distillation",
                                "describe prior art",
                                "introduce disclosed technology",
                                "describe advantages",
                                "provide overview of disclosed protocols",
                                "discuss transversal gates",
                                "outline remaining sections"
                            ],
                            "outline_short": [
                                "motivate magic state distillation",
                                "summarize prior art",
                                "introduce disclosed technology"
                            ]
                        },
                        {
                            "title": "III. Basic Distillation Protocols",
                            "paragraphs": [
                                "Distillation protocols for magic states to date can be put roughly into two classes. Those in the first class implement a non-Clifford \u03c0/4-rotation to a stabilizer state such as |+ or |0. See Sergei Bravyi and Alexei Kitaev, \u201cUniversal quantum computation with ideal Clifford gates and noisy ancillas,\u201d Phys. Rev. A 71, 022316 (2005), quant-ph/0403025; Sergey Bravyi and Jeongwan Haah, \u201cMagic state distillation with low overhead,\u201d Phys. Rev. A 86, 052329 (2012), 1209.2426; Andrew J. Landahl and Chris Cesare, \u201cComplex instruction set computing architecture for performing accurate quantum Z rotations with less magic,\u201d (2013), 1302.3240. The non-Clifford rotation is desirably done fault-tolerantly, so the protocols in this class focus on finding error correcting codes that admits a transversal non-Clifford rotation. This requires the underlying code to have a special symmetry, which is rather rare. The protocols in the second class implement measurements of \u201cstabilizers\u201d of the magic state, based on the fact that a magic state in the third level of Clifford hierarchy is an eigenstate of a Clifford operator. See, e.g., E. Knill, \u201cFault-tolerant postselected quantum computation: Schemes,\u201d (2004), quant-ph/0402171v1; E. Knill. \u201cFault-tolerant postselected quantum computation: Threshold analysis,\u201d (2004), quantph/0404104v1; Adam M. Meier, Bryan Eastin, and Emanuel Knill, \u201cMagic-state distillation with the four-qubit code,\u201d Quant. Inf. Comp. 13, 195 (2013), 1204.4221; Cody Jones, \u201cMultilevel distillation of magic states for quantum computing,\u201d Phys. Rev. A 87, 042305 (2013), 1210.3388v2; Guillaume Duclos-Cianci and David Poulin, \u201cReducing the quantum computing overhead with complex gate distillation,\u201d Phys. Rev. A 91, 042315 (2015), 1403.5280v1; Earl T. Campbell and Joe O'Corman, \u201cAn efficient magic state approach to small angle rotations,\u201d Quantum Science and Technology 1, 015007 (2016), 1603.04230v2. To measure a Clifford operator, one can use a non-Clifford operation which has been implemented fault-tolerantly by a distance-two code.",
                                "The example schemes in this disclosure belong to the second class. There are two levels of error correcting codes in examples of the disclosed scheme, which are referred to as inner and outer codes.",
                                "Roughly speaking, the outer codes specify a certain set of measurements of Clifford operators on a set of input magic states, and the inner codes specify how to implement these measurements.",
                                "Aspects of the disclosed technology can be described by two examples. These examples are for illustration purposes only, as they involve a relatively small number of non-Clifford gates and states, but help illustrate certain principles of the disclosed technology. The disclosed technology is highly scalable and a more general class of protocols is presented in later sections.",
                                "Without loss of generality, by a standard Clifford twirling argument, one can assume that each r/4 rotation and undistilled magic state suffers from independent Y errors with probability E. This error model is referred to as the stochastic error model.",
                                "**A. Trivial Outer Code**",
                                "If one could implement the control-Hadamard, then the distillation is relatively straightforward: Prepare an ancilla qubit in |+ state, apply the control-Hadamard with the control on the ancilla and the Hadamard on an arbitrary target qubit, and measure the ancilla in X-basis to accept +1 outcome. The accepted target qubit is projected onto the magic state.",
                                "The control-Hadamard belongs to the third level of Clifford hierarchy, and thus cannot be implemented with Clifford operations. To obtain an approximate control-Hadamard with noisy non-Clifford rotations, one can use an error correcting code that can implement H on the logical qubits fault-tolerantly.\n\n\n- - 1. \\[\\[7,1,3\\]\\] Inner Code",
                                "To this end, observe that the Steane code admits a transversal Hadamard. See, e.g., A. M. Steane, \u201cError correcting codes in quantum theory,\u201d Physical Review Letters 77, 793797 (1996); E. Knill, \u201cFault-tolerant postselected quantum computation: Schemes,\u201d (2004), quant-ph/0402171v1. The stabilizers are",
                                "IIIXXXX IIZZZZ",
                                "IXXIIXX,IZZIIZZ,",
                                "XIXIXIX ZIZIZIZ\u2003\u2003(III.1)",
                                "the group generated by which is fixed under the H\u22977: Xi\u2194Zi, and the logical operator pair is",
                                "ZZZZZZZ XXXXXXX\u2003\u2003(III.2)",
                                "which are interchanged by the transversal Hadanmard. Using an identity",
                                "H=TZT\u2020=e\u2212\u03c0Y/8Zei\u03c0Y/8\u2003\u2003(III.3)",
                                "one can see that the logical control-Hadamard is possible by replacing the middle Z by the control-Z. The T gate can be noisy as they act on the physical qubits of the Steane code.",
                                "This way, a Hadamard measurement routine has been created that is fault-tolerant. Then, one example magic state distillation protocol is as follows:\n\n\n- 1. Prepare a noisy magic state in the \u201cdata\u201d register, and \\|0\n  in 6 check registers, and embed them into the Steane code\n- 2. Prepare an ancilla in \\|+\n  and implement control-H^(\u22977) using Eq. (III.3), where the control is\n  the ancilla and the targets are the physical qubits of the Steane\n  code.\n- 3. Inverse the embedding of the Steane code.\n- 4. Measure the ancilla in the X basis, the check qubits in the Z\n  basis.\n- 5. Upon +1 outcome in all 7 measurements, a distilled magic state is\n  in the data qubit.  \n  Now examine the pattern of errors that may go undetected. There are\n  two possibilities.\n  - The initial magic state is faulty, and this is undetected due to\n    malfunction of the control-Hadamard.\n  - The noisy \u03c0/4 rotations induce a logical error.  \n    The first possibility is because a pair of simultaneous errors\n    sandwiching the control-Z can alter the ancilla measurement:",
                                "|00|\u2297I+|11|\u2297e\u2212i\u03c0Y/8YZYei\u03c0Y/8=(Z\u2297I)(|00|\u2297I+|11|\u2297e\u2212i\u03c0/8Zei\u03c0Y/8).\u2003\u2003(III.4)",
                                "Thus, the first possibility occurs with probability \u22083 to leading order. One can easily see that this is the only possibility for weight 2 errors from the control-Hadamard to escape. The second possibility occurs at order e3 since Steane's code has distance 3.",
                                "It is useful to think of the above protocol as a Hadamard measurement (H-measurement) routine that introduces a new error of order \u22083 to the target, and another error of order \u22082 to the control. The error on the control is easy to fix; repeat the measurement. This corresponds to having redundant checks in the outer code. The error on the target is inherent to the choice of the inner quantum code, and should thus be overcome by another quantum code.\n\n\n- - 2. \\[\\[17,1,5\\]\\] Inner Code",
                                "There exists a distance 5 code on 17 qubits with H\u229717 being the logical Hadamard. It is an instance of the color code. H. Bombin and M. A. Martin-Delgado, \u201cTopological quantum distillation,\u201d Physical Review Letters 97, 180501 (2006), quant-ph/0605138; Sergey Bravyi and Andrew Cross, \u201cDoubled color codes,\u201d 1509.03239v1. The binary matrix for this code is included in Section X. In a similar way as above, this H-measurement routine has error rate O(\u22085) on the target, and O(\u22082) on the control. By repeating the H-measurement twice using this inner code, the control's error rate becomes O(\u22084). The control error goes undetected only if the initial magic state is faulty. Overall, only weight 5 errors may be undetected.",
                                "In fact, one can pipeline the two H-measurement routines: First, H-measure a noisy magic state using [[7,1,3]] code, and then H-measure the outcome using [[17,1,5]] code. (Interestingly, the protocol using Steane code, and the pipelined protocol appear to have deep relation with triply even codes. See Section XII.) Hence, a distillation routine has been obtained with fifth order error suppression that operates on 18 qubits in total. The circuit is in FIG. 7 in Section XI.",
                                "**B. Repetition Outer Code**",
                                "Imagine one has nouter noisy magic states that are to be distilled. Under the stochastic error model, one can think of the noisy magic states as an ensemble of nouter-bit strings where 0 denotes a good magic state, and 1 denotes a bad one. The protocol in the previous subsection examines one qubit at a time, and in terms of the bit strings, this amounts to checking individual bits. If the goal is to suppress the overall error to d-th order where d<nouter, the bit-wise check might be unnecessary. A better way is to devise a measurement routine that can check the parity of several bits.\n\n\n- - 1. \\[\\[4,2,2\\]\\] Inner Code",
                                "The simplest case is when nouter=2 and the desired error suppression is quadratic. If one can measure H\u22972, then by postselecting on +1 outcome the noisy state is projected to the even parity subspace, which is O(\u22082) away from the pair of perfect magic states. One can describe the situation by saying that one has a repetition code on nouter=2 bits with one parity check. This is an outer code.",
                                "A corresponding inner code should implement control-H\u22972 to accuracy O(\u22082), both in the target and the control. Meier, Eastin, and Knill have designed such a measurement routine. See Adam M. Meier, Bryan Eastin, and Emanuel Knill, \u201cMagic-state distillation with the four-qubit code,\u201d Quant. Inf. Comp. 13, 195 (2013), 1204.4221. The four qubit code [[4, 2,2]] whose stabilizers are X\u22974 and Z\u22974 admits the transversal Hadamard =H\u22974 as a logical operator. If one chooses the logical operators as",
                                "\\(\\begin{matrix}\n\\left\\{ {\\begin{matrix}\nX & X & I & I \\\\\nI & Z & Z & I\n\\end{matrix}\ue89e\\mspace{34mu} \ue89e\\left\\{ \\begin{matrix}\nZ & Z & I & I \\\\\nI & X & X & I\n\\end{matrix} \\right.} \\right. & \\left( {{III}\ue89e{.5}} \\right)\n\\end{matrix}\\)",
                                "then the transversal Hadamard swaps the two logical qubits. Using Eq. (III.3), this means that one can implement control-Swap to accuracy O(\u22082). Now, in one example embodiment, the control-Swap is used twice sandwiching the Hadamard:",
                                "[CSwap12]H1[CSwap12]=[C(H1\u2297H2)]H1\u2003\u2003(III.6)",
                                "where the superscript C denotes the control that is common for both control-Swaps, and the subscripts 1 and 2 denote the qubits the operator acts on. The extra H1 does no harm since the magic state is its eigenstate. The obtained control-H\u22972 is accurate up to error O(\u22082) on the target since the distance of the four-qubit code is 2, and also O(\u22082) on the control due to Eq. (III.4). (Meier, Eastin, and Knill compresses the circuit for the control-H\u22972. See Adam M. Meier, Bryan Eastin, and Emanuel Knill, \u201cMagic-state distillation with the four-qubit code,\u201d Quant. Inf. Comp. 13, 195 (2013), 1204.4221; see also Earl T. Campbell and Joe O'Corman, \u201cAn efficient magic state approach to small angle rotations,\u201d Quantum Science and Technology 1, 015007 (2016), 1603.04230v2.) This is a quadratic distillation protocol.\n\n\n- - 2. \\[\\[16,6,4\\]\\] Inner Code and Pipelining",
                                "The classical Hadamard code [16,5, 8] has a property that every code word has even overlap with any other code word. By the CSS construction, using these classical codewords as stabilizers, one obtains a [[16,6,4]] code; see section X A 2 for the stabilizers. It will later be shown that there is a choice of logical operators such that the transversal Hadamard H\u229716 implements simultaneous pairwise swaps on the three pairs of logical qubits. This implies that one can measure any even product. {tilde over (H)}\u22972, {tilde over (H)}\u22974, or {tilde over (H)}\u22976 of Hadamards on kinner=6 magic states. For example, one can generalize Eq. (III.6) to",
                                "[CSwap12][CSwap34]H1H3[CSwap12][CSwap34]=[C(H1\u2297H2\u2297H3\u2297H4)]H1H3.\u2003\u2003 (III.7)",
                                "The classical Hadamard code [16,5,8] has a property that every code word has even overlap with any other code word. By the CSS construction, using these classical codewords as stabilizers, one obtains a [[16,6,4]] code; see section X A 2 for the stabilizers. The H-measurement routine puts quadratic error to the control and quartic error to the target.",
                                "Imagine that nouter=6 magic states are laid on a ring. One can measure H\u22972 on every nearest neighboring pair of the magic states. There are six checks in total. The measurement pattern follows the parity checks of the classical repetition code; there is a redundancy in the checks, which turns out to be necessary. Now consider how this achieves quartic error suppression. In order for an error on one of nouter magic states to pass the measurement routines, the two checks that involve that input state must both be faulty. This process gives an O(\u22085) error, e.g., the probability of both checks being faulty is O(\u22084), so including the error on the input magic state the error is O(\u22085). Note that if one did not have a redundancy in the checks of the outer code, using only 5 checks, one qubit would be checked only once and one would achieve only third order error suppression. More generally, any process involving one or more input magic state errors gives an error which is at most O(\u22085). The dominant error after all the H-measurements is then from the logical error by the H-measurement routine, which happens with probability O(\u22084).",
                                "One can pipeline the [[4,2,2]] code routine in front of the [[16,6,4]] code routine to lower the complexity of the distillation circuit. For instance, one can run the three H-measurement routines by the [[4,2,2]] code on pairs of magic states (12), (34), and (56), and then run the three H-measurement routines by [[16,6,4]] code on pairs of magic states (23), (45), and (61). It is straightforward to show that the modified version also achieves quartic error suppression. The modified version has been simulated, and the results can be found in Section VII. The circuit is in FIG. 6 in Section XI."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce magic state distillation",
                                "classify distillation protocols",
                                "describe first class of protocols",
                                "describe second class of protocols",
                                "introduce example schemes",
                                "describe stochastic error model",
                                "introduce trivial outer code",
                                "describe [[7,1,3]] inner code",
                                "implement control-Hadamard",
                                "describe Hadamard measurement routine",
                                "analyze error patterns",
                                "introduce [[17,1,5]] inner code",
                                "describe H-measurement routine",
                                "pipeline H-measurement routines",
                                "introduce repetition outer code",
                                "describe [[4,2,2]] inner code",
                                "implement control-H\u22972",
                                "describe quadratic distillation protocol",
                                "introduce [[16,6,4]] inner code",
                                "describe H-measurement routine",
                                "pipeline H-measurement routines",
                                "analyze error suppression",
                                "describe modified distillation protocol",
                                "simulate modified protocol",
                                "describe circuit for modified protocol",
                                "conclude repetition outer code"
                            ],
                            "num_characters": 13406,
                            "outline_medium": [
                                "introduce two classes of distillation protocols",
                                "describe first class of protocols",
                                "describe second class of protocols",
                                "introduce example schemes",
                                "describe trivial outer code",
                                "introduce [[7,1,3]] inner code",
                                "describe Hadamard measurement routine",
                                "analyze error patterns",
                                "introduce [[17,1,5]] inner code",
                                "describe pipelined protocol",
                                "introduce repetition outer code",
                                "describe [[4,2,2]] inner code",
                                "describe quadratic distillation protocol"
                            ],
                            "outline_short": [
                                "introduce magic state distillation protocols",
                                "describe two classes of protocols",
                                "motivate trivial outer code",
                                "describe [[7,1,3]] inner code",
                                "describe [[17,1,5]] inner code",
                                "describe repetition outer code"
                            ]
                        },
                        {
                            "title": "IV. Third Level of Clifford Hierarchy",
                            "paragraphs": [
                                "The protocol above can be straightforwardly generalized to distilling other magic states to implement gates at, the third level of the Clifford hierarchy. Consider a state |\u03c8 on q qubits such that |\u03c8=U|\u03d5 where U is a gate at the third level of the Clifford hierarchy and |\u03d5 is a stabilizer state. See Isaac L. Chuang and Daniel Gottes man, \u201cDemonstrating the viability of universal quantum computation using teleportation and single-qubit operations,\u201d Nature 402, 390393 (1999). An example of such a state |\u03c8 is the magic state to produce a CCZ gate, which is equivalent to the Toffoli gate up to a Hadamard on the target. See Peter W. Shor, \u201cFault-tolerant quantum computation,\u201d in Foundations of Computer Science, 1996.",
                                "\\(\\begin{matrix}\n{{{\ue85c\\psi}\\rangle} = {\\underset{\\underset{U}{\uf613}}{{cc}_{Z}}\ue89e{\\left( \\underset{{\ue85c\\varphi}\\rangle}{\\underset{\uf613}{\\left( \\frac{{{{{\ue85c0}\\rangle} +}\ue85c1}\\rangle}{\\sqrt{2}} \\right)}} \\right)^{\\otimes 3}.}}} & \\left( {{IV}\ue89e{.1}} \\right)\n\\end{matrix}\\)",
                                "As |\u03c8 is a stabilizer state, one can identify q operators, S(1), S(2), . . . , S(q), which are products of Paulis, generating the stabilizer group of |\u03d5 so that |\u03d5 is the unique (up to global phase)+1 eigenstate of those operators. For the CCZ, one can see S(1)=X1, S(2)=X2, and S(3)=X3. Then, the state |\u03c8 is the unique +1 eigenstate of the operators",
                                "W(a)\u2261US(a)U\u2020, for a=1, . . . ,q.\u2003\u2003(IV.2)",
                                "These operators W(a) commute with each other by construction, and belong to the second level of the hierarchy, the Clifford group. For the CCZ, one can see W(1)=X1(CZ)23, W(2)=X2(CZ)13, and W(3)=X3(CZ)12.",
                                "Here is an example protocol for CCZ state distillation using three copies of the [[4,2,2]] code.",
                                "In this example, the three copies are regarded as a single [[12,6,2]] code and the logical qubits are indexed by 1, . . . , 6. One can encode one CCZ state stabilized by W(a) into logical qubits 1,3,5 and another stabilized by W\u2032(a) into 2,4,6 where a=1,2,3. Consider a variant of Eq. (III.6)",
                                "[C(Swap12Swap34Swap56)](W(a)135\u2297I246)[C(Swap12Swap34Swap56)]=[C(W(a)135\u2297W(a)246)](W(a)135\u2297I)\u2003\u2003(IV.3)",
                                "where the control qubit is common for every gate. The simultaneous control-Swaps are implemented by the control-H\u229712 on the [[12,6,2]] code, where the control-H\u229712 in turn is implemented by noisy T gates. Thus, one can obtain a measurement routine for W(a)\u2297W\u2032(a). (Since W(1), W(2), W(3) are the same up to permutations of qubits, the measurement routine can in fact measure any product W(a)\u2297W\u2032(b) for a, b=1, 2, 3 on the pair of CCZ states.)",
                                "Then the protocol is to measure W(1)W\u2032(1). W(2)W\u2032(2), and W(3)W\u2032(3).",
                                "By applying the Clifford stabilizers W uniformly at random to a noisy magic state for CCZ, it becomes a mixture of eigenstates of W's. Hence one may assume an error model where an error flips at least, one of W(1), W(2), W(3) with probability \u2208. Since the measurement routine puts measurement error at rate O(\u22082) and logical error at rate O(\u22082), the protocol achieves quadratic error reduction for CCZ state. For higher order reduction, one should use inner and outer code of higher distances.",
                                "A related discussion on error model for the T state is given in Section VII A.",
                                "In passing, it is noted that the Clifford unitary V123=(CZ2)(CX2)X2X3 on three qubits 1, 2, 3 is a stabilizer of the CCZ state",
                                "\\({{{{\ue85c{CCZ}}\\rangle} = {{\\frac{1}{\\sqrt{8}}\ue89e{\\sum\\limits_{a,b,{c = 0},1}\ue89e\\left( {- 1} \\right)^{abc}}}\ue85c{abc}}}\\rangle}.\\)",
                                "Since the CCZ state is permutation invariant, one can obtain six such stabilizers. They do not commute, but any triple of them uniquely determines the CCZ state. The controlled version can be implemented with only four T gates. See Bryan Eastin, \u201cDistilling one-qubit magic states into toffoli states,\u201d Phys. Rev. A 87, 032321 (2013), 1212.4872v2; see also Cody Jones, \u201cLow-overhead constructions for the fault-tolerant toffoli gate,\u201d Physical Review A 87, 022328 (2013), 1212.5069. CV123=T2(CZ2)T2(CZ2)T2\u2020(CZ2)T2\u2020(CX3). It might be possible to use these stabilizers with odd codes, but because they do not commute the resulting measurement routine rejects faulty inputs with a probability less than 1, even in the limit \u2208\u21920."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce third level of Clifford hierarchy",
                                "describe magic state for CCZ gate",
                                "identify stabilizer operators",
                                "define W operators",
                                "describe example protocol for CCZ state distillation",
                                "implement control-Swaps",
                                "analyze error model",
                                "conclude CCZ state distillation"
                            ],
                            "num_characters": 4140,
                            "outline_medium": [
                                "generalize protocol to distill other magic states",
                                "introduce CCZ state distillation protocol",
                                "describe measurement routine for W(a)\u2297W\u2032(a)",
                                "analyze error reduction"
                            ],
                            "outline_short": [
                                "generalize protocol to distill other magic states",
                                "describe example protocol for CCZ state distillation"
                            ]
                        },
                        {
                            "title": "V. Inner Codes",
                            "paragraphs": [
                                "In this section, a general class of inner codes is disclosed that can be used in any of the distillation protocols disclosed herein.",
                                "**A. Symmetric Forms Over 2**",
                                "Consider finite dimensional vector spaces over the binary field 2. The space 2n is equipped with a symmetric dot product v\u00b7w=\u03a3iviwi\u22082. This dot product on 2 is non-degenerate, e.g., for any nonzero vector v\u22082n, there is a vector w\u22082n such that v\u00b7w=1. Let S be a null (self-orthogonal) subspace of 2n, on which the dot product identically vanishes. Since S is null, the dot product of 2n canonically induces a dot product on the quotient space 2n/S by [v]\u00b7[w]:=v\u00b7w where [v] and [w] denote the equivalence classes (members of the quotient space) represented by v and w, respectively. Let S\u22a5 denote the orthogonal complement of S with respect to the dot product.",
                                "Lemma 1. The induced dot product on S\u22a5/S is non-degenerate.",
                                "**Proof.**",
                                "First, it is claimed that (S\u22a5)\u22a5=S. It is clear by definition that S\u2286(S\u22a5)\u22a5. Interpreting the orthogonal complement as the solution space of a system of linear equations, one sees that the claim holds by dimension counting. For [v]\u2208S\u22a5/S, if [v]\u00b7[w]=0 for any w, then v belongs to (S\u22a5)\u22a5=S, implying that [v]=0\u2208S\u22a5/S. \u25a1",
                                "For any basis {[v(i)], . . . , [v(k)]} of S\u22a5/S, consider the symmetric matrix \u039b representing the dot product:",
                                "\u039bab=v(a)\u00b7v(b).\u2003\u2003(V.1)",
                                "Lemma 1 is equivalent to saying that the matrix \u039b is non-singular. Any basis change of S\u22a5/S induces a congruent transformation \u039b\u2192MT\u039bM. One considers equivalence classes of A under the congruent transformations.\n\nLemma 2 (Classification of symmetric forms over 2). A non-degenerate symmetric form over 2 is equivalent to one of the two non-equivalent choices:",
                                "\\(\\begin{matrix}\n{{I_{n} = \\begin{pmatrix}\n1 & \\; & \\; \\\\\n\\; & \\ddots & \\; \\\\\n\\; & \\; & 1\n\\end{pmatrix}},\\mspace{14mu} \ue89e{\\lambda = {I_{n/2} \\otimes \\; \ue89e{\\begin{pmatrix}\n0 & 1 \\\\\n1 & 0\n\\end{pmatrix}.}}}} & \\left( {V\ue89e{.2}} \\right)\n\\end{matrix}\\)",
                                "**Proof:**",
                                "The two options are not equivalent since \u03bbn means that the every vector is self-orthogonal, whereas In implies that not every vector is self-orthogonal. For completeness, an elementary algorithmic proof is given by manipulating symmetric matrices.",
                                "First, it is claimed that any symmetric matrix can be brought to a direct sum of Ip and \u03bbq for some p\u22650 and q\u22650, where q is even. If there is a nonzero diagonal element one can bring this to the top-left by permutation. Gaussian elimination on the first column and row reveals that I1 is a direct summand. Induction gives a direct summand Ip, and one is left with a symmetric matrix \u039b\u2032 with the zero diagonal. Any column cannot be zero since \u039b\u2032 is non-singular, and thus some permutation brings 1 to (2, 1) and (1, 2) entries of \u039b\u2032. Gaussian elimination on the first and second columns and rows reveals a direct summand \u03bb2. By induction, the first claim is proved.",
                                "The second claim is that Ip+2\u2295\u03bbq\u22122\u2245Ip\u2295\u03bbq whenever p, q>0, whose proof is immediate:",
                                "\\(\\begin{matrix}\n{{\\begin{pmatrix}\n1 & 1 & 1 \\\\\n1 & 1 & 0 \\\\\n1 & 0 & 1\n\\end{pmatrix}\ue89e\\begin{pmatrix}\n1 & \\; & \\; \\\\\n\\; & 1 & \\; \\\\\n\\; & \\; & 1\n\\end{pmatrix}\ue89e\\begin{pmatrix}\n1 & 1 & 1 \\\\\n1 & 1 & 0 \\\\\n1 & 0 & 1\n\\end{pmatrix}} = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 0 & 1 \\\\\n0 & 1 & 0\n\\end{pmatrix}} & \\left( {V\ue89e{.3}} \\right)\n\\end{matrix}\\)",
                                "Therefore, whenever p>0, one has Ip, \u03bbq\u2248Ip+q. If p=0, there is nothing more to prove. \u25a1",
                                "The classification motivates the following notion of bases.",
                                "**Definition 1.**",
                                "Given a null subspace S\u22862n, a basis of S\u22a5/S is called (p,q)-magic if the symmetric matrix \u039b representing the dot product on S\u22a5/S among the basis vectors is equal to Ip\u2295\u03bbq for some p\u22650 and q\u22650. A magic basis odd exists if p>0, or even if p=0.",
                                "One can summarize the results of this section into a theorem.",
                                "**Theorem 1.**",
                                "For any self-orthogonal subspace S\u22862n, there exists a (p,q)-magic basis for S\u22a5/S, where p+q=S\u22a5/S. If p>0 and q>0, then a (p+2, q\u22122)-magic basis exists.",
                                "**B. CSS Codes from Self-Orthogonal Matrices**",
                                "It is standard to associate a bit string v=(v1, . . . , vn) to a Pauli operator: X(v)=X1v. . . Xnvwhere Xj is the Pauli \u03c3x on qubit j, and Z(v)=Z1v. . . Znvwhere Zj is the Pauli \u03c3z on qubit j. The commutation relation is that",
                                "X(v)Z(w)=(\u22121)v\u00b7wZ(w)X(v).\u2003\u2003(V.4)",
                                "The CSS construction of quantum codes applies to a self-orthogonal (null) subspace S\u22862n: For every vector v\u2208S, one can define an X-stabilizer X(v) as well as Z-stabilizer Z(v). The set of equivalence classes of X-type (Z-type) logical operators is then in one-to-one correspondence with S\u22a5/S. The number of logical qubits is thus",
                                "k=dimS\u22a5/S=n\u22122S.\u2003\u2003(V.5)",
                                "One can encode logical qubits by choosing a complete set of logical operators {tilde over (X)}(j) and {tilde over (Z)}(j) as follows. Choose a (p,q)-magic basis {v(1), . . . , v(p), w(1), . . . , w(q)} of S\u22a5/S. (Here an adapted notation is used to denote an equivalence class (a member of the quotient space) by a representative.) Then, one defines",
                                "\\(\\quad\\begin{matrix}\n\\begin{matrix}\n\\left\\{ \\begin{matrix}\n{{\\overset{\\sim}{X}}^{(i)} = {X\ue8a0\\left( v^{(i)} \\right)}} \\\\\n{{\\overset{\\sim}{Z}}^{(i)} = {Z\ue8a0\\left( v^{(i)} \\right)}}\n\\end{matrix} \\right. & \\; & {{{{for}\ue89e\\mspace{14mu} \ue89ei} = 1},\\ldots \ue89e\\;,p,} \\\\\n\\left\\{ \\begin{matrix}\n{{\\overset{\\sim}{X}}^{({p + {2\ue89ej} - 1})} = {X\ue8a0\\left( w^{({{2\ue89ej} - 1})} \\right)}} \\\\\n{{\\hat{Z}}^{({p + {2\ue89ej} - 1})} = {Z\ue8a0\\left( w^{({2\ue89ej})} \\right)}}\n\\end{matrix} \\right. & \\left\\{ \\begin{matrix}\n{{\\overset{\\sim}{X}}^{({p + {2\ue89ej}})} = {Z\ue8a0\\left( w^{({{2\ue89ej} - 1})} \\right)}} \\\\\n{{\\overset{\\sim}{Z}}^{({p + {2\ue89ej}})} = {X\ue8a0\\left( w^{({2\ue89ej})} \\right)}}\n\\end{matrix} \\right. & {{{{for}\ue89e\\mspace{14mu} \ue89ej} = 1},\\ldots \ue89e\\;,{q\ue89e\\text{/}\ue89e2.}}\n\\end{matrix} & \\left( {V\ue89e{.6}} \\right)\n\\end{matrix}\\)",
                                "By definition of the magic basis, these logical operators obey the canonical commutation relation of Pauli operators on k qubits:",
                                "{tilde over (X)}(a){tilde over (Z)}(b)(\u22121)\u03b4{tilde over (Z)}(b){tilde over (X)}(a).\u2003\u2003(V.7)",
                                "Note that the commutation relation can be realized with arbitrary signs\u00b1in the choice of the logical operators, but induced Clifford logical operators will depend on the signs. (V.6) is enforced in order for the transversal Hadamard {tilde over (H)}=Hnto be the logical Hadamard \u03a0a=1k{tilde over (H)}(a).",
                                "CSS codes are defined based on self-orthogonal subspaces over 2:",
                                "**Theorem 2.**",
                                "Let S\u22862n be a self-orthogonal subspace with a (p,q)-magic basis of S\u22a5/S. Then, there exists a CSS code on n qubits with p+q logical qubits and a choice of logical operators such that transversal Hadamard H\u2297n implements the logical Hadamard for the logical qubits 1, . . . , p, and simultaneously the swaps between the logical qubit p+2j\u22121 and p+2j where j=1, . . . , q/2.",
                                "In this disclosure, a weakly self-dual CSS code is called \u201codd\u201d if the magic basis is odd, and even otherwise. It is possible for an odd code to have an even number of logical qubits, an even number of physical qubits, and an even distance. Every even code, however, has an even number of logical qubits, an even number of physical qubits, and an even distance.",
                                "It is noted that, the CSS codes derived from a self-orthogonal matrices are not too restrictive. By representing each qubit in any stabilizer code of parameters [[n,k,d]] by Majorana modes, one can obtain a weakly self-dual CSS code of parameters [[4n,2k,2d]]. See Sergey Bravyi, Bernhard Leemhuis, and Barbara M. Terhal, \u201cMajorana fermion codes,\u201d New J. Phys. 12, 083039 (2010), 1004.3791. This mapping is briefly reviewed in Section VI B. Other families of such codes with improved rate are also presented."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce inner codes",
                                "define symmetric dot product",
                                "define null subspace S",
                                "prove lemma 1",
                                "define symmetric matrix \u039b",
                                "state lemma 2",
                                "prove lemma 2",
                                "define (p,q)-magic basis",
                                "state theorem 1",
                                "introduce CSS codes from self-orthogonal matrices",
                                "define X-stabilizer and Z-stabilizer",
                                "choose magic basis for logical operators",
                                "define logical operators",
                                "state theorem 2",
                                "define odd and even codes"
                            ],
                            "num_characters": 7576,
                            "outline_medium": [
                                "define symmetric forms over 2",
                                "motivate classification of symmetric forms",
                                "classify symmetric forms over 2",
                                "define magic basis",
                                "construct CSS codes from self-orthogonal matrices",
                                "encode logical qubits using magic basis",
                                "summarize CSS codes from self-orthogonal subspaces"
                            ],
                            "outline_short": [
                                "define symmetric forms over 2",
                                "classify symmetric forms over 2",
                                "construct CSS codes from self-orthogonal matrices"
                            ]
                        },
                        {
                            "title": "VI. Coding Theory and Asymptotic Performance",
                            "paragraphs": [
                                "**A. Asymptotic Performance**",
                                "In this section, the asymptotic properties of the class of protocols defined above are considered, for appropriate choice and inner and outer codes. Here, possibilities of pipelining are ignored, and only a single inner and outer code to define each protocol are used; this will reduce the question of asymptotic properties to the question of the existence of code families with certain properties.",
                                "In this discussion, \u201casymptotic\u201d will refer to one of two limits. In the first limit, consider a family of protocols parametrized by d, the order of reduction in error. An instance in the family reduces error probability from \u2208 to a constant times \u2208d in the limit of small \u2208. It can be proven that",
                                "**Theorem 3.**",
                                "There is a family of protocols parametrized by an integer d\u22651 to obtain a d-th order reduction in error, using a total of \u0398(d) physical qubits, producing nouter=\u0398(d) magic states. The total number of T gates used is nT=\u0398(d2), so that the number of T gates per magic state is \u0398(d). The T-gate depth of the circuit is also \u0398(d), where the T-gate depth refers to the circuit depth assuming that an arbitrary Clifford can be executed in depth 1.",
                                "In the second limit, one can fix d and consider a family of protocols parametrized by nouter, the number of magic states produced. Here it is proven that",
                                "**Theorem 4.**",
                                "For any odd d\u22655, there is a family of protocols using nouter\u00b7(1+o(1)) physical qubits, producing nouter magic states with a d-th order reduction in error. The total number of T gates used is",
                                "nT=(1+o(1))nouter.\u2003\u2003(VI.1)",
                                "Given one particular protocol with \u2208out=C\u2208ind consuming nT/nouter T gates per output, an infinite family of protocols can be defined by concatenation with itself. For this concatenated family, the number of T gates to achieve an arbitrarily small error rate \u03b4 in output magic states scales like O((log 1/\u03b4)\u03b3) where the scaling exponent is",
                                "\u03b3=logd(nT/nouter).\u2003\u2003(VI.2)",
                                "See Sergei Bravyi and Alexei Kitaev, \u201cUniversal quantum computation with ideal Clifford gates and noisy ancillas,\u201d Phys. Rev. A 71, 022316 (2005), quant-ph/0403025; Sergey Bravyi and Jeongwan Haah, \u201cMagic state distillation with low overhead,\u201d Phys. Rev. A 86, 052329 (2012), 1209.2426.",
                                "Smaller values of \u03b3 reflect asymptotically more efficient distillation protocols. The triorthogonal codes (see Sergey Bravyi and Jeongwan Haah, \u201cMagic state distillation with low overhead,\u201d Phys. Rev. A 86, 052329 (2012), 1209.2426) achieve \u03b3\u2192log2(3), and \u201cmultilevel\u201d protocol (see Cody Jones, \u201cMultilevel distillation of magic states for quantum computing,\u201d Phys. Rev. A 87, 042305 (2013), 1210.3388v2) achieves \u03b3\u21921+. It was conjectured that no protocol could achieve \u03b3<1. Both families in Theorems 3 and 4 achieve \u03b3\u21921.",
                                "It can be noted that the measure \u03b3 slightly underestimates the T-count efficiency of the family in Theorem 3. In order to achieve an arbitrary small final error rate \u03b4 from a fixed initial error rate, say, \u2208=0.01, one can pick a member Pd of the family of error reduction degree d such that \u03b4>Cd(\u2208/2d2)d. Here Cd is the leading coefficient of the output error probability of the protocol Pd, which is at most the number of ways that weight d errors occur among nT=0(d2) T gates; Cd\u2264\u03b1(d2d) for some \u03b1>0 independent of d. For the condition \u03b4>Cd(\u2208/d2)d, it suffices that d>(log(1/\u03b4)+log \u03b1)/log(1/\u2208). One can initially distill magic states to suppress the error rate from \u2208 to \u2208\u2032=\u2208/d2, by using a concatenated protocol Pinit. This takes ninit=O(log d)\u03b3 input magic states per output magic states for some \u03b3>1. One can then feed Pd with the outputs from Pinit at error rate \u2208\u2032. It follows that",
                                "nT/nouter=O(d)\u00b7ninit=O(log(1/\u03b4)(log log 1/\u03b4)\u03b3)\u2003\u2003(VI.3)",
                                "magic states at error rate e suffice to achieve final accuracy \u03b4. Thus, the scaling of nT/nouter is linear in log(1/\u03b4) up to a logarithmic correction. (One can iterate the argument recursively to further slow down the dependency on 1/\u03b4.)",
                                "Theorem 4 will use odd codes. The reduced number of T gates required to implement checks with an odd code is essential to obtaining the number of T gates in the theorem (one would need roughly twice as many using even codes). This explains why d is chosen odd. The case of d=1 is of course trivial: no codes are needed.",
                                "Theorems 3, 4 will follow almost immediately given certain families of inner and outer codes obeying certain properties of the codes that are defined below. These theorems are proven given these properties in this subsection and families of inner and outer codes are constructed with these properties in subsections VI B and VI C.",
                                "Consider first, the inner code. This code will have kinner logical qubits and ninner physical qubits. The distance of the inner code will be at least d. Consider then the effect of errors in the T gates inside the inner code; e.g., in the T gates acting on the encoded state. To obtain d-th order reduction in error, it suffices to consider the case that fewer than d errors occur in such T gates. Since the inner code distance is at least d, these errors cannot produce a logical error. There is one way, however, in which these errors can have an effect without being detected by the inner code. It is possible that a pair of errors act inside the inner code, both on T gates acting on the same qubit. The effect of these errors is to cause an error in the check being measured by the inner code, e.g., if the check was measuring a given product of W operators specified by the outer code, one can instead measure the opposite sign; referred to herein as \u201cmeasurement error\u201d.",
                                "The possibility of measurement errors affects some of the properties that are attributes of the outer code. Desirably, the outer code has a distance of at least d, as otherwise a pattern of fewer than d errors in the input magic states could cause an undetectable error, but this is not sufficient. It is desirable that a pattern of fewer than d errors causes enough checks to be violated so that even a small number of measurement errors will lead to an error detected by the code. This is defined by the property of \u201csensitivity\u201d that is now defined.",
                                "The outer code will have m parity checks, encoded in an m-by-nouter parity check matrix M, where each row of the matrix indicates a given check. One can measure rows of this matrix with even weight using an even inner code and rows with odd weight using an odd inner code. For simplicity, and without limitation, all rows can have even weight or all rows can use use odd weight so that one can use the same inner code for all checks. (More generally, one could use both an inner and an outer code). Then, this inner code must have kinner greater than or equal to the maximum row weight of M. In this case, one can say that the inner code can implement the checks of the outer code.",
                                "**Definition 2.**",
                                "An m-by-nouter parity check matrix M for a classical linear code is said to be ({tilde over (d)},s)-sensitive if any nonzero bit vector v of length nouter with |v|\u2264{tilde over (d)}. It follows that |Mv\u2265s. That is, for any such vector, the number of violated parity checks is at least s.",
                                "It can be emphasized that sensitivity is a property of the check matrix of the outer code, rather than the codewords of the outer code, and in some examples the rows of the check matrix may be linearly dependent.",
                                "A ({tilde over (d)},s)-sensitive parity check matrix is ({tilde over (d)}\u22121,s)-sensitive by definition.",
                                "**Lemma 3.**",
                                "Given a parity check matrix M such that 2|Mv|+|v|\u2265d for any nonzero v",
                                "\\(\\left( {{e.g.\\; \ue89e\\left( {{d - 1},\\frac{d - 1}{2}} \\right)} - {{sensitive}\ue89e\\mspace{14mu} \ue89eM}} \\right),\\)",
                                "and given an inner code of distance d that can implement the checks defined by M, the protocol yields d-th order reduction in error.",
                                "**Proof.**",
                                "Any error pattern inside the inner codes with weight less than d cannot cause a logical error. Thus, if an error pattern inside the inner code does not violate a stabilizer of the inner code, it either has no effect or it leads to an error in measurement of a check of the outer code; the latter possibility requires at least two errors inside the inner code. Any input state with |v|\u22651 errors will violate at least |Mv|\u2265(d\u2212|v|)/2 checks of the outer code. If no violation of these checks is detected, there must be at least 2|Mv| errors on T gates inside the inner code. Thus, there must be at least d errors in total. \u25a1",
                                "Now, some asymptotic properties of the codes are defined.",
                                "**Definition 3.**",
                                "A family of quantum error correcting codes with increasing number of qubits n has good rate if the number of encoded qubits k is \u0398(n) and has good distance if the distance d is \u0398(n).",
                                "**Definition 4.**",
                                "Given a family of outer codes with increasing nouter, one can say that this family has good sensitivity if each code in the family is ({tilde over (d)},s)-sensitive for {tilde over (d)}=\u0398(nouter) and s=\u0398(nouter).",
                                "**Definition 5.**",
                                "Given a family of outer codes with increasing nouter, one can say that this family has good check rate if the parity check matrix is m-by-nouter with m=\u0398(nouter).",
                                "**Proof of Theorem 3.**",
                                "In subsection VI B, it is shown that families of both even and odd inner codes with good rate and distance exist, and in subsection VI C, it shown that families of outer codes with good check rate, good sensitivity, and even row weight exist. Combining these results with Lemma 3, theorem 3 follows. \u25a1",
                                "**Proof of Theorem 4.**",
                                "In subsection VI B, it is shown that, for any d, there exist families of both even and odd inner codes with increasing ninner such that kinner/ninner\u21921. To prove this theorem, one will only need the result for odd inner codes. Consider some code from this family with given kinner,ninner. In subsection VI C, Lemma 9 is shown, which is reproduced here:",
                                "**Lemma.**",
                                "Given integers {tilde over (d)}, w\u22651 and s\u22652, there exists an m\u00d7nouter parity check matrix M that is ({tilde over (d)},s)-sensitive where in =nouter\u00b7s/w and every row of M has weight wt exactly.",
                                "Choose w=kinner. Choosing {tilde over (d)}\u2265d\u22121 and s=(d\u22121)/2, this gives an outer code such that the checks can be performed by the given inner code and one can perform nouter(S/W)=nouter(s/kinner) checks with the inner code. Each such check with the inner code requires using 2ninner T gates, so that the total number of T gates needed to perform the checks with the inner code is equal to 2nouters(ninner/kinner). Additionally, one can perform nouter T gates to create the input magic states to the outer code. Thus, the total number of T gates is",
                                "\\(\\quad\\begin{matrix}\n\\begin{matrix}\n{n_{T} = \ue89e{n_{outer}\ue89e\\; \ue89e\\left( {1 + {2\ue89e{sn}_{inner}\ue89e\\text{/}\ue89ek_{inner}}} \\right)}} \\\\\n{= \ue89e{n_{outer}\ue89e\\; \ue89e{\\left( {d + {\\left( {d - 1} \\right)\ue89e\\left( {{n_{inner}\ue89e\\text{/}\ue89ek_{inner}} - 1} \\right)}} \\right).}}}\n\\end{matrix} & \\left( {{VI}\ue89e{.4}} \\right)\n\\end{matrix}\\)",
                                "Taking ninner large so ninner/kinner\u21921, it can be concluded that nT\u2192nouterd. \u25a1",
                                "One can now see better why d\u22655 was used in Theorem 4. This is because for d=3, one has s=1 and lemma 9 does not apply. It will be explained later why the case s=1 is excluded from that lemma; roughly, this is because in this case, each bit participates in only a single check and one would lack certain expansion properties for a certain graph defined later.",
                                "**B. Inner Codes**",
                                "In this subsection, asymptotic constructions of inner codes are disclosed. Also in this subsection, a few constructions of weakly self-dual codes with good rate and distance are discussed as well as improvements to these schemes offered by the disclosed technology.",
                                "First, A. R. Calderbank and Peter W. Shor, \u201cGood quantum error-correcting codes exist,\u201d Phys. Rev. A 54, 10981105 (1996), quant-ph/9512032 shows that, given any ratio d/n, one can find a family of weakly self-dual CSS codes with n qubits and distance d and given ratio d/n achieving a rate k/n\u21921-2H2(d/n), where H2 is the binary entropy function. The codes found in that paper all are even codes. However, the disclosed technology can obtain odd codes from them by a \u201cpuncturing procedure\u201d (see also section 3.5 of Daniel Gottesman, \u201cStabilizer codes and quantum error correction,\u201d (1997), quant-ph/9705052:",
                                "**Definition 6.**",
                                "Given an even weakly-self-dual CSS code C on n qubits with k logical qubits, define a \u201cpunctured code\u201d C\u2032 as follows. Choose a qubit i (the code C\u2032 may depend upon the choice of i). Write the stabilizer generators of C such that only one X-type and one Z-type generator is supported on i. Define C\u2032 by removing qubit i and removing the stabilizer generators support on i. Then C\u2032 has n\u2032=n\u22121 qubits and k+1 logical qubits. The code C\u2032 is an odd code by construction.",
                                "If C is non-degenerate with distance d, then C\u2032 has distance d\u2032\u2265d\u22121. More generally, d\u2032+1 is greater than or equal to the minimum weight of an operator which commutes with the stabilizer group of C, because given an X-type logical operator O in C\u2032 then either O or OXi must commute with the stabilizer group of C. Indeed, one may show that puncturing the codes of A. R. Calderbank and Peter W. Shor, \u201cGood quantum error-correcting codes exist,\u201d Phys. Rev. A 54, 10981105 (1996), quant-ph/9512032 reduces the distance by at most 1.",
                                "The only disadvantage of this proof is that it is a greedy proof that is not known how to implement efficiently. One example of doing this is a randomized construction which allows one to give codes which, with high probability, have the desired distance. Unfortunately, this construction will only achieve k/n\u2192\u00bd\u2212H2(2d/n). This construction uses a general method to construct weakly self-dual CSS codes in Sergey Bravyi, Bernhard Leemhuis, and Barbara M. Terhal, \u201cMajorana fermion codes,\u201d New J. Phys. 12, 083039 (2010), 1004.3791.",
                                "Consider a stabilizer code Cqubit which acts on n physical qubits and has k logical qubits and distance d. From this code, one can derive a code for Majorana fermions CMajorana which acts on 4n Majorana modes and has k logical qubits and distance 2d, where now the distance refers to minimum weight of a product of Majorana operators that is a logical operator. The code CMajorana is derived in the following way: For each physical qubit of Cqubit, one introduces four Majorana modes, \u03b30, \u03b31, \u03b32, \u03b33, and declares that the product \u03b40\u03b31\u03b42\u03b33 is a stabilizer of CMajorana. For each stabilizer of Cqubit, one defines a stabilizer of CMajorana by replacing X on a qubit by i\u03b30\u03b31, Y by i\u03b30\u03b32, and Z by i\u03b30\u03b33. The stabilizer generators of CMajorana are given by bit strings of length 4n such that the dot product over 2 of any pair of such bit strings is 0. Thus, from CMajorana, one can define a weakly self-dual CSS code Cwsd with 4n physical qubits, 2k logical qubits and distance 2d. Since a randomized construction (see, for example, Eq. 7.200 of John Preskill, \u201cLecture notes on quantum computation.\u201d Caltech Ph219.) gives stabilizer codes Cqubit with k/n\u21921\u2212H2(d/n)\u2212(d/n) log2(3), mapping these stabilizer codes Cqubit to weakly-self dual codes Cwsd gives k/n\u2192(\u00bd)[1\u2212H2(2d/n)\u2212(2d/n) log 2(3)]. Since the randomized construction gives a lower bound to the weight of any operator commuting with the stabilizer group, one can puncture these codes and reduce the distance by at most 1.",
                                "Another proof of the existence of such good weakly self dual-codes is given below. This next proof will lead to rate k/n\u21921\u22122H2(d/n). For any fixed distance d, one can obtain families of stabilizer codes with n physical qubits and k logical qubits with the ratio k/n\u21921 as n\u2192\u221e. While this improvement is only by constant factors over the construction via Majorana codes, it will lead to nice asymptotic expressions for the number of T-gates, nT, required to attain d-th order suppression in error. It is also a randomized construction, showing that codes in a certain ensemble have the desired properties with high probability.",
                                "Define a random ensemble of n-by-c weakly self-orthogonal matrices as follows, where a matrix M is defined to be self-orthogonal if MMT=0. Choose the first row of the matrix to be the all 1s vector {right arrow over (1)}. Choose the second row uniformly at random subject to the constraint that it have vanishing dot product with the first row. Continue in this fashion, choosing the j-th row uniformly at random subject to the constraint that it have vanishing dot product with the first j\u22121 rows. (Remark: the restriction that, the first row be the all Is vector is simply chosen to simplify some notation, so that one does not need to add the requirement that each row have even weight.)",
                                "**Lemma 4.**",
                                "Consider a fixed n-component vector v, with v\u22600 and v\u2260{right arrow over (1)}. For a random c-by-n self-orthogonal M, the probability that Mv=0 is at most 2\u2212c+1+2\u2212n+c+1.",
                                "**Proof.**",
                                "Let w1, . . . , wc be the rows of M. Let Vj be the self-orthogonal subspace which is the span of the first j rows of M. One can estimate the desired probability by a union bound, considering separately the event that v\u2208Vc\u22a5 and v\u2209Vc, and the event that v\u2208Vc\u22a5 and v\u2209Vc.",
                                "Consider the first event. Let j>1. Then",
                                "Pr[wj\u00b7v=0|v\u2209Vj\u22121]=\u00bd,\u2003\u2003(VI.5)",
                                "because the constraint that (v, wj)=0 is independent of the constraints on the vector wj. Thus, for any k,",
                                "\\(\\begin{matrix}\n{{{\\Pr \ue8a0\\left\\lbrack {\\upsilon \\in {V_{k}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89e\\upsilon} \\notin V_{k}} \\right\\rbrack} \\leq {\\prod\\limits_{j = 2}^{k}\ue89e\\; \ue89e\\frac{1}{2}}} = {2^{{- k} + 1}.}} & \\left( {{VI}\ue89e{.6}} \\right)\n\\end{matrix}\\)",
                                "For k=c, one can find in particular that",
                                "Pr[v\u2208Vc\u22a5 and v\u2209Vc]\u22642\u2212c+1.\u2003\u2003(VI.7)",
                                "Now one can estimate the probability of the second event. Note that if v\u2208Vc, there is a least j such that v\u2208Vj. So,",
                                "\\(\\begin{matrix}\n{{\\Pr \ue8a0\\left\\lbrack {\\upsilon \\in {V_{c}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89e\\upsilon} \\in V_{c}} \\right\\rbrack} \\leq {\\sum\\limits_{j = 2}^{c}\ue89e{{\\Pr \ue8a0\\left\\lbrack {\\upsilon \\in {V_{j}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89e\\upsilon} \\in {V_{j - 1}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89e\\upsilon} \\notin V_{j - 1}} \\right\\rbrack}.}}} & \\left( {{VI}\ue89e{.8}} \\right)\n\\end{matrix}\\)",
                                "We have",
                                "Pr[v\u2208Vj and v\u2208Vj\u22121\u22a5 and v\u2209Vj\u22121]=Pr[v\u2208Vj\u22121\u22a5 and v\u2209Vj\u22121\u22a5]\u00b7Pr[v\u2208Vj\u22121|v\u2208Vj\u22121\u22a5 and v\u2209Vj\u22121]\u22642\u2212j+2Pr[v\u2208Vj\u22121|v\u2208Vj\u22121\u22a5 and v\u2209Vj\u22121],\u2003\u2003(VI.9)",
                                "where Eq. (VI.6) was used.",
                                "Now one can estimate the probability Pr[v\u2208Vj|v\u2208Vj\u22121\u22a5 and v\u2209Vj\u22121]. This is possibly nonzero only if v\u00b7v=0. Consider the space of all n-component vectors modulo vectors in Vj\u22121; this quotient space has dimension at least n\u2212(j\u22121). Let \u03c0 be the natural map from the space of all vectors to this quotient space. The vector \u03c0v is nonzero by assumption. The vector wj is subject to at most j\u22121 independent constraints from Vj\u22121. Consider the space of possible \u03c0wj, given that wj obeys those constraints; this space has dimension at least n\u22122(j\u22121) and so the probability that a random vector in this space is equal to \u03c0v is at most 2\u2212(n\u22122j+2). Hence, Pr[v\u2208Vj\u22121|v\u2208Vj\u22121\u22a5 and v\u2209Vj\u22121]\u22642\u2212(n\u22122j+2), so Pr[v\u2208Vj\u22121 and v\u2208Vj\u22121\u22a5 and v\u2209Vj\u22121]\u22642\u2212n+j. So by Eq. (VI.8).",
                                "\\(\\begin{matrix}\n{{\\Pr \ue8a0\\left\\lbrack {\\upsilon \\in {V_{c}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89e\\upsilon} \\in V_{c}} \\right\\rbrack} \\leq {\\sum\\limits_{j = 2}^{c}\ue89e2^{{- n} + j}} \\leq {2^{{- n} + c + 1}.}} & \\left( {{VI}\ue89e{.10}} \\right)\n\\end{matrix}\\)",
                                "By a union bound, adding probabilities in Eqs. (VI.7,VI.10), the lemma follows. \u25a1",
                                "**Lemma 5.**",
                                "Let n, c, d be such that",
                                "\\(\\begin{matrix}\n{{\\left( {2^{{- n} + c + 1} + 2^{{- c} + 1}} \\right)\ue89e{\\sum\\limits_{w = 1}^{d}\ue89e\\begin{pmatrix}\nn \\\\\nw\n\\end{pmatrix}}} < 1.} & \\left( {{VI}\ue89e{.11}} \\right)\n\\end{matrix}\\)",
                                "Then, there exists an c-by-n matrix M such that MMT=0 and such that Mv\u22600 for any v\u22600 with v having Hamming weight at most d.",
                                "**Proof.**",
                                "This follows from lemma 4 and by a first moment bound. For random M from the above ensemble, the average number of vectors v $0 with Hamming weight at most d such that MTv=0 is at most (\u03a3w=1d(wn))\u00b7(2\u2212n+c+1+2\u2212c+1).",
                                "**Lemma 6.**",
                                "For any fixed d, one can find a family of M with increasing n such that the ratio c/n tends asymptotically to zero and such that Eq. (VI.11) is obeyed. Hence, for any distance d, one can find a family of even or odd weakly self-dual CSS codes such that the ratio kinner/ninner\u21921 as ninner\u2192\u221e.",
                                "**Proof.**",
                                "Immediate for the even case. Since the lemma 4 upper bounds the probability that an operator commutes with the stabilizer group one can also puncture these codes to obtain an odd code. \u25a1",
                                "**C. Outer Codes**",
                                "In this subsection, families of outer codes are constructed with good check rate and sensitivity. The discussion begins with a randomized construction, and then it is shown how to construct explicit families using previous results in coding theory.",
                                "**Lemma 7.**",
                                "There exist families of outer codes with good check rate and sensitivity and even row weight.",
                                "**Proof.**",
                                "Consider a random m-by-nouter parity check matrix M. Let {tilde over (d)}=nouter\u22121. Choose each row independently but with the constraint that it should be of even weight. For any vector 1, with |v|\u2264{tilde over (d)}, the syndrome vector Mv has independent entries from the uniform distribution. Thus, the probability that |Mv|\u2264s for s\u2264m/2 is bounded by",
                                "\\({{2^{- m}\ue89e{\\sum\\limits_{i \\leq s}\ue89e\\begin{pmatrix}\nm \\\\\ni\n\\end{pmatrix}}} = {\ue52e^{*}\ue8a0\\left( 2^{m\ue8a0{({{H\ue8a0{({s\ue89e\\text{/}\ue89em})}} - 1})}} \\right)}},\\)",
                                "where H(p)=\u2212p log2(p)\u2212(1\u2212p) log2(1\u2212p) is the binary entropy function. The number of such vectors v is bounded by 2n. By a union bound, the probability that there is an error vector v of weight less than {tilde over (d)} such that the syndrome has weight less than s is bounded by",
                                "(2m(H(s/m)\u22121)2n=*(2n\u00b7(1+(m/n)(H(s/m)\u22121)).",
                                "For sufficiently large ratio m/nouter and sufficiently small ratio s/m, this quantity is exponentially small in nouter. \u25a1",
                                "The above randomized construction is very similar to randomized constructions of classical codes with good rate and distance, where it is defined",
                                "**Definition 7.**",
                                "A family of classical error correcting codes with increasing number of bits n has good rate if the number of encoded bits k is \u0398(n) and has good distance if the distance d is \u0398(n).",
                                "That is, even though very different properties are being considered (number of violated checks rather than distance of the code), the first moment argument above is very similar to standard first moment arguments to construct such codes with good rate and distance, with some additional technicalities required to ensure even weight of the parity checks. This is not a coincidence. As will now be shown, given a family of codes with good rate and distance, one can construct a family of codes with good check rate and sensitivity.",
                                "**Lemma 8.**",
                                "Let C be a classical error correcting code that encodes k bit messages into n bit codewords. Let C have distance d. Let v1, . . . , vk be a basis for the codewords of C. Let M be the n-by-(k+1) matrix whose columns are the vectors v1, . . . , vk, w where w=v1+ . . . +vk. Then, all rows of M have even weight and M is a parity check matrix for a code with nouter=k+1 bits which is ({tilde over (d)},s) sensitive with s=d and {tilde over (d)}=nouter\u22121. Thus, the code with parity checks encoded by M has only two codewords (the all 0 vector and the all 1 vector) and any message which is not a codeword will violate at least d checks.",
                                "**Proof.**",
                                "For any (k+1)-bit vector v, the vector Mv is a codeword of C. If v is nonzero and is not equal to the all 1 vector, then Mv is a nonzero codeword of C and hence has weight at least d. \u25a1",
                                "Since nouter=k+1, in order to obtain an even nouter, if C has k even, one can simply define a new code C\u2032 which encodes k\u22121 bit messages into n bit codewords by using any (k\u22121)-dimensional subspace of the codewords of C, in this way obtaining a parity check matrix for a code with nouter=k\u22121+1=k.",
                                "Using lemma 8, one can construct explicit families of codes with good check rate and good sensitivity given any explicit family of codes with good rate and good distance. As an example of such a code family, one can use the expander codes of Michael Sipser and Daniel A Spielman. \u201cExpander codes,\u201d IEEE Transactions on Information Theory 42, 17101722 (1996).",
                                "**Lemma 9.**",
                                "Given integers {tilde over (d)}, w\u22651 and s\u22652, there exists an m\u00d7nouter parity check matrix M that is ({tilde over (d)},s)-sensitive where m=nouter\u00b7s/w and every row of M has weight w exactly.",
                                "**Proof.**",
                                "A parity check matrix M defines a bipartite graph G, often called a Tanner graph. One set of vertices of the graph (which we call B labeled by the columns of M) corresponds to bits of the code and the other set (which we call C labeled by the rows of M) corresponds to checks, with an edge between a pair of vertices if M is nonzero in the corresponding entry. Equivalently, given such a bipartite graph G, this defines a parity check matrix. It can be claimed that given a bipartite graph with all vertices in B having degree s and all vertices in C having degree w and with girth >2{tilde over (d)}, the corresponding parity check matrix defines a code with the desired properties. Once this has been shown, the lemma follows, since Z Furedi. Felix Lazebnik. A Seress. Vasiliy A Ustimenko, and Andrew J Woldar, \u201cGraphs of prescribed girth and bi-degree,\u201d Journal of Combinatorial Theory, Series B 64, 228-239 (1995) shows the existence of such graphs.",
                                "Note first that the degree of vertices in C corresponds to the row weight of M. Next, note that if all vertices in C have degree w and all in B have degree s, then",
                                "\\(m = {{\uf603C\uf604} = {n_{outer}\ue89e\\frac{s}{w}}}\\)",
                                "with nouter=|B|.",
                                "To prove the claim, let V C B be a nonempty set of erroneous bits. By assumption, 1\u2264|V|\u2264{tilde over (d)}. Consider a subgraph H of G defined by all vertices of V and its neighbors. By the girth condition on C, the subgraph H has to be a collection of disjoint trees. Thus, it suffices to prove the claim in case where H is connected. If |V|=1, then the error violates s checks, and the proof is done. If |V|\u22652, let v1, v2\u2208V be a pair that are the furthest apart. The choice of the pair ensures that each of v1 and v2 has s\u22121 leaves attached to it. Therefore, V violates at least 2s\u22122\u2265s checks.\n\n\n- - \u25a1",
                                "Note that the ratio m/nouter=s/w in lemma 9 is the best possible, because each bit must participate in at least s checks (e.g., every column of the parity check matrix must have weight at least s).",
                                "Now consider the question of finding small Tanner graphs with the desired properties. It will now be shown that any such Tanner graph with girth 6 or more (which implies that the checks are non-overlapping) and which defines a code with distance 7 or more will give an outer code that gives seventh order reduction in error when used with an inner code of distance 7 or more. First, any single input error will violate 3 checks, since every bit is in three checks. Any pair of input errors on qubits q1, q2 must violate at least 4 checks (each qubit is in 3 checks, and since the checks are nonoverlapping, there is at most one check containing both q1, q2). Any three input errors on qubits q1, q2, q3 must also violate at least 3 checks (there is at most one check containing q1, q2 and at most one check containing q2, q3 and at most one check containing q1, q3). Any four input errors on qubits q1, q2, q3, q4 must violate at least 2 checks (the number of violated checks must be even since there are an even number of input errors, and by the distance assumption, there is no pattern on four qubits that violates no checks). By the distance assumption, any five or six input errors must violate at least one check.",
                                "Numerical searches were performed for graphs with the needed girth which defined a code with the needed distance as follows: an integer m was chosen and an outer code searched with mkinner qubits and 3m checks. The search was an iterative randomized procedure. The graph was initialized by taking in copies of the complete bipartite graph on kinner qubits and 3 checks. This initial graph clearly does not obey the girth bound (all three of the checks in each copy are identical). An iterative random search was performed to find a graph with girth 6 or more; this search proceeded by first finding a 4-cycle, then choosing an edge (q,C) between a qubit q and an edge C in that 4-cycle, then choosing another random edge (q\u2032,C\u2032) and replacing the pair (q,C) and (q\u2032,C\u2032) with (q,C\u2032) and (q\u2032,C). This procedure was repeated until the graph had girth 6 or more. Then, an additional random search was performed; this search also replaced pairs of edges (q,C) and (q\u2032,C\u2032) with (q,C\u2032) and (q\u2032,C); in this case, the pairs were chosen randomly subject to the constraint that no 4-cycle is created. After a large number of such steps, the determination of whether the resulting code had distance 7 was tested; this test was done by searching for an error pattern of weight 6 or less that does not violate an outer code check; some tricks were done to speed this search (for example, if a qubit q has an error, and if q is in checks C1, C2, C3 then there must be qubits q1\u2208C1,q2\u2208C2,q3\u2208C3 with q1,q2,q3\u2260q such that q1,q2,q3 all have errors).",
                                "For kinner=5, 7, 9, 11, 13, for m=kinner+1, graphs were found with girth 6 by random search. Note that there exist graphs with girth 6 with m=kinner (the grid code with horizontal, vertical, and one diagonal is an example of such). The graphs give concrete examples of outer codes which obey the distance and sensitivity bounds.",
                                "Outer codes were also found that obey the distance and sensitivity bounds with nouter=mkinner qubits for smaller values of m by taking more checks. This was done by finding graphs of girth 6 or more as described above and then performing a large number of random updates of these graphs keeping girth \u22656. Then, if the resulting code had distance 5 or 6, attempts were made to numerically find whether one could add a small number of checks to that code to obtain a code with distance 7, repeating the search until success. The resulting code then gives seventh order reduction and, since only a few checks are added, has close to the minimum number of input magic states.",
                                "The results of these searches are shown in table I."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce asymptotic properties of protocols",
                                "define two limits of asymptotic performance",
                                "state Theorem 3",
                                "prove Theorem 3",
                                "state Theorem 4",
                                "prove Theorem 4",
                                "define \u03b3 for concatenated protocols",
                                "discuss triorthogonal codes and multilevel protocols",
                                "conjecture \u03b3<1",
                                "discuss T-count efficiency of Theorem 3",
                                "define error reduction degree d",
                                "discuss initial distillation of magic states",
                                "derive nT/nouter scaling",
                                "discuss Theorem 4 using odd codes",
                                "define inner code properties",
                                "discuss effect of errors in T gates",
                                "define measurement error",
                                "introduce outer code properties",
                                "define sensitivity of outer code",
                                "prove Lemma 3",
                                "define good rate and distance of codes",
                                "define good sensitivity and check rate of outer codes",
                                "prove Theorem 3 using inner and outer codes",
                                "prove Theorem 4 using inner and outer codes",
                                "discuss existence of inner codes with good rate and distance",
                                "discuss existence of outer codes with good check rate and sensitivity",
                                "define puncturing procedure for even codes",
                                "discuss randomized construction of weakly self-dual CSS codes",
                                "introduce Majorana fermion codes",
                                "derive weakly self-dual CSS codes from Majorana codes",
                                "discuss randomized construction of stabilizer codes",
                                "define random ensemble of weakly self-orthogonal matrices",
                                "state Lemma 4 for random self-orthogonal matrices",
                                "introduce coding theory",
                                "define asymptotic performance",
                                "prove lemma 4",
                                "prove lemma 5",
                                "prove lemma 6",
                                "introduce outer codes",
                                "prove lemma 7",
                                "define classical error correcting codes",
                                "prove lemma 8",
                                "construct explicit families of codes",
                                "prove lemma 9",
                                "discuss Tanner graphs",
                                "discuss small Tanner graphs",
                                "discuss numerical searches",
                                "describe iterative randomized procedure",
                                "describe additional random search",
                                "test for distance 7",
                                "discuss results of searches",
                                "discuss outer codes with smaller values of m",
                                "describe method for adding checks",
                                "discuss results of searches",
                                "discuss table I",
                                "conclude coding theory",
                                "conclude asymptotic performance",
                                "conclude outer codes",
                                "conclude overall"
                            ],
                            "num_characters": 30103,
                            "outline_medium": [
                                "introduce asymptotic properties of protocols",
                                "define two limits for asymptotic analysis",
                                "state Theorem 3 on d-th order reduction in error",
                                "state Theorem 4 on d-th order reduction in error with odd d",
                                "motivate importance of \u03b3 exponent",
                                "discuss triorthogonal codes and multilevel protocol",
                                "conjecture that no protocol can achieve \u03b3<1",
                                "define \u03b3 exponent and its relation to T-count efficiency",
                                "discuss error reduction using concatenated protocols",
                                "define inner code and its properties",
                                "define outer code and its properties, including sensitivity",
                                "state Definition 2 of ({tilde over (d)},s)-sensitivity",
                                "state Lemma 3 on d-th order reduction in error",
                                "define good rate, good distance, good sensitivity, and good check rate",
                                "outline proof of Theorem 3",
                                "outline proof of Theorem 4",
                                "define coding theory and asymptotic performance",
                                "prove lemma 4",
                                "prove lemma 5",
                                "prove lemma 6",
                                "introduce outer codes",
                                "prove lemma 7",
                                "define classical error correcting codes",
                                "prove lemma 8",
                                "prove lemma 9",
                                "discuss finding small Tanner graphs",
                                "discuss numerical searches for graphs",
                                "describe results of numerical searches",
                                "conclude outer codes section"
                            ],
                            "outline_short": [
                                "introduce asymptotic properties of protocols",
                                "define theorem 3: family of protocols with d-th order reduction in error",
                                "define theorem 4: family of protocols with d-th order reduction in error using odd codes",
                                "motivate sensitivity of outer code",
                                "define sensitivity of outer code",
                                "prove theorem 3 using lemma 3 and existence of inner and outer codes",
                                "prove theorem 4 using lemma 9 and existence of inner and outer codes",
                                "introduce inner codes and their constructions",
                                "prove probability bound",
                                "prove lemma 5",
                                "prove lemma 6",
                                "construct outer codes",
                                "prove lemma 7",
                                "prove lemmas 8 and 9"
                            ]
                        },
                        {
                            "title": "VII. Numerical Simulation",
                            "paragraphs": [
                                "In this section, results of numerical simulations are given. The discussion begins with an explanation of the error model used for simulations. The discussion also includes an explanation of two protocols that are simulated and that have not been explained previously; one of these protocols uses a [[21,3,5]] code. Simulation results are the given. One interesting result of the simulation is how little effect the subleading terms have, even at fairly large noise values.",
                                "**A. Magic State Fidelity**",
                                "When one injects a magic state \u03bc for \u03c0/4 rotation into a quantum circuit, there is a probability for correction K by angle \u03c0/2 to be applied. If one represents the overall procedure by a quantum channel C\u03bc, it is C\u03bc(\u03c1)=\u03a0+(\u03c1\u2297\u03bc)\u03a0++K\u03a0\u2212(\u03c1\u2297\u03bc)\u03a0\u2212K\u2020, where \u03a0\u00b1 denotes the measurement combined with a control-Pauli on the magic state and a target data qubit. Let |\u03bc0 be the ideal magic state, and |\u03bc0\u22a5 be the orthogonal state. Then, it is straightforward to calculate that C|\u03bc\u03bc+|\u03bc\u03bc|(\u03c1)=0.",
                                "This implies that for any initial approximate magic state \u03bc, the result of the injection is the same as if \u03bc had been through a twirling channel \u03b5 that dephases the magic state in the basis {\u03bc0,|\u03bc0\u22a5}:",
                                "\\(\\begin{matrix}\n{\\mu = {{\\begin{pmatrix}\n{1 - \\epsilon} & * \\\\\n* & \\epsilon\n\\end{pmatrix}\ue89e\\overset{\u025b}{\ue205}\ue89e\\begin{pmatrix}\n{1 - \\epsilon} & 0 \\\\\n0 & \\epsilon\n\\end{pmatrix}}.}} & \\left( {{VII}\ue89e{.1}} \\right)\n\\end{matrix}\\)",
                                "The twirled state is \u2208 away from the ideal state in the trace distance, resulting in error at most \u2208 to the quantum circuit's outcome. (The trace distance is defined as T(\u03c1, \u03c3)=\u00bd\u2225\u03c1\u2212\u03c3\u22251.) The error \u2208 can be expressed by the squared fidelity as",
                                "1\u2212\u2208=F2(\u03bc0,\u03bc)=0|\u03bc|\u03bc0=\u03bc0|\u03b5(\u03bc)|\u03bc0.\u2003\u2003(VII.2)",
                                "(The fidelity is defined as F(\u03c1,\u03c3)=\u2225\u221a{square root over (\u03c1)}\u221a{square root over (\u03c3)}\u22251, which is equal to |\u03c1|\u03c3| for pure \u03c1 and \u03c3.) This formula is convenient in that it yields the same answer regardless of whether or not twirling is applied to \u03bc (this is the last equality in the above formula). When a state \u03bcn that approximates \u03bc0\u2297n is injected, the error from this multi-qubit magic state is given by 1\u2212F2(\u03bc0\u2297n,\u03bcn). Note that F2(\u03bc0,\u03bc) is linear in \u03bc. Below, 1\u2212F2 is used as the probability of error to report the simulation results.",
                                "**B. Error Models**",
                                "The typical model to analyze distillation protocols is the stochastic error model. In typical distillation protocols, one has only a single output, magic state, and so one is interested in the probability that the output magic state has an error as a function of the input, conditioned on no error being detected by the code; the error probability is a ratio of polynomials in \u2208, with the leading term being of order \u2208d for some d, with an integer coefficient.",
                                "For purposes of this discussion, since the codes used are fairly large, enumeration of all possible error patterns becomes difficult, especially if one wishes to go beyond leading order in t. For this reason, numerical simulation is used. One could simulate a mixed state, using a quantum channel to describe an approximate T-gate; however, this is numerically prohibitive and it is preferred to use an approach that involves only pure states. One could numerically simulate pure states using the stochastic error model by choosing errors to occur with probability p, and sampling the output error probability. However, this simulation also becomes difficult, precisely because the codes lead to a high suppression in the error. For example, if the target error probability is 10\u221210, one would require \u02dc1010 samples, with a fairly large number of qubits needed to be simulated in each run, to determine the output error probability accurately.",
                                "While there may be ways to overcome this sampling issue using importance sampling, in certain embodiments of the disclosed technology, another method is used. Instead of rotating by either \u03c0/4 or by 5\u03c0/4 as in the stochastic error model, each T gate rotates by an angle chosen uniformly in the interval [\u03c0/4\u2212\u03b8, \u03c0/4+\u03b8], for some angle \u03b8>0. Then, conditioned on the code not detecting an error, one can determine the error in the output state.",
                                "In fact, the model with input angles [\u03c0/4\u2212\u03b8, \u03c0/4+\u03b8] and the stochastic error model describe the same average input state, assuming an appropriate choice of \u2208 and \u03b8.",
                                "\\(\\quad\\begin{matrix}\n\\begin{matrix}\n{{\\frac{1}{2\ue89e\\theta}\ue89e{\\int_{\\lbrack{{- \\theta},{+ \\theta}}\\rbrack}\ue89e\\ \ue89e{{dx}\ue8a0\\begin{pmatrix}\n{\\cos^{2}\ue89e\\frac{x}{2}} & {\\sin \ue89e\\frac{x}{2}\ue89e\\cos \ue89e\\frac{x}{2}} \\\\\n{\\sin \ue89e\\frac{x}{2}\ue89e\\cos \ue89e\\frac{x}{2}} & {\\sin^{2}\ue89e\\frac{x}{2}}\n\\end{pmatrix}}}} = {{\\left( {1 - \\epsilon} \\right)\ue89e\\mspace{11mu} \ue89e\\begin{pmatrix}\n1 & 0 \\\\\n0 & 0\n\\end{pmatrix}} + {\\epsilon \ue89e\\mspace{11mu} \ue89e\\begin{pmatrix}\n0 & 0 \\\\\n0 & 1\n\\end{pmatrix}}}} \\\\\n{\\mspace{79mu} \ue89e{{\\frac{1}{2} - \\frac{\\sin \ue89e\\mspace{11mu} \ue89e\\theta}{2\ue89e\\theta}} = \\epsilon}}\n\\end{matrix} & \\left( {{VII}\ue89e{.3}} \\right)\n\\end{matrix}\\)",
                                "Hence, one wants \u2208\u2248\u03b82/12. (It is emphasized that this is in a notation where \u03b8 is the rotation angle in the Bloch sphere; the T-gate is a rotation by \u03c0/4, not by \u03c0/8.) From this equation, it is evident that the sample average in the random angle model converges faster to its true average. In the stochastic error model with small e, one must do roughly 1/e runs to obtain meaningful statistics, while here, one needs only a constant number of runs.",
                                "**C. Other Protocols**",
                                "**1. [[16,2,4]] Inner Code**",
                                "In subsubsection III B 2 it was explained that a protocol using a [[16,6,4]] inner code. This required using a total of 17 physical qubits, namely 16 for the code and one ancilla. One can also modify this inner code to a [[16,2,4]] inner code by turning some of the logical operators into checks. This inner code suffices to implement the H-measurements on pairs of states (23), (45), (61) and so it can implement the checks of the outer code used in subsubsection III B 2. Using a [[16, 2,4]] inner code, if one wants to have nouter=6, a total of 21 physical qubits can be used, since one needs 16 for the code, plus 4 for the logical qubits not encoded in the code, plus one ancilla. Thus, this requires additional physical qubits compared to the [[16,6,4]] code. The reason for considering the [[16,2,4]] code in numerics is to see if it reduces the prefactor in the error, since the [[16,2,4]] code has fewer logical operators than the [[16,6,4]] code. The protocol can be pipelined e.g., with the [[16,2,4]] inner code in the same way as done with the [[16,6,4]] inner code.",
                                "See FIG. 6 in Section XI.",
                                "**2. [[21,3,5]] Inner Code**",
                                "Another inner code that was used is a [[21,3,5]] inner code. This allows one to obtain fifth order reduction in error. nouter=4 was used with the outer code having check matrix",
                                "\\(\\begin{matrix}\n{M = {\\begin{pmatrix}\n1 & 1 & 1 & 0 \\\\\n1 & 1 & 0 & 1 \\\\\n1 & 0 & 1 & 1 \\\\\n0 & 1 & 1 & 1\n\\end{pmatrix}.}} & \\left( {{VII}\ue89e{.4}} \\right)\n\\end{matrix}\\)",
                                "It uses 4 checks for 4 qubits. This matrix is not (4,2)-sensitive, but is sufficient to achieve fifth order reduction in error since 2|Mv|+|v|\u22655 for every nonzero v. See FIG. 9 in Section XI.",
                                "A simple pipelining can reduce the noisy T gate count compared to this protocol. Distill three independent magic states using [[7,1,3]] inner code. (The outer code is trivial in this case.) The three distilled magic states are then pipelined into the [[21,3,5]] inner code. This produces 3 magic states with error O(\u22085), consuming, per output, 28 T gates and one T state with error \u2208.",
                                "Without pipelining, but using weight 3 checks from [[21,3,5]], one can find an outer code that is (4,2) sensitive using (\u2154)nouter checks. This produces nouter magic states with fifth order error suppression, consuming 42\u00b7\u2154=28 T gates and one T state, per output. The smallest such outer code is explained elsewhere herein, where it is called the Petersen graph code.",
                                "**D. [[23,1,7]] Inner Code**",
                                "A [[23,1,7]] inner code is also given in this disclosure. Pipelining this code with a [[7, 1,3]] and a [[17,1,5]] inner code gives nouter=1 with error O(\u22087). One could also apply this code to each of the output bits of any of the other fifth order protocols of section VII C 2 to obtain error O(\u22087).",
                                "**E. Results**",
                                "The results of the simulations are shown in FIG. 5. Note that the plots are close to linear on a log-log plot, with only small deviations at high error rate. Each data point represents the average of at least 104 runs, with statistical fluctuations negligible on the scale of the plot. The asymptotic behavior is within statistical error of that given by an enumeration of minimum weight error patterns.",
                                "The protocol using [[16,2,4]] inner code has a slightly reduced output error, compared to the protocol using the [[16,6, 4]] inner code.",
                                "It is emphasized that \u2208out indicates the probability that there is any error in the output state which is a multi-qubit state. Suppose that two protocols give the same value of \u2208out for a given \u2208in, but one protocol has a large nouter. If the total number of magic states is large compared to nouter, the number of times one desirably calls the protocol is inversely proportional to nouter, and so the protocol with the larger nouter for the given \u2208out is less likely to produce an error.",
                                "The probability that no error is detected by the protocol is roughly (1\u2212\u2208in)n. This result would be exact if any error in an input T gate led to the protocol detecting an error. Instead, some high weight error patterns do not lead to any error detected by the code, leading to slight corrections to this formula.",
                                "FIG. 5 shows results of numerical simulations. \u2208in represents input error; this is the error \u2208 of Eq. (VII.3) for the given \u03b8. \u2208out is the average of 1\u2212\u03bc0|\u03bc|\u03bc0 over runs. The numbers labelling curves indicate the number of physical qubits, not including the ancilla qubit. Specifically, 4 indicates protocol using [[4,2,2]] inner code. 7 indicates protocol using [[7,1,3]] inner code. 15 is the Bravyi-Kitaev 15-to-1 protocol included for comparison purposes; 7 and 15 have almost identical performance. 16 is pipelined protocol using [[16,6,4]] inner code; 20 is pipelined protocol using [[16,2,4]] inner code. 17 is pipelined protocol using [[17,1,5]] inner code. 22 is protocol using [[21,3,5]] inner code with nouter=4. 21 is protocol using [[21,3,5]] inner code pipelined with [[7,1,3]] inner code. 17, 21, and 22 have almost identical performance. 23 is protocol using [[23,1,7]] inner code."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "explain error model used for simulations",
                                "introduce magic state fidelity",
                                "define twirled state",
                                "express error in terms of squared fidelity",
                                "introduce stochastic error model",
                                "explain difficulty of enumerating error patterns",
                                "introduce alternative error model with random angles",
                                "show equivalence of alternative model to stochastic error model",
                                "discuss advantages of alternative model",
                                "introduce [[16,2,4]] inner code",
                                "explain modification of inner code to implement H-measurements",
                                "discuss pipelining of [[16,2,4]] inner code",
                                "introduce [[21,3,5]] inner code",
                                "explain pipelining of [[21,3,5]] inner code",
                                "discuss reduction of noisy T gate count",
                                "introduce [[23,1,7]] inner code",
                                "discuss pipelining of [[23,1,7]] inner code",
                                "present results of simulations",
                                "discuss asymptotic behavior of results",
                                "emphasize importance of nouter in error probability"
                            ],
                            "num_characters": 10391,
                            "outline_medium": [
                                "explain error model used for simulations",
                                "define magic state fidelity",
                                "introduce twirling channel to dephase magic state",
                                "express error in terms of squared fidelity",
                                "describe stochastic error model",
                                "introduce alternative error model with random angles",
                                "discuss [[16,2,4]] inner code protocol",
                                "discuss [[21,3,5]] inner code protocol",
                                "discuss [[23,1,7]] inner code protocol",
                                "present simulation results"
                            ],
                            "outline_short": [
                                "explain error model used for simulations",
                                "introduce magic state fidelity",
                                "describe error models used",
                                "discuss other protocols",
                                "present results of simulations"
                            ]
                        },
                        {
                            "title": "VIII. Protocols at Intermediate Size",
                            "paragraphs": [
                                "In this section, a family of protocols that work well at intermediate sizes is presented. These protocols achieve a ratio nT/nouter that is fairly close to asymptotically optimal (e.g., close to 6) even for modest sizes. They also achieve a high success rate by a modification of the previous protocols: the usual approach is that if an error is detected, either by a stabilizer measurement of the inner code or by a measurement of the outer code, a failure is declared and the process is tried again. Instead, in certain embodiments, an error correction scheme is used in some cases to fix errors while maintaining seventh order reduction in error.",
                                "The first ingredient is an inner code. In certain example embodiments, quantum BCH codes are used. See Markus Grassl and Thomas Beth, \u201cQuantum bch codes,\u201d arXiv preprint quant-ph/9910060 (1999). There are quantum BCH codes that are weakly self-dual CSS codes, with parameters such as [[63,27,7]] or [[63,39,5]] or [[127,85,7]] or [[127,99,5]]. Thus, the ratio kinner/ninner is fairly large for these codes even at modest sizes for distance 5 or 7.",
                                "The second ingredient is an outer code. Here, a few possibilities can be considered. Before generalizing, consider the following example. Let nouter=mn, for some m, n, and imagine the qubits as arranged in an m-by-n grid. One can take m=kinner for some given inner code and n=kinner for some other inner code. The outer code has two types of checks, corresponding to rows and columns of the grid. These checks can be paralleized, so that all checks of a given type are performed at the same time. In particular embodiments, the rows are done first, then the columns (though other embodiments use the reverse order); the row measurements can be done in parallel, as can the column measurements.",
                                "This outer code has distance four, and this protocol will achieve fourth order reduction in error. One can say that a row or column detects an error if there is an error detected by either the stabilizer measurements of the inner code for that column or by the check of the outer code for that column. One can also say that there is a measurement in the check of an outer code if the check shows no error but there is indeed an error.",
                                "In certain example embodiments, the following protocol is performed:\n\n\n- - 1. Check the rows using any inner code of distance at least 2. If\n    there is an error detected by any given row R, re-initialize the\n    qubits in that row to approximate magic states and repeat the\n    measurement on the row. At this point, the rows are independent\n    (unentangled with each other), so repeating the measurements on a\n    given row has no effect on the other rows.\n  - 2. Check the columns using any inner code of distance at least 4. If\n    there is an error detected by any column, discard the qubits in that\n    column.\n  - 3. The remaining qubits are approximate magic states with error\n    O(\u2208\u2074).",
                                "Before analyzing the output error rate, a distinction will first be discussed. Previously, when showing that an output error was reduced to fourth order (for example), it sufficed to show that any pattern of T-gate errors which led to no error being detected and which led to an output error had at least four T-gate errors. Now, however, one is conditioning on the fact that some errors did occur: for example, if an error is detected by a stabilizer measurement in some column, it is known that at least one T-gate error occurred when acting on the encoded state (and possibly more occurred); thus, it should be shown that the number of T-gate errors required to produce an output error is at least four more than the number of T-gate errors known to occur. This will be assumed in what follows, without being stated explicitly, so that all counts of number of T-gate errors do not include the known errors.",
                                "There are two points to consider. The first is to show that the output error is indeed O(\u22084). Consider any output magic state in qubit q. Qubit q is in some row R and column C. Consider the following possibilities. First, suppose that there is no logical error in row R. This breaks into two subcases. In the first subcase, suppose that there is no error in measurement of the outer code in row R. Then, there must be some other qubit q\u2032 in row R which is also input with an error. No error is detected by column C, so either there is a measurement error of the outer code in column C (in which case the total number of T-gate errors is at least 4, given 1 for q, 1 for q\u2032, and 2 for the measurement error) or there is another qubit q\u2033 in column C which also has an error. However, since q\u2033 is in some row R\u2032\u2260R, and R\u2032 does not detect an error, again the total number of T-gate errors is at least 4. In the second subcase, suppose that there is an error in measurement of the outer code in row R. Then, since q has an error also, the total number of T-gate errors is at least 3, and further q will also be measured in some column C so if not error is detected there, the weight must be more than 3.",
                                "Suppose instead there is a logical error in row R. Thus, one can have a situation where qubit q has an error after measuring the row and only two T-gate errors have occurred. However, then q is measured in some column and again the total number of errors must be at least 4.",
                                "The second point is the success rate: in this case, one does not mind discarding all qubits in a row R as this affects only that row. The number of T-gates in a row is \u02dcn, and so for \u2208n\u22721, there is a good probability of accepting each row. If instead one had discarded all rows when any single error was detected, one would need mn\u2208\u22721.",
                                "The above procedure can be generalized to a three dimensional grid; for simplicity, consider size n3, although one may also consider different sizes in each direction. This discussion refers to rows, columns, and verticals to denote the three directions. The outer code again measures each of the three directions in turn, first, rows, then columns, then verticals. This outer code has distance 8, but one can achieve seventh order reduction in error. This is the best possible outcome given that each qubit is in only three checks.",
                                "At this point, a new modification is introduced to the protocol: error correction. In particular embodiments, the following protocol is used:\n\n\n- - 1. Check the rows using any inner code of distance at least 3. If\n    there is an error detected by any given row R, re-initialize the\n    qubits in that row to approximate magic states and repeat the\n    measurement on the row. At this point, the rows are independent\n    (unentangled with each other), so repeating the measurements on a\n    given row has no effect on the other rows.\n  - 2. Check the columns using any inner code of distance at least 7. If\n    the inner code stabilizers detect an error in any column C, and that\n    error syndrome can be caused by at most 1 error inside the inner\n    code, apply an error correction to fix those errors, and then repeat\n    the measurement in that column, continuing until no errors are\n    detected. If the outer code check detects an error, discard all\n    qubits in the vertical plane which contains that given column and\n    repeat steps 1, 2 on the qubits in that plane.\n  - 3. Check the verticals using any code of distance at least 7. If any\n    error is detected by a measurement of an outer code check, discard\n    all qubits and repeat the protocol from the beginning. Otherwise, if\n    an error is detected by an inner code stabilizer, discard the qubits\n    in that diagonal but not in the other diagonals where no inner code\n    stabilizer detects an error. Return all qubits which are not\n    discarded as approximate magic states; they have error O(\u2208\u2077).",
                                "Note that in step 2, if an error syndrome can be caused by at most 1 error, and a correction is applied, it is possible that a logical error is produced. It is possible that there were actually 6 or more errors inside the inner code, and the correction led to a weight 7 logical error. In this case, the difference between the known number of T-gate errors (1) and the actual number (at least 6) is at least 5, so the effect of the correction is to make it as if the inner code in step 2 only had distance 5.",
                                "Thus, one should analyze a protocol as if the codes has distance 3,5,7 for rows, columns, verticals. However, such a code indeed leads to a seventh order reduction in error.",
                                "The reason for the error correction step is to reduce the change of having to discard all qubits in a given plane. The number of T-gates applied in checking columns in any given plane is \u02dcn2, and so if one discarded all qubits in a plane whenever any error was detected by the inner code, one would need \u2208n2\u22721. Instead, discarding can be performed in a plane due to inner code errors if there are at least 2 errors in a given column; to make this probability small, one needs (\u2208n)2n=\u22082n3\u22721.",
                                "Finally, consider the probability of having to discard a plane due to errors in an outer code measurement in a column. After the first round of row measurements, the error probability for qubits in any row is \u02dc\u22082 for any given qubit, so the probability of discarding a plane is \u02dc\u22082n2, rather than \u2208n2 as one might have guessed.",
                                "A final interesting outer code to consider is a modification of the two dimensional grid, where now one can add an additional check on the diagonals. This outer code has distance 6. Distance 6 or higher codes can be used to perform the checks. In such cases, the rows can be checked, then the columns, then the diagonals (different orders are also possible). The same error correction as in the three dimensional grid can be used: one can correct column measurements with at most 1 error in the inner code."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "introduce family of protocols for intermediate sizes",
                                "discuss use of quantum BCH codes as inner codes",
                                "explain construction of outer code",
                                "discuss row and column checks of outer code",
                                "introduce error correction scheme",
                                "explain re-initialization of qubits in error-corrected rows",
                                "discuss discarding of qubits in error-detected columns",
                                "analyze output error rate",
                                "discuss conditioning on detected errors",
                                "show that output error is O(\u2208\u2074)",
                                "discuss success rate of protocol",
                                "generalize protocol to three-dimensional grid",
                                "introduce error correction in three-dimensional grid",
                                "discuss application of error correction in columns",
                                "explain discarding of qubits in error-detected vertical planes",
                                "analyze output error rate in three-dimensional grid",
                                "discuss success rate of three-dimensional grid protocol",
                                "introduce modification of two-dimensional grid with diagonal checks",
                                "discuss error correction in modified two-dimensional grid"
                            ],
                            "num_characters": 9772,
                            "outline_medium": [
                                "introduce family of protocols for intermediate sizes",
                                "describe inner code using quantum BCH codes",
                                "describe outer code with row and column checks",
                                "explain error correction scheme",
                                "analyze output error rate",
                                "discuss success rate of protocol",
                                "generalize protocol to three-dimensional grid",
                                "introduce error correction step",
                                "discuss probability of discarding planes due to errors"
                            ],
                            "outline_short": [
                                "introduce inner code and outer code",
                                "describe protocol with error correction",
                                "analyze output error rate and success rate",
                                "generalize to three-dimensional grid and discuss error correction"
                            ]
                        },
                        {
                            "title": "IX. Discussion",
                            "paragraphs": [
                                "In this disclosure, a general scheme has been given to construct distillation protocols using inner and outer codes. If desired, these protocols can be concatenated with other protocols. However, on their own, they achieve optimal asymptotic behavior, as well as having small size examples which perform well.",
                                "One of the advantages of these protocols is the small number of qubits that they use, as they maintain a constant ratio of physical to logical qubits in the asymptotic limit. In Cody Jones, \u201cMultilevel distillation of magic states for quantum computing,\u201d Phys. Rev. A 87, 042305 (2013), 1210.3388v2, another family of protocols giving \u03b3\u21921 was constructed. However, this protocol, like most distillation protocols involving concatenation, required a large overhead of physical to logical qubits. The benefits of reduced overhead may be even more important if possible errors in the Clifford gates are taken into account.",
                                "It is interesting to consider the asymptotics of this overhead between physical and logical qubits. Note that given any distillation protocol, there is a trivial way to define a new protocol with a fixed ratio of physical to logical qubits. Suppose, for example, that some protocol uses nphys qubits to produce 1 output magic state. Call this protocol P. One can define a new protocol P\u2032 that works on 2nphys qubits to produce nphys output magic states, which simply consists of applying P a total of nphys times sequentially. However, the T-gate circuit depth of P\u2032 now is proportional to nphys times the T-gate depth of P. In contrast, in Theorem 3, a d-th order error reduction is obtained at fixed ratio of physical to logical with a T-gate depth proportional to d. That is, the protocols that are discussed herein are space and time efficient.",
                                "**X. Example Small Inner and Outer Codes**",
                                "In this section, some specific inner and outer codes are given, either giving the stabilizers or referring to the literature. Some of these codes are explained in the basic distillation section III or in numerical simulations VII in the body of this disclosure. Other codes have other useful properties that are described for specific codes.",
                                "When stabilizers for an inner code are given, each row gives one stabilizer generator. Each row consists of a binary string, of length equal to the number of qubits, with a 1 indicating that that stabilizer acts on that qubit (the parity check matrix is given).",
                                "**A. Inner Codes**",
                                "**1. [[4,2,2]] Inner Code**",
                                "This is explained in Section III.",
                                "**2. [[16,6,4]] Inner Code**",
                                "The stabilizer matrix is the classical Hadamard code [16,5,8].\n\n\n- - 1111111111111111\n  - 1111111100000000\n  - 1111000011110000\n  - 1100110011001100\n  - 1010101010101010",
                                "**3. [[7,1,3]] Inner Code**",
                                "This is explained in Section III.",
                                "**4. [[17,1,5]] Inner Code**",
                                "This code is the smallest odd code that was found with kinner=1 and distance 5. The stabilizers are:\n\n\n- - 11011010101000010\n  - 01100011001100110\n  - 00110110010011001\n  - 00010101000111110\n  - 00001110010011101\n  - 00000101000110000\n  - 00000011111011010\n  - 00000001010100001",
                                "**5. [[21,3,5]] and [[23,1,7]] Inner Codes**",
                                "The (extended) Golay code is a classical self-dual code which is [24, 12, 8]. Puncturing a bit by collecting all code words that has zero on that bit, one obtains a self-orthogonal [23,11, 7]. From this, one can obtain a weakly self-dual CSS code which is [[23,1,7]]. There are many positions to puncture, but due to high symmetry of the Golay code, the resulting codes have the same weight enumerators. One can pipeline the [[23,1,7]] code after the protocol of section III A 2 to give a protocol with one output magic state and seventh order suppression in error.",
                                "By puncturing the [[23,1,7]] code twice, one obtains a [[21,3,5]] code. In a numerical search, a smaller odd code with kinner=3 and distance 5 was found. The stabilizers of the [[21,3,5]] code are:\n\n\n- - 100000000011110110100\n  - 010000000001111011010\n  - 001000000110110011001\n  - 00010000011011001101\n  - 000010000001101100111\n  - 000001000110111000110\n  - 000000100101010010111\n  - 000000010100100111110\n  - 000000001100011101011",
                                "The code [[20,2,6]] can be constructed from the five-qubit code [[5,1,3]] by going through the Majorana operators, while the others cannot be constructed in this way. See Sergey Bravyi, Bernhard Leemhuis, and Barbara M. Terhal. \u201cMajorana fermion codes,\u201d New J. Phys. 12, 083039 (2010), 1004.3791",
                                "**6. Other Inner Codes**",
                                "Some other examples of inner codes can be found in M. B. Hastings, \u201cSmall majorana fermion codes,\u201d 1703.00612, from which one can reproduce optimal kinner found for given distance and ninner in Table II. For stabilizers, see M. B. Hastings, \u201cSmall majorana fermion codes.\u201d 1703.00612.",
                                "**B. Outer Codes**",
                                "**1. Petersen Graph Code**",
                                "The outer code in section VII C 2 has 4 qubits, uses weight-3 checks and is (4,2) sensitive. However, from Lemma 9, it is known that there is some nouter such that there is a code which is (4,2) sensitive with weight-3 checks, which has only (\u2154)n outer checks. This code is now explained. The proof of Lemma 9 reduces the problem of finding such a code to finding a bipartite graph G. Since the set B of that lemma has degree 2, one can equivalently define the code by a graph H such that the vertices of the graph H correspond to checks and the edges correspond to bits; e.g., in the case that B has degree 2, the possible bipartite graphs G are in one-to-one correspondence with degree-3 graphs H. Then, from the proof of Lemma 9, it is known that if H has girth at least 5, then the corresponding code is (4,2) sensitive. The smallest such graph H is known to be the Petersen graph. This is a degree-3 graph with 15 vertices and 10 edges.",
                                "Note that the girth being 5 is optimal in this case, because if H has girth 4, then there is a weight 4 error that violates no checks.",
                                "**XI. Example Circuits**",
                                "In this section, example circuits for some of the protocols above are disclosed. Boxes labelled Enc or Enc\u2032 denote encoding and decoding circuits, which are Cliffords. The number in the box indicates what code is used. H denotes Hadamard, M denotes measurement in Z basis, JMx denotes measurement in X basis, Czs denotes control-Z operations.",
                                "FIG. 6 is a block diagram 600 of an example pipelined circuit using [[16,6,4]] code described in section III B 2. Further, the legend in FIG. 6 applies to the FIGS. 7-9 as well.",
                                "FIG. 7 is a block diagram 700 of an example pipelined circuit using [[17,1,5]] code described in section III A 2.",
                                "FIG. 8 is a block diagram 800 of an example pipelined circuit using [[16,2,4]] code described in section VII C 1.",
                                "FIG. 9 is a block diagram 900 of an example circuit using [[21,3,5]] code described in section VII C 2.",
                                "**XII. Coincidence Among Protocols**",
                                "The Steane code has 7 Y-logical operators of weight 3. In the distillation protocol using the Steane code as the inner code, each logical error may appear in 4 different ways in the column that implements control-H\u22977. The measurement error at the lowest order can happen in 7 ways. Overall, the cubic error can happen in 7\u00b74+7=35 ways. This number matches the number of logical operators of weight 3 in the Bravyi-Kitaev 15-to-1 protocol. See Sergei Bravyi and Alexei Kitaev, \u201cUniversal quantum computation with ideal Clifford gates and noisy ancillas,\u201d Phys. Rev. A 71, 022316 (2005), quant-ph/0403025.",
                                "When [[7,1,3]] to [[17,1,5]] were pipelined, there are 48 T gates and 1 T state. The number of logical operators of weight 5 in [[17,1,5]] is 51. Each logical operator can appear in 16 different configurations in the column that implements control-H\u229717. The measurement error from the 17-qubit code routine occurs in 17 ways at the leading order. Thus, the output error probability has leading term (51\u00b716+35\u00b717)\u22085=1411\u22085. The coefficient matches the number of Z-logical operators of weight 5 in the [[49,1,5]] code, as reported in Sergey Bravyi and Jeongwan Haah, \u201cMagic state distillation with low overhead,\u201d Phys. Rev. A 86, 052329 (2012), 1209.2426.",
                                "Bravyi and Cross (see Sergey Bravyi and Andrew Cross, \u201cDoubled color codes,\u201d 1509.03239v1) gave a recursive construction for triply even codes. They showed how to convert a pair of a (classical) triply even code of length nt-1 with dual distance 2t\u22121 and some (classical) self-orthogonal code of length mt with dual distance 2t+1 into a triply even code of length nt=2mt+nt-1 with dual distance 2t+1. The formula gives another coincidence with the pipeline. nt-1 is the number of T gates/states, sitting before the final H-measurement routine in the pipeline, and mt is the code length of the final H-measurement routine. Thus, the recursive formula nt=2mt+nt-1 correctly counts the number of T gates/states used in the pipeline.",
                                "A similar coincidence was observed by Jones (see Cody Jones, \u201cMultilevel distillation of magic states for quantum computing,\u201d Phys. Rev. A 87, 042305 (2013), 1210.3388v2), where the leading error probabilities of the distillation protocols by a family of weakly self-dual [[k+4,k,2]] codes with (k,0)-magic basis and those by a family of triorthogonal codes (see Sergey Bravyi and Jeongwan Haah, \u201cMagic state distillation with low overhead,\u201d Phys. Rev. A 86, 052329 (2012), 1209.2426) are shown to be the same as (3k+1)\u22082. The total number of T gates/states were also the same as 3k+8.",
                                "**XIII. Qudits**",
                                "In this section, an extension to qudits is considered with local Hilbert space dimension p>2, with p a prime. Consider a basis of state |j, where j=0, 1, . . . , p\u22121 is periodic mod p. The following operators and phase factor are used",
                                "\\(\\begin{matrix}\n{\\quad\\begin{matrix}\n\\begin{matrix}\n{{\\omega = \ue89ee^{2\ue89e\\pi \ue89e\\; \ue89e{i/p}}},} \\\\\n{{H = \ue89e{\\frac{1}{\\sqrt{p}}\ue89e{\\sum\\limits_{j,k}\ue89e{\\omega^{jk}\ue89e{\uf603j\\rangle}\ue89e\\mspace{11mu} \ue89e{\\langle k\uf604}}}}},}\n\\end{matrix} & \\begin{matrix}\n{{Z = \ue89e{\\sum\\limits_{j}\ue89e{\\omega^{j}\ue89e{\uf603j\\rangle}\ue89e\\mspace{11mu} \ue89e{\\langle j\uf604}}}},} \\\\\n{{S = \ue89e{\\sum\\limits_{j}\ue89e{\\omega^{{j\ue8a0{({j - 1})}}/2}\ue89e{\uf603j\\rangle}\ue89e\\mspace{11mu} \ue89e{\\langle j\uf604}}}},} \\\\\n{{U\ue8a0(n)} = \ue89e{\\sum\\limits_{j}\ue89e{{\uf603{nj}\\rangle}\ue89e\\mspace{11mu} \ue89e{\\langle j\uf604}\ue89e\\mspace{20mu} \ue89e\\left( {n \\neq 0} \\right)}}}\n\\end{matrix} & \\begin{matrix}\n{{X = \ue89e{\\sum\\limits_{j}\ue89e{{\uf603{j + 1}\\rangle}\ue89e\\mspace{11mu} \ue89e{\\langle j\uf604}}}},} \\\\\n{{\\;^{C}\ue89eX = \ue89e{\\sum\\limits_{j}\ue89e{{\uf603j\\rangle}\ue89e\\mspace{11mu} \ue89e{{\\langle j\uf604} \\otimes X^{j}}}}},}\n\\end{matrix}\n\\end{matrix}} & \\left( {{XIII}\ue89e{.1}} \\right)\n\\end{matrix}\\)",
                                "which generate the Clifford group. It holds that ZX=\u03c9XZ.",
                                "In this section, a generalization of odd codes is used throughout, ignoring even codes. One reason is that one cannot achieve control-Swap in the same way as one could previously. The general method in the qubit case was to use some non-Clifford operation such as a T gate, conjugating controlled Pauli to obtain control-Swap on the code space of some code. However, Swap is of order 2 while control-Z is of order p. For odd codes, implementation of the control-Hadamard was not tired as before, because Hadamard is of order 4 for p>2, and hence is not conjugate to control-Z.",
                                "**A. Preliminary**",
                                "Let one first define a T-gate. The cases p=3 and p>3 are going to be different. Define",
                                "\\(\\quad\\begin{matrix}\n{{{g\ue8a0(j)}:={{\\sum\\limits_{k = 0}^{j}\ue89e{\\frac{1}{2}\ue89e{k\ue8a0\\left( {k - 1} \\right)}}} = {\\frac{1}{6}\ue89e\\left( {j^{3} - j} \\right)}}},} & \\left( {{XIII}\ue89e{.2}} \\right) \\\\\n{{g\ue8a0\\left( {j + p} \\right)} = {{{g\ue8a0(j)}\ue89e\\mspace{20mu} \ue89e{mod}\ue89e\\mspace{11mu} \ue89ep\ue89e\\mspace{25mu} \ue89e{if}\ue89e\\mspace{11mu} \ue89ep} > 3}} & \\left( {{XIII}\ue89e{.3}} \\right)\n\\end{matrix}\\)",
                                "where the second line is because 6 is invertible in p>3, and ensures that g is a well defined function on p>3. All arithmetic in the exponent of \u03c9, Z, X, and S will be over p for both p=3 and p>3. Define the T-gate as",
                                "\\(\\begin{matrix}\n\\begin{matrix}\n{{T = {\\sum\\limits_{j = 0}^{p - 1}\ue89e{\\omega^{g\ue8a0{(j)}}\ue89e{\uf603j\\rangle}\ue89e\\mspace{11mu} \ue89e{\\langle j\uf604}}}},} & {{{TXT}^{- 1}\ue89eX^{- 1}} = S} & {{{{if}\ue89e\\mspace{14mu} \ue89ep} > 3},}\n\\end{matrix} & \\left( {{XIII}\ue89e{.4}} \\right) \\\\\n\\begin{matrix}\n{{T = {{{\uf6030\\rangle}\ue89e\\mspace{11mu} \ue89e{\\langle 0\uf604}} + {e^{{- 2}\ue89e\\pi \ue89e\\; \ue89ei\ue89e\\text{/}\ue89e9}\ue89e{\uf6031\\rangle}\ue89e\\mspace{11mu} \ue89e{\\langle 1\uf604}} + {e^{2\ue89e\\pi \ue89e\\; \ue89ei\ue89e\\text{/}\ue89e9}\ue89e{\uf6032\\rangle}\ue89e\\mspace{11mu} \ue89e{\\langle 2\uf604}}}},} & {{{TXT}^{- 1}\ue89eX^{- 1}} = {e^{{- 2}\ue89e\\pi \ue89e\\text{/}\ue89e9}\ue89eS}} & {{{if}\ue89e\\mspace{14mu} \ue89ep} = 3.}\n\\end{matrix} & \\left( {{XIII}\ue89e{.5}} \\right)\n\\end{matrix}\\)",
                                "These show that in both cases the T gate is at the third level of the generalized Clifford hierarchy. More generally, it is observed that",
                                "\\(\\begin{matrix}\n{{T^{m}\ue89e{XT}^{- m}} = \\left\\{ \\begin{matrix}\n{S^{m}\ue89eX} & {{{{for}\ue89e\\mspace{14mu} \ue89ep} > 3},} \\\\\n{e^{{- 2}\ue89e\\pi \ue89e\\; \ue89e{{im}/9}}\ue89eS^{m}\ue89eX} & {{{{for}\ue89e\\mspace{14mu} \ue89ep} = 3},}\n\\end{matrix} \\right.} & \\left( {{XIII}\ue89e{.6}} \\right)\n\\end{matrix}\\)",
                                "For both p=3 and p>3, define |\u03c8m for in =0, 1, . . . , p\u22121 be the (+1)-eigenstate of TmXT\u2212m:",
                                "TmXT\u2212m|\u03c8m=|\u03c8m.\u2003\u2003(XIII.7)",
                                "Any state |\u03c8m for m=1, . . . , p\u22121 will be a \u201cmagic state.\u201d",
                                "How would one use these magic states? Suppose p>3. Consider a pair of qudits in a state \u03a3jaj|j\u2297|\u03c8m. Apply a control-X operation with the first qudit as source and the second qudit as target. This maps the state to",
                                "\\(\\begin{matrix}\n{{{{{\\frac{1}{\\sqrt{p}}\ue89e{\\sum\\limits_{j,k}\ue89e{a_{j}\ue89e\\omega^{{mg}\ue8a0{(k)}}}}}\ue85cj},{k + j}}\\rangle}.} & \\left( {{XIII}\ue89e{.8}} \\right)\n\\end{matrix}\\)",
                                "Now measure the second qudit in the computational basis, obtaining a result l. This gives a state on the first qudit \u03a3jaj\u03c9mg(l\u2212j)|j. Thus, the transformation implemented on the first qudit is \u03a3j\u03c9mg(l\u2212j)|jj|. Expanding the exponent, one has",
                                "\\(\\begin{matrix}\n{\\quad\\begin{matrix}\n{{{mg}\ue8a0\\left( {\ue54b - j} \\right)} = \ue89e{{{mg}\ue8a0(\ue54b)} - {{mg}\ue8a0(j)} + {\\frac{m}{2}\ue89e\\left( {{\ue54b\ue89ej}^{2} - {\ue54b^{2}\ue89ej}} \\right)}}} \\\\\n{= \ue89e{{{mg}\ue8a0(\ue54b)} - {{mg}\ue8a0(j)} + {{m\ue89e\ue54b}\ue89e\\frac{j\ue8a0\\left( {j - 1} \\right)}{2}} - {m\ue89e\\frac{\ue54b\ue8a0\\left( {\ue54b - 1} \\right)}{2}\ue89e{j.}}}}\n\\end{matrix}} & \\left( {{XIII}\ue89e{.9}} \\right)\n\\end{matrix}\\)",
                                "The first term on the right-hand side of Eq. (XIII.9) corresponds to an irrelevant global phase factor. The second term, \u2212mg(j), corresponding to implementing transformation T\u2212m on the first qudit. The third term gives a phase factor that can be corrected by applying a power of the S gate and the last term gives phase factors that can be corrected by a power of the Z gate. Thus, the state injection procedure works, in that one can use a magic state |\u03c8m to produce a transformation T\u2212m up to Clifford corrections.",
                                "When p=3, the same state injection can be used, with m=1. One finds after some calculation that if the measurement outcome is l=0, the implemented operations is T\u22121 to the source, if l=1, it is \u2208\u22122\u03c0i/9ST\u22121, and if l=2, it is \u22082\u03c0i/9Z\u22121S\u22121T\u22121. Thus, in all cases, the implemented operation is T\u22121 up to a Clifford correction.",
                                "Note that Tm and T\u2212m are interconvertible by Cliffords. More generally, it is possible to use Clifford operations to convert a gate Tm into another gate Tm with m\u2032=mn3 for n\u22600, by U=U(n)=\u03a3j|njj| gate. For p>3, we have U\u2020TmU=\u03a3j\u03c9mg(nj)|jj| where",
                                "\\(\\quad\\begin{matrix}\n{{{g\ue8a0({nj})} = {{\\frac{1}{6}\ue89e\\left( {{n^{3}\ue89ej^{3}} - {nj}} \\right)} = {{{n^{3}\ue89e{g\ue8a0(j)}} + {\\frac{n^{3} - n}{6}\ue89e{j.\ue89e{Thus}}\ue89e\\mspace{14mu} \ue89eU^{\\dagger}\ue89eT^{m}\ue89eU}} = {T^{{mn}\ue89e\\; \ue89e3}\ue89eZ^{m\ue89e\\frac{n^{3} - n}{6}}}}}},} & \\left( {{XIII}\ue89e{.10}} \\right)\n\\end{matrix}\\)",
                                "and so indeed Tm=C1Tm\u2032C2 for some Cliffords C1,C2. For p=3, we see T=U(\u22121)T\u22121U(\u22121). Now, for which pairs m,m\u2032 can we find an n such that m\u2032=mn3? The multiplicative group p\u00d7 is cyclic of order p\u22121. Therefore, when p\u22121 is not a multiple of 3, then p\u00d7nn3\u2208p\u00d7 is a bijection, and any Tm can be interconverted into any other Tm\u2032. If p\u22121 is a multiple of 3, there are three distinct classes of T gates. Since \u22121=(\u22121)3, Tm and T\u2212m are always interconvertible.",
                                "**B. Inner Codes**",
                                "For arbitrary vector v\u2208pnone can write X(v)=Xv\u2297 . . . \u2297X\u03c5ninner, and Z(\u03c5)=Z\u03c51\u2297 . . . \u2297Z pninner. As in the weakly self-dual CSS code construction for qubits, it is straightforward to define a stabilizer code starting from a self-orthogonal subspace S\u2282S\u22a5\u2282pn; The stabilizer group is generated by X(v) and Z(v) where v\u2208S. The quotient space S\u22a5/S is in one-to-one correspondence with the set of X-type (Z-type) logical operators, and the induced dot product on S\u22a5/S is non-degenerate. In Section XIV below, it is shown that there is a basis {v(1), . . . , v(k} of S\u22a5/S such that v(i)\u00b7v(j)=\u03b1j\u03b4ij where the scalars \u03b1j are all 1 possibly except the last one. For simplicity, the discussion is focused on cases where",
                                "(1,1, . . . ,1)\u2208S,\u2003\u2003(XIII.11)",
                                "v(i)\u00b7v(j)=\u03b4ij.\u2003\u2003(XIII.12)",
                                "e.g., the second condition is that all scalars \u03b1j are equal to 1 The first condition demands that ninner to be a multiple of p. The second is a mild restriction, since (S\u2295S)\u22a5/(S\u2295S) always has a basis such that (XIII.12) holds. Given a basis {v(j)} satisfying (XIII.12), one can define logical operators of the inner code as",
                                "{tilde over (X)}(j)=X(v(j)),",
                                "{tilde over (Z)}(j)=Z(v(j)),\u2003\u2003(XIII.13)",
                                "which indeed obey the commutation relation",
                                "{tilde over (Z)}(a){tilde over (X)}(b)=\u03c9\u03b4{tilde over (X)}(b){tilde over (Z)}(a)\u2003\u2003(XIII.14)",
                                "of the generalized Pauli operators on kinner qudits. Thus, this is a generalization of the odd codes in the qubit case. Due to (XIII.11), the transversal gate =S\u2297nis a logical operator:",
                                "SjXkS\u2212j=\u03c9\u2212jk(k+1)/2ZjkXk\u2003\u2003(XIII.15)",
                                "X(v)\u22121=\u03c9\u2212(v\u00b7v+v\u00b7{right arrow over (1)})/2Z(v)X(v)\u2003\u2003(XIII.16)",
                                "where, in the second equation, the phase factor vanishes when v\u2208S.",
                                "One can implement the measurement of the stabilizer TmXT\u2212m of the magic state |\u03c8m using the inner codes. The measurement becomes feasible if C(TmXT\u2212m) can be implemented for logical qudits. Searching for its fault-tolerant implementation can begin by observing an identity C(TmXT\u2212m)=Tm(CX)T\u2212m that enables one to implement some controlled Clifford on logical qudits. The actual action on logical qubits depends on the inner code, but conditions (XIII.11. XIII.12) will make it uniform across all logical qudits.",
                                "Recall TmXT\u2212m=\u03b7\u22121SmX where \u03b7=1 if p>3 and \u03b7=\u22082\u03c0i/9 if p=3. The action of the transversal gate m\u2212m can be deduced by looking at the logical operators and phase. The answer is",
                                "\\(\\begin{matrix}\n{{{\\overset{\\_}{T}}^{m}\ue89e\\overset{\\_}{X}\ue89e\\; \ue89e{\\overset{\\_}{T}}^{- m}} = {{\\eta^{- n_{inner}}\ue89e{\\overset{\\_}{S}}^{m}\ue89e\\overset{\\_}{X}} \\cong {\\eta^{k_{inner} - n_{inner}}\ue89e{\\prod\\limits_{a = 1}^{k_{inner}}\ue89e{\\eta^{- 1}\ue8a0\\left( {{\\overset{\\sim}{S}}^{(a)}\ue8a0\\left( {\\overset{\\sim}{Z}}^{(a)} \\right)}^{1/2} \\right)}^{m}}}}} & \\left( {{XIII}\ue89e{.17}} \\right)\n\\end{matrix}\\)\n\nbecause",
                                "\\(\\begin{matrix}\n\\left\\{ {\\begin{matrix}\n{{{\\overset{\\_}{S}}^{m}\ue89e{\\overset{\\sim}{X}}^{(a)}\ue89e{\\overset{\\sim}{S}}^{- m}} = {{\\omega^{{- m}/2}\ue8a0\\left( {\\overset{\\sim}{Z}}^{(a)} \\right)}^{m}\ue89e{\\overset{\\sim}{X}}^{(a)}}} \\\\\n{{{\\overset{\\_}{S}}^{m}\ue89e{\\overset{\\sim}{Z}}^{(a)}\ue89e{\\overset{\\_}{S}}^{- m}} = {\\overset{\\sim}{Z}}^{(a)}} \\\\\n{{{\\overset{\\_}{S}}^{m}\ue89e\\underset{\\underset{{\uf603\\overset{\\sim}{0}\\rangle}^{\\otimes k_{inner}}}{\uf613}}{\\sum\\limits_{v \\in S}\ue89e{X\ue89e(\\upsilon)\ue89e{\uf6030\\rangle}^{\\otimes n_{inner}}}}} = {\uf603\\overset{\\sim}{0}\\rangle}^{\\otimes k_{inner}}}\n\\end{matrix},\ue89e\\left\\{ {\\begin{matrix}\n{{\\left( {S^{m}\ue89eZ^{m/2}} \\right)\ue89e{X\ue8a0\\left( {S^{m}\ue89eZ^{m/2}} \\right)}^{- 1}} = {\\omega^{{- m}/2}\ue89eZ^{m}\ue89eX}} \\\\\n{{\\left( {S^{m}\ue89eZ^{m/2}} \\right)\ue89e{Z\ue8a0\\left( {S^{m}\ue89eZ^{m/2}} \\right)}^{- 1}} = Z} \\\\\n{{\\left( {S^{m}\ue89eZ^{m/2}} \\right)\ue89e{\uf6030\\rangle}} = {\uf6030\\rangle}}\n\\end{matrix}.} \\right.} \\right. & \\left( {{XIII}\ue89e{.18}} \\right)\n\\end{matrix}\\)",
                                "Suppose p>3. In order to implement C({tilde over (S)}m{tilde over (X)}), one can consider an equation and a solution",
                                "C(SmX)=(CX1\u2212y)(CZu)(CSx)(CXy)(CSz)(CZs)(C\u03c9t)\u2003\u2003(XIII.19)",
                                "C(SmX)=(CX1/3)[(CZ3m/8)(CS3m/4)](CX2/3)[(CSm/4)(CZm/8)](C\u03c9\u2212m/6)\u2003\u2003(XIII.20)",
                                "where the control is common for every gate, and u,x,y,z,s,t are variables. (Using CA=\u03a3j|jj|\u2297Aj, one can evaluate matrix elements on both sides.) Note that the operators in the brackets are powers of C(SmZm/2). This implies that indeed simultaneous C({tilde over (S)}m{tilde over (X)}) on all logical qudits can be implemented using m(C3m/4)\u2212m, m(Cm/4)\u2212m controlled Pauli logical operators, and a power of Z on the control.",
                                "When p=3 it suffices to consider m=1. To remove the phase factor \u03b7k\u2212nthe kinner can be a multiple of 3. This can be achieved by considering three copies of a given code if necessary. ninner is already a multiple of 3 due to (XIII.11). One can implement \u03a0a=1kC(\u03b7\u22121{tilde over (S)}(a){tilde over (X)}(a)) by an identity",
                                "C(\u03b7\u22121SX)=(CX\u22121)(C(\u03b7\u22121SZ\u22121))(CZ)(CX\u22121)(CZ\u22121)(C\u03c92).\u2003\u2003(XIII.21)",
                                "It has been shown that it is possible to build a fault-tolerant routine to measure m\u2212m. One can show the existence of good qudit codes, so asymptotic properties remain the same as for the qubit case.",
                                "It is possible to generalize Lemma 4 to the case of matrices over a field p for p>2; however, the generalization is more difficult since the self-orthogonality constraint implies a nonlinear constraint on the rows of the matrix so that each row is null; see Lemma 13. An alternative construction is now given that achieves the scaling similar to Lemma 6, namely that for any distance d, one can find a family of odd weakly self-dual qudit CSS codes with X({right arrow over (1)}) in the stabilizer group such that the ratio kinner/ninner\u21921 as ninner\u2192\u221e. This construction is derived from Reed-Muller codes. Let C=RM(r,m) be a classical Reed-Muller code over p; the codewords have length pm. The dual code C\u22a5=(m(p\u22121)\u2212r\u22121, m); see Theorem 5.4.2 of Edvard F Assmus and Jennifer D Key. Designs and their Codes, 103 (Cambridge University Press, 1992). For any fixed r, for large enough m, C\u2282C\u22a5, so the codespace of C is self-orthogonal, and {right arrow over (1)} is in the codespace of C. One can use the codespace of C as the space S, and use the CSS construction to define a weakly self-dual code. For fixed r, the rate of C tends to zero at large m, so the rate of the resulting weakly self-dual tends to 1. See S Vijay and L. Fu, \u201cQuantum error correction for complex and majorana fermion qubits,\u201d 1703.00459 for weakly self-dual qubit codes derived from Reed-Muller codes. To make (XIII.12) hold, it may be necessary to use S\u2295S instead of S.",
                                "**C. Outer Codes**",
                                "If the inner code has code distance d, then one should use an outer code with a parity check matrix that is",
                                "\\(\\left( {{d - 1},\\left\\lceil \\frac{d - 1}{2} \\right\\rceil} \\right) - {{sensitive}.}\\)",
                                "In full generality, one would want to use a parity check matrix with entries in p, where an entry \u03b2\u22600 would mean a stabilizer (\u03b7\u22121SmX)\u03b2. This makes it necessary to have a different logical operator choice than used above.",
                                "However, a check matrix that is given by the adjacency matrix of a biregular graph with large girth is sufficient. Such a check matrix has only 0 and 1 entries, so no other choice of logical operator is necessary beyond what is given above. Recall that a graph with large girth is locally a tree. Hence, a bad magic state will be caught by many checks because it flips a single stabilizer in these checks, and the required sensitivity is guaranteed.",
                                "**XIV. Symmetric Forms Over Finite Fields**",
                                "The classified nondegenerate symmetric forms have been classified over the binary field 2 in Section V. Over a field of odd characteristic, the set of all finite dimensional vector spaces with nondegenerate symmetric forms (quadratic spaces for short) constitute an abelian group under the direct sum, after identifying hyperbolic planes as the identity. This group is known as the Witt group of the field, and the group structure is well known. Here a self-contained and elementary treatment of the Witt group of p is presented, and the quadratic spaces over fields of odd characteristic is classified.",
                                "It is natural to distinguish two cases depending on whether \u22121\u2208p is a square, since a one-dimensional quadratic space is classified by p\u00d7/(p\u00d7)2, where p\u00d7:=p\u2020{0} and (p\u00d7)2:={x2\u2208\u00d7}. Since the multiplicative group p\u00d7 is a cyclic group of order p\u22121, the element\u22121 being the unique element of \u00d7 with multiplicative order 2, is a square if and only if p=1 mod 4.",
                                "The part of the argument in Section V applies here without any change where any non-degenerate symmetric matrix was inductively converted to a direct sum of a diagonal matrix and blocks of",
                                "\\(\\begin{pmatrix}\n0 & 1 \\\\\n1 & 0\n\\end{pmatrix},\\)",
                                "which represents a hyperbolic plane. Below, it is assumed that symmetric matrices are block diagonal in this form. It is then easy to explain why quadratic spaces constitute a group:",
                                "\\(\\begin{matrix}\n{{\\begin{pmatrix}\n1 & 1 \\\\\n1 & {- 1}\n\\end{pmatrix}^{T}\ue89e\\begin{pmatrix}\na & 0 \\\\\n0 & {- a}\n\\end{pmatrix}\ue89e\\begin{pmatrix}\n1 & 1 \\\\\n1 & {- 1}\n\\end{pmatrix}} = {\\begin{pmatrix}\n0 & {2\ue89ea} \\\\\n{2\ue89ea} & 0\n\\end{pmatrix} \\simeq \\begin{pmatrix}\n0 & 1 \\\\\n1 & 0\n\\end{pmatrix}}} & \\left( {{XIV}\ue89e{.1}} \\right)\n\\end{matrix}\\)",
                                "This means that the one-dimensional quadratic space with form (\u2212a) is the inverse of the space with form (a). 2 is an invertible element of the field.",
                                "It is noted that the determinant of the symmetric form up to squares is a nontrivial invariant valued in the multiplicative group p\u00d7/(p\u00d7)2 which is isomorphic to the additive group /2. Let \u03b1\u2208p be a non-square.",
                                "Case I:",
                                "p=1 mod 4 so that \u22121\u2208(p\u00d7)2. Consider a block diag(a,a) of the symmetric matrix. Since \u22121 is a square, it can be seen diag(a,a)diag(a, \u2212a)diag(1, \u22121)diag(1, 1) under congruent transformations. Therefore, there are four classes of symmetric matrices up to hyperbolic planes: diag(1), diag(\u03b1), diag(1, \u03b1), and diag(1, 1). By looking at the determinant of the form and the parity of the dimension, it can be seen that the four classes are distinct elements of the Witt group, which is hence isomorphic to /2\u2295/2. Given a dimension of quadratic spaces, there are only two exclusive possibilities:",
                                "diag(1.1, . . . ,1,1), and diag(1.1, . . . ,1,\u03b1).\u2003\u2003(XIV.2)",
                                "Case II:",
                                "p=3 mod 4 so that \u22121\u2209(p\u00d7)2. In this case, one can set \u03b1=\u22121. it is claimed that diag(1, 1) is not hyperbolic. If v=av1+bv2 is a vector in this two-dimensional space, where v1, v2 are basis vectors with vi2=1 and a, b\u2208p, then v\u00b7v=a2+b2. Since \u22121 is not a square, the equation a2+b2=0 does not have any nonzero solution, and this proves the claim. Next, it is shown that diag(1, 1)z,138 diag(\u22121, \u22121). To this end, a solution to a2+b2+1=0 over p is found. Once such a solution is found, then it can be seen that",
                                "\\(\\begin{matrix}\n{{\\begin{pmatrix}\na & b \\\\\nb & {- a}\n\\end{pmatrix}^{T}\ue89e\\begin{pmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{pmatrix}\ue89e\\begin{pmatrix}\na & b \\\\\nb & {- a}\n\\end{pmatrix}} = {\\begin{pmatrix}\n{- 1} & 0 \\\\\n0 & {- 1}\n\\end{pmatrix}.}} & \\left( {{XIV}\ue89e{.3}} \\right)\n\\end{matrix}\\)",
                                "The existence of the solution follows from (p\u00d7)2+(p\u00d7)2(p\u00d7)2, which implies that (p\u00d7)2+(p\u00d7)2\u22121. If (p\u00d7)2+(p\u00d7)2\u2286(p\u00d7)2, then (p\u00d7)2 would be a monoid under addition contained in a finite group, and hence would be a group itself, which must contain 0\u2209(p\u00d7)2. Therefore, quadratic spaces given a dimension are classified by the determinant of the form up to squares.",
                                "diag(1,1, . . . 1,1), and diag(1, . . . 1,\u22121)\u2003\u2003(XIV.4)",
                                "The Witt group of p is isomorphic to /4 generated by diag(1).",
                                "Now, certain facts and proofs are provided about quadratic spaces.",
                                "**Lemma 10**",
                                "(Chapter XV Theorem 10.2 of Serge Lang, Algebra, revised 3rd ed. (Springer, 2002).). Let Q be a nondegenerate quadratic space. If two subspaces V and U are isomorphic by an isometry \u03c3: V\u2192U, then there exists an isometry : Q\u2192Q such that |V=\u03c3.",
                                "**Lemma 11.**",
                                "Let N be a null subspace (on which the symmetric form vanishes) of a nondegenerate quadratic space Q over p. Then, Q is isometric to the orthogonal sum of N\u22a5/N and a minimal hyperbolic subspace that contains N.",
                                "**Proof.**",
                                "Applying Lemma 10 to the identity map a, one can conclude that any orthogonal set of vectors extends to an orthogonal basis. Since the form is nondegenerate, there exists a minimal hyperbolic subspace that includes N (hyperbolic extension), and the symmetric form can be written as \u039b\u2032\u2295\u03bb. where \u03bb is hyperbolic, and \u039b\u2032 is nondegenerate. It is then clear that N\u22a5/N has the symmetric form \u039b\u2032. \u25a1",
                                "**Lemma 12.**",
                                "Let Q be a nondegenerate quadratic space of dimension n over p. Every maximal null subspace of Q has the same dimension in. Given any null subspace N of dimension k\u2264m, the number of null vectors of Q that are orthogonal to N is",
                                "\u22a5(Q,N)=pn\u2212k\u22121+pm\u2212pn\u2212m\u22121=:\u03b6(n,m,k).\u2003\u2003(XIV.5)",
                                "**Proof.**",
                                "To prove the first claim, suppose M, M\u2032 are maximal null subspaces. If dim M\u2264dim M\u2032, then any injection from M to M\u2032 is an isometry, which can be extended to Q as . Then, \u22121(M\u2032) is a null superset of M, and hence is M itself since M is maximal. Thus, dim M=dim M\u2032.",
                                "Let (Q, N) be the set of all null vectors of Q that are orthogonal to N. ( is not a subspace in general.) Consider \u03d5: (Q,N)\u2192(N\u22a5/N,0), a restriction of the canonical projection map Q\u2192Q/N. The map \u03d5 is subjective by definition of \u03b6. If x, y\u2208(Q,N) are mapped to the same element, then x\u2212y\u2208N. This implies that \u03d5 maps exactly #N elements to one. (Here, # denotes the number of elements of the finite set.) Therefore,",
                                "#(Q,N)=(#N)(#(N\u22a5/N,0)).\u2003\u2003(XIV.6)",
                                "Due to the preceding lemma, the dimension of a maximal null subspace of N\u22a5/N is m\u2212k. Thus, it remains only to prove the lemma when k=0 since",
                                "#(Q,k)=pk(pn\u22122k\u22121\u2212pn\u2212k\u22121+pm\u2212k)=pn\u2212k\u22121\u2212pn\u2212m\u22121+pm.\u2003\u2003(XIV.7)",
                                "A definite quadratic space is one in which w\u00b7w=0 implies w=0. (A definite space corresponds to a nontrivial element of the Witt group; for example, a one-dimensional space is always definite; If \u03b1 is not a square, then the symmetric form diag(1, \u2212\u03b1) is definite.) To count all null vectors, one can work in a basis such that the n-by-n symmetric matrix is",
                                "\u039b=\u039b\u2032\u2295\u039b2m\u2003\u2003(XIV.8)",
                                "where \u039b\u2032 definite, and",
                                "\\(\\Lambda_{2\ue89em} = {\\frac{1}{2}\ue89e{\\begin{pmatrix}\n0 & 1 \\\\\n1 & 0\n\\end{pmatrix} \\otimes I_{m}}}\\)",
                                "is an orthogonal sum of m hyperbolic planes. In this basis, let one write any vector x as x\u2032\u2295(u, u\u2032). The nullity is then expressed by a quadratic equation of coordinates",
                                "x\u2032\u00b7x\u2032+u\u00b7u\u2032=0.\u2003\u2003(XIV.9)",
                                "The solutions of this equation are divided into two classes: x\u2032\u00b7x\u2032=0 or x\u2032\u00b7x\u2032\u22600. In the former case, x\u2032=0 and u\u00b7u\u2032=0. Given arbitrary u there is u\u2032 such that this equation holds. The number of solutions is pm+(pm\u22121)pm\u22121. In the latter case, one has u\u22600, and u\u00b7u\u2032=c=\u2212x\u2032\u00b7x\u2032\u22600 is a inhomogeneous equation in u\u2032, whose solution always exists. For any given nonzero c, there are thus (pm\u22121)pm\u22121 choices of (u, u\u2032). x\u2032 can be any nonzero vector, so there are pn\u22122m\u22121 choices. In sum, the number of null vectors in an n-dimensional quadratic space Q over p is",
                                "#(Q,0)=pm+(pm\u22121)pm\u22121+(pn\u22122m\u22121)(pm\u22121)pm\u22121=pn\u22121\u2212pn\u2212m\u22121+pm.\u2003\u2003(XIV.10)\n\n\n- - \u25a1",
                                "**Lemma 13.**",
                                "Let w\u22a5={right arrow over (1)}\u2208pn be the all-1 vector where n is a multiple of p\u22653. Assume c<(n\u22122)/2, and let w2, . . . , wc be null vectors of pn chosen inductively such that wj is chosen uniformly at random from (pn, Vj\u22121) where Vj\u22121=span(w1, . . . , wj\u22121). Let M be a c-by-n matrix M with rows wj.",
                                "Consider a fixed n-component vector v, with v\u22600 and v\u2260{right arrow over (1)}. The probability that Mv=0 is bounded from above by",
                                "\\(\\begin{matrix}\n{{20\ue89e\\left( \\frac{3}{5} \\right)^{n - c}} + {\\left( \\frac{11}{15} \\right)^{c - 1}.}} & \\left( {{XIV}\ue89e{.11}} \\right)\n\\end{matrix}\\)",
                                "**Proof.**",
                                "The desired probability is estimated by a union bound, considering separately the event that v\u2208Vc\u22a5 and v\u2209Vc, and the event that v\u2208Vc\u22a5 and v\u2208Vc. The second event is possible only if v\u00b7v=0. By the classification of symmetric forms, a maximal null space of pn has dimension m such that n\u22122\u22642m\u2264n. The assumption that c<(n\u22122)/2 implies that",
                                "kj:=dimVj\u2264j\u2264c\u2264m\u22121.\u2003\u2003(XIV.12)",
                                "Consider the first event, assuming v\u00b7v=0. Let j>1. Then",
                                "\\(\\begin{matrix}\n{{\\Pr \ue8a0\\left\\lbrack {v \\in {V_{j}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89ev} \\notin V_{j}} \\middle| {v \\in {V_{j - 1}^{\\bot}\ue89e\\backslash \ue89eV_{j - 1}}} \\right\\rbrack} \\leq \\frac{\\zeta \ue8a0\\left( {n,m,{k_{j - 1} + 1}} \\right)}{\\zeta \ue8a0\\left( {n,m,k_{j - 1}} \\right)} \\leq \\frac{p}{{2\ue89ep} - 1} \\leq \\frac{3}{5}} & \\left( {{XIV}\ue89e{.13}} \\right)\n\\end{matrix}\\)",
                                "because wj has to be orthogonal to span(v)+Vj\u22121, which is null and is a proper superset of Vj\u22121. Thus, for any 1,",
                                "\\(\\begin{matrix}\n{{\\Pr \ue8a0\\left\\lbrack {v \\in {V_{t}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89ev} \\notin V_{t}} \\right\\rbrack} = {{{\\Pr \ue8a0\\left\\lbrack {v \\in {V_{1}^{\\bot}\ue89e\\backslash \ue89eV_{1}}} \\right\\rbrack}\ue89e{\\prod\\limits_{j = 2}^{t}\ue89e{\\Pr \ue8a0\\left\\lbrack {v \\in {V_{j}^{\\bot}\ue89e\\backslash \ue89eV_{j}}} \\middle| {v \\in {V_{j - 1}^{\\bot}\ue89e\\backslash \ue89eV_{j - 1}}} \\right\\rbrack}}} \\leq {\\prod\\limits_{j = 2}^{t}\ue89e\\frac{\\zeta \ue8a0\\left( {n,m,{k_{j - 1} + 1}} \\right)}{\\zeta \ue8a0\\left( {n,m,k_{j - 1}} \\right)}} \\leq {\\left( \\frac{3}{5} \\right)^{t - 1}.}}} & \\left( {{XIV}\ue89e{.14}} \\right)\n\\end{matrix}\\)",
                                "For t=c, one finds in particular that",
                                "Pr[v\u2208Vc\u22a5 and v\u2209Vc]\u2264(\u2157)c\u22121.\u2003\u2003(XIV.15)",
                                "Now assume v\u00b7v\u22600. The event that v\u2208Vj\u22a5 happens only if wj is chosen from v\u22a5. The decomposition is bound as follows: Pr[v\u2208Vc\u22a5]=Pr[v\u2208V1\u22a5]\u03a0j=2cPr[v\u2208Vj\u22a5|v\u2208Vj\u22121\u22a5]. The first term is bounded by 1 trivially. For other factors, it is observed that the dimension of v\u22a5 is n\u22121, and a maximal null subspace in v\u22a5 has dimension m\u2032\u2264m. Under the conditioning v\u2208Vj\u22121\u22a5, the null space Vj\u22121 is a subspace of v\u22a5, and #(v\u22a5, Vj\u22121)=\u03b6(n\u22121, m\u2032, kj\u22121)\u2264\u03b6(n\u22121, m, kj\u22121). Hence,",
                                "\\(\\begin{matrix}\n{{\\Pr \ue8a0\\left\\lbrack {v \\in V_{c}^{\\bot}} \\right\\rbrack} = {{{\\Pr \ue8a0\\left\\lbrack {v \\in V_{1}^{\\bot}} \\right\\rbrack}\ue89e{\\prod\\limits_{j = 2}^{c}\ue89e{\\Pr \ue8a0\\left\\lbrack {v \\in V_{j}^{\\bot}} \\middle| {v \\in V_{j - 1}^{\\bot}} \\right\\rbrack}}} \\leq {\\prod\\limits_{j = 2}^{c}\ue89e\\frac{\\zeta \ue8a0\\left( {{n - 1},m,k_{j - 1}} \\right)}{\\zeta \ue8a0\\left( {n,m,k_{j - 1}} \\right)}} \\leq \\left( \\frac{p^{2} + p - 1}{{2\ue89ep^{2}} - p} \\right)^{c - 1} \\leq \\left( \\frac{11}{15} \\right)^{c - 1}}} & \\left( {{XIV}\ue89e{.16}} \\right)\n\\end{matrix}\\)",
                                "where in the second inequality, the assumption that kj\u22121\u2264c<(n\u22122)/2\u2264m was used.",
                                "Turn now to the second event and assume v\u00b7v=0. Note that if v\u2208Vc, there is a least j such that v\u2208Vj. So,",
                                "\\(\\begin{matrix}\n{{\\Pr \ue8a0\\left\\lbrack {v \\in {V_{c}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89ev} \\in V_{c}} \\right\\rbrack} \\leq {\\prod\\limits_{j = 2}^{c}\ue89e{{\\Pr \ue8a0\\left\\lbrack {v \\in {V_{j}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89ev} \\in {V_{j - 1}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89ev} \\notin V_{j - 1}} \\right\\rbrack}.}}} & \\left( {{XIV}\ue89e{.17}} \\right)\n\\end{matrix}\\)",
                                "**One has**",
                                "\\(\\begin{matrix}\n{{{\\Pr \ue8a0\\left\\lbrack {v \\in {V_{j}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89ev} \\in {V_{j - 1}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89ev} \\notin V_{j - 1}} \\right\\rbrack} = {{{\\Pr \ue8a0\\left\\lbrack {v \\in {V_{j - 1}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{11mu} \ue89ev} \\notin V_{j - 1}} \\right\\rbrack} \\cdot {\\Pr \ue8a0\\left\\lbrack {v \\in V_{j}} \\middle| {v \\in {V_{j - 1}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89ev} \\notin V_{j - 1}} \\right\\rbrack}} \\leq {\\left( \\frac{3}{5} \\right)^{j - 2}\ue89e{\\Pr \ue8a0\\left\\lbrack {v \\in {V_{j - 1}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89ev} \\notin V_{j - 1}} \\right\\rbrack}}}},} & \\left( {{XIV}\ue89e{.18}} \\right)\n\\end{matrix}\\)",
                                "where Eq. (XIV.14) was used. The second factor is bounded as",
                                "\\(\\begin{matrix}\n{{\\Pr \ue8a0\\left\\lbrack {v \\in V_{j}} \\middle| {v \\in {V_{j - 1}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89ev} \\notin V_{j - 1}} \\right\\rbrack} \\leq \\frac{p^{1 + k_{j - 1}}}{\\zeta \ue8a0\\left( {n,m,k_{j - 1}} \\right)} < \\frac{3}{2\ue89ep^{n - {2\ue89ej}}}} & \\left( {{XIV}\ue89e{.19}} \\right)\n\\end{matrix}\\)",
                                "because wj belongs to span(v)+Vj\u22121. Hence, Pr[v\u2208Vj and v\u2208Vj\u22121\u22a5 and v\u2209Vj\u22121]\u22645(\u2157)n\u2212j. So by Eq. (XIV.17),",
                                "\\(\\begin{matrix}\n{{\\Pr \ue8a0\\left\\lbrack {v \\in {V_{c}^{\\bot}\ue89e\\mspace{14mu} \ue89e{and}\ue89e\\mspace{14mu} \ue89ev} \\in V_{c}} \\right\\rbrack} \\leq {\\sum\\limits_{j = 2}^{c}\ue89e{5\ue89e\\left( \\frac{3}{5} \\right)^{n - j}}} < {20\ue89e{\\left( \\frac{3}{5} \\right)^{n - c}.}}} & \\left( {{XIV}\ue89e{.20}} \\right)\n\\end{matrix}\\)",
                                "Summing the probabilities of (XIV.16) and (XIV.20), the proof is complete. \u25a1",
                                "**XV. Example Computing Environments**",
                                "FIG. 1 illustrates a generalized example of a suitable computing environment 100 in which several of the described embodiments can be implemented. The computing environment 100 is not intended to suggest any limitation as to the scope of use or functionality of the disclosed technology, as the techniques and tools described herein can be implemented in diverse general-purpose or special-purpose environments that have computing hardware.",
                                "With reference to FIG. 1, the computing environment 100 includes at least one processing device 110 and memory 120. In FIG. 1, this most basic configuration 130 is included within a dashed line. The processing device 110 (e.g., a CPU or microprocessor) executes computer-executable instructions. In a multi-processing system, multiple processing devices execute computer-executable instructions to increase processing power. The memory 120 may be volatile memory (e.g., registers, cache. RAM, DRAM, SRAM), non-volatile memory (e.g., ROM, EEPROM, flash memory), or some combination of the two. The memory 120 stores software 180 implementing tools for implementing the quantum circuit (e.g., the Magic state distillation circuits and associated techniques) as described herein.",
                                "The computing environment can have additional features. For example, the computing environment 100) includes storage 140, one or more input devices 150, one or more output devices 160, and one or more communication connections 170. An interconnection mechanism (not shown), such as a bus, controller, or network, interconnects the components of the computing environment 100. Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment 100, and coordinates activities of the components of the computing environment 100.",
                                "The storage 140 can be removable or non-removable, and includes one or more magnetic disks (e.g., hard drives), solid state drives (e.g., flash drives), magnetic tapes or cassettes, CD-ROMs, DVDs, or any other tangible non-volatile storage medium which can be used to store information and which can be accessed within the computing environment 100. The storage 140 can also store instructions for the software 180 implementing the quantum circuits and techniques described herein.",
                                "The input device(s) 150 can be a touch input device such as a keyboard, touchscreen, mouse, pen, trackball, a voice input, device, a scanning device, or another device that provides input to the computing environment 100. The output device(s) 160 can be a display device (e.g., a computer monitor, laptop display, smartphone display, tablet display, netbook display, or touchscreen), printer, speaker, or another device that provides output from the computing environment 100.",
                                "The communication connection(s) 170 enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer-executable instructions or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired or wireless techniques implemented with an electrical, optical, RF, infrared, acoustic, or other carrier.",
                                "As noted, the various methods for generating the disclosed circuits (e.g., for compiling/synthesizing the circuits) can be described in the general context of computer-readable instructions stored on one or more computer-readable media. Computer-readable media are any available media (e.g., memory or storage device) that can be accessed within or by a computing environment. Computer-readable media include tangible computer-readable memory or storage devices, such as memory 120 and/or storage 140, and do not include propagating carrier waves or signals per se (tangible computer-readable memory or storage devices do not include propagating carrier waves or signals per se).",
                                "Various embodiments of the methods disclosed herein can also be described in the general context of computer-executable instructions (such as those included in program modules) being executed in a computing environment by a processor. Generally, program modules include routines, programs, libraries, objects, classes, components, data structures, and so on, that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments.",
                                "Computer-executable instructions for program modules may be executed within a local or distributed computing environment.",
                                "An example of a possible network topology 200 (e.g., a client-server network) for implementing a system according to the disclosed technology is depicted in FIG. 2. Networked computing device 220 can be, for example, a computer running a browser or other software connected to a network 212. The computing device 220 can have a computer architecture as shown in FIG. 1 and discussed above. The computing device 220 is not limited to a traditional personal computer but can comprise other computing hardware configured to connect to and communicate with a network 212 (e.g., smart phones, laptop computers, tablet computers, or other mobile computing devices, servers, network devices, dedicated devices, and the like). In the illustrated embodiment, the computing device 220 is configured to communicate with a computing device 230 (e.g., a remote server, such as a server in a cloud computing environment) via a network 212. In the illustrated embodiment, the computing device 220 is configured to transmit input data to the computing device 230, and the computing device 230 is configured to implement any of the quantum circuits disclosed herein (e.g., compiling/synthesizing the quantum circuit from a higher-level circuit description) and outputting results to the computing device 220. Any of the data received from the computing device 2930 can be stored or displayed on the computing device 2920 (e.g., displayed as data on a graphical user interface or web page at the computing devices 220). In the illustrated embodiment, the illustrated network 212 can be implemented as a Local Area Network (LAN) using wired networking (e.g., the Ethernet IEEE standard 802.3 or other appropriate standard) or wireless networking (e.g. one of the IEEE standards 802.11a, 802.11b, 802.11g, or 802.11n or other appropriate standard).",
                                "Alternatively, at least part of the network 212 can be the Internet or a similar public network and operate using an appropriate protocol (e.g., the HTTP protocol).",
                                "Another example of a possible network topology 300 (e.g., a distributed computing environment) for implementing a system according to the disclosed technology is depicted in FIG. 3. Networked computing device 320 can be, for example, a computer running a browser or other software connected to a network 312. The computing device 320 can have a computer architecture as shown in FIG. 1 and discussed above. In the illustrated embodiment, the computing device 320 is configured to communicate with multiple computing devices 330, 331, 332 (e.g., remote servers or other distributed computing devices, such as one or more servers in a cloud computing environment) via the network 312. In the illustrated embodiment, each of the computing devices 330, 331, 332 in the computing environment 300 is used to perform at least a portion of any of the quantum circuits disclosed herein. In other words, the computing devices 330, 331, 332 form a distributed computing environment in which the quantum circuit implementation process is shared across multiple computing devices. The computing device 320 is configured to transmit input data to the computing devices 330, 331, 332, which are configured to distributively implement any of the quantum circuit processes disclosed herein (e.g., compiling/synthesizing the quantum circuit from a higher-level circuit description) and to provide results to the computing device 320. Any of the data received from the computing devices 330, 331, 332 can be stored or displayed on the computing device 320 (e.g., displayed as data on a graphical user interface or web page at, the computing devices 320). The illustrated network 312 can be any of the networks discussed above with respect to FIG. 2.",
                                "With reference to FIG. 4, an exemplary system for implementing embodiments of the disclosed technology includes computing environment 400. In computing environment 400, a compiled quantum computer circuit description, including a circuit description for one or more magic state distillation circuits as disclosed herein, can be used to program (or configure) one or more quantum processing units such that the quantum processing unit(s) implement the circuit described by the quantum computer circuit description. The quantum computer circuit description can implement any of the magic state distillation circuits discussed herein.",
                                "The environment 300 includes one or more quantum processing units 302 and one or more readout device(s) 308. The quantum processing unit(s) execute quantum circuits that are precompiled and described by the quantum computer circuit description. The quantum processing unit(s) can be one or more of, but are not limited to: (a) a superconducting quantum computer; (b) an ion trap quantum computer; (c) a fault-tolerant architecture for quantum computing; and/or (d) a topological quantum architecture (e.g., a topological quantum computing device using Majorana zero modes). The precompiled quantum circuits, including any of the disclosed circuits comprising quantum Boltzmann machines, can be sent into (or otherwise applied to) the quantum processing unit(s) via control lines 306 at the control of quantum processor controller 320. The quantum processor controller (QP controller) 320 can operate in conjunction with a classical processor 310 (e.g., having an architecture as described above with respect to FIG. 1) to implement the desired quantum computing process. Further, the classical processor 310 can be programmed to implement any of the disclosed Boltzmann machine training methods.",
                                "In the illustrated example, the QP controller 320 further implements the desired quantum computing process via one or more QP subcontrollers 304 that are specially adapted to control a corresponding one of the quantum processor(s) 302. For instance, in one example, the quantum controller 320 facilitates implementation of the compiled quantum circuit by sending instructions to one or more memories (e.g., lower-temperature memories), which then pass the instructions to low-temperature control unit(s) (e.g., QP subcontroller(s) 304) that transmit, for instance, pulse sequences representing the gates to the quantum processing unit(s) 302 for implementation. In other examples, the QP controller(s) 320 and QP subcontroller(s) 304 operate to provide appropriate magnetic fields, encoded operations, or other such control signals to the quantum processor(s) to implement the operations of the compiled quantum computer circuit description. The quantum controller(s) can further interact with readout devices 308 to help control and implement the desired quantum computing process (e.g., by reading or measuring out data results from the quantum processing units once available, etc.)",
                                "With reference to FIG. 4, compilation is the process of translating a high-level description of a quantum algorithm into a quantum computer circuit description comprising a sequence of quantum operations or gates, which can include any of the magic state distillation circuits as disclosed herein. The compilation can be performed by a compiler 322 using a classical processor 310 (e.g., as shown in FIG. 1) of the environment 300 which loads the high-level description from memory or storage devices 312 and stores the resulting quantum computer circuit description in the memory or storage devices 312.",
                                "In other embodiments, compilation can be performed remotely by a remote computer 300 (e.g., a computer having a computing environment as described above with respect to FIG. 1) which stores the resulting quantum computer circuit description in one or more memory or storage devices 362 and transmits the quantum computer circuit description to the computing environment 300 for implementation in the quantum processing unit(s) 302. Still further, the remote computer 300 can store the high-level description in the memory or storage devices 362 and transmit the high-level description to the computing environment 300 for compilation and use with the quantum processor(s). In any of these scenarios, results from the computation performed by the quantum processor(s) can be communicated to the remote computer after and/or during the computation process. Still further, the remote computer can communicate with the QP controller(s) 320 such that the quantum computing process (including any compilation and/or QP processor control procedures) can be remotely controlled by the remote computer 360. In general, the remote computer 360 communicates with the QP controller(s) 320 and/or compiler/synthesizer 322 via communication connections 350.",
                                "In particular embodiments, the environment 300 can be a cloud computing environment, which provides the quantum processing resources of the environment 300 to one or more remote computers (such as remote computer 360) over a suitable network (which can include the internet).",
                                "**XVI. General Embodiments**",
                                "This section describes several example embodiments for implementing embodiments of the disclosed technology. The disclosed tools and techniques are not to be construed as limiting in any way, as an one or more of the illustrated method acts can be performed alone or in various other combinations and subcombinations with one another. Further, any one or more of the disclosed method acts can be performed with one or more other method acts disclosed herein.",
                                "FIG. 10 is a flowchart of an example method 1000 for distilling magic states in a quantum computing device in accordance with embodiments of the disclosed technology. The illustrated embodiment should not be construed as limiting, as the disclosed method acts can, in some cases, be performed alone, in different orders, or at least partially simultaneously with one another. Further, any of the disclosed methods or method acts can be performed with any other methods or method acts disclosed herein.",
                                "In some embodiments, the methods below are performed (at least in part) by a classical computer configured to communicate with and control a quantum computer. Still further, the method acts can be embodied as computer-executable instructions which when executed by a computer cause the computer to perform the methods.",
                                "At 1010, an inner code is applied (e.g., to qubits or qudits in a quantum computing device). In the illustrated embodiment, the inner code comprises a weakly self-dual error correcting code to implement control-Swap operations on the plurality of qubits or qudits.",
                                "At 1012, the control-Swap operations are used to test properties of the magic states on the plurality of qubits or quidits so that a distance of the code scales proportional to the number of logical qubits or quidits.",
                                "In some embodiments, the method suppresses errors exhibited by magic states by a power (e.g., a selected or chosen target power). For example, at 1014, an outer code is applied (e.g., to the qubits or qudits in the quantum computing device). In the illustrated embodiment, the outer code comprises an error-correcting code with a sensitivity selected to test the properties of the magic states such that measurement errors are also suppressed by the power. The power can, for example, be selected or chosen by a designer of the quantum circuit and can choose the power based on a variety of factors, including the size of the quantum circuit to be implemented, the desired accuracy of the result to be produced by the circuit, and the available quantum circuit overhead to implement the error-correcting code.",
                                "In some embodiments, the inner code uses 16 physical qubits, obtains 6 logical qubits, and has a code distance of 4. In certain embodiments, the inner code uses 30 physical qubits, obtains 6 logical qubits, and has a code distance of 6. In some embodiments, the inner code uses 64 physical qubits, obtains 12 logical qubits, and has a code distance of 8.",
                                "In further embodiments, the magic states are implemented by T-gates. In some embodiments, the quantum computing device is a topological quantum computer. In certain embodiments, the error correcting codes are Calderbank-Shor-Steane codes that implement controlled Hadanmards for the inner code and reduce circuit depth. In some embodiments, the inner code and the outer code are implemented by a single concatenated circuit (e.g., implemented by the quantum computing device and configured to communicate with/control the plurality of qubits or qudits).",
                                "In some embodiments, at least two of the magic states are input at different stages from one another.",
                                "In certain embodiments, the inner code implements controlled-Hadamard operations, and the number of physical qubits or qudits used is odd. For example, in certain implementations, the inner code uses 17 physical qubits, obtains 1 logical qubits, and has a code distance of 5. In other implementations, the inner code uses 21 physical qubits, obtains 3 logical qubits, and has a code distance of 5.",
                                "Relatedly, circuits configured to distill magic states in a quantum computing device (e.g., circuits operating within or in concert with the quantum computing device) are also disclosed. Some embodiments comprise: quantum circuit elements configured to implement an inner code and an outer code, the inner code providing a weakly self-dual error correcting code to implement control-Swap operations on a plurality of logical qubits or qudits and provide error suppression to a target power (e.g., a selected or chosen power), the outer code providing an error-correcting code with a sensitivity selected to test the properties of the magic states such that measurement errors are also suppressed by the target power. The target power can, for example, be selected or chosen by a designer of the quantum circuit and can choose the power based on a variety of factors, including the size of the quantum circuit to be implemented, the desired accuracy of the result to be produced by the circuit, and the available quantum circuit overhead to implement the error-correcting code.",
                                "In some embodiments, the inner code uses 16 physical qubits, obtains 6 logical qubits, and has a code distance of 4. In further embodiments, the inner code uses 30 physical qubits, obtains 6 logical qubits, and has a code distance of 6. In some embodiments, the inner code uses 64 physical qubits, obtains 12 logical qubits, and has a code distance of 8.",
                                "In certain embodiments, the circuit comprises a plurality of T-gates configured to implement the magic states. In some embodiments, the circuit is part of a topologically protected quantum computer using Majorana zero modes to implement qubits or qudits.",
                                "In further embodiments, the error correcting codes are Calderbank-Shor-Steane codes that implement controlled Hadamards for the inner code and reduce circuit depth. In some embodiments, the circuit is concatenation-free. In certain embodiments, the circuit is configured to input at least two of the magic states at different circuit stages from one another.",
                                "In some embodiments, the inner code implements controlled-Hadamnard operations, and the number of physical qubits or qudits used is odd. For example, the inner code uses 17 physical qubits, obtains 1 logical qubits, and has a code distance of 5. In other examples, the inner code uses 21 physical qubits, obtains 3 logical qubits, and has a code distance of 5.",
                                "In further embodiments, the outer code gives seventh order reduction in error when used with an inner code of distance 7 or more. And, in some implementations, the outer code is obtained from a Tanner graph of girth 6 or more and the outer code has distance 7 or more. Such outer codes may have each qubit participating in exactly 3 checks or may have a small number of additional checks to give the needed distance with a smaller code.",
                                "FIG. 11 is a flowchart of an example method 1100 for distilling magic states in a quantum computing device in accordance with embodiments of the disclosed technology. The illustrated embodiment should not be construed as limiting, as the disclosed method acts can, in some cases, be performed alone, in different orders, or at least partially simultaneously with one another. Further, any of the disclosed methods or method acts can be performed with any other methods or method acts disclosed herein.",
                                "In some embodiments, the methods below are performed (at least in part) by a classical computer configured to communicate with and control a quantum computer. Still further, the method acts can be embodied as computer-executable instructions which when executed by a computer cause the computer to perform the methods.",
                                "At 1110, applying an inner code and outer code to distill a plurality of the magic states in the quantum computing device, and thereby possible error in the magic states. In the illustrated embodiment, the inner code comprises Bose-Chaudhuri-Hocquenghem (\u201cBCH\u201d) codes to implement operations on a plurality of physical qubits or quidits in the quantum computing device.",
                                "In some embodiments, the outer codes are determined by arranging the qubits or qudits in a two dimensional or three dimensional code. In certain embodiments, the inner code further comprises error correcting codes.",
                                "Relatedly, circuits configured to distill magic states in a quantum computing device (e.g., circuits operating within or in concert, with the quantum computing device) are also disclosed. Some embodiments comprise: quantum circuit elements configured to implement an inner code and an outer code for suppressing error in physical qubits or qubits that implement the magic states, the quantum circuit elements for the inner code being configured to apply Bose-Chaudhuri-Hocquenghem (\u201cBCH\u201d) codes on one or more of the physical qubits or quidits of the quantum computing device.",
                                "In some embodiments, the outer codes are determined by representing the qubits or qudits as arranged in a two dimensional or three dimensional grid. In certain embodiments, the circuit is further configured to perform an error correction procedure if the inner code detects an error syndrome that can be caused by a small number of errors (e.g., one or two errors).",
                                "**XVII. Concluding Remarks**",
                                "Having described and illustrated the principles of the disclosed technology with reference to the illustrated embodiments, it will be recognized that the illustrated embodiments can be modified in arrangement and detail without departing from such principles."
                            ],
                            "subsections": [],
                            "outline_long": [
                                "discuss distillation protocols",
                                "motivate small number of qubits",
                                "compare with other protocols",
                                "define trivial way to define new protocol",
                                "explain T-gate circuit depth",
                                "summarize space and time efficiency",
                                "introduce example small inner and outer codes",
                                "describe [[4,2,2]] inner code",
                                "describe [[16,6,4]] inner code",
                                "describe [[7,1,3]] inner code",
                                "describe [[17,1,5]] inner code",
                                "describe [[21,3,5]] and [[23,1,7]] inner codes",
                                "explain puncturing of codes",
                                "describe [[20,2,6]] code",
                                "introduce other inner codes",
                                "describe Petersen graph code",
                                "explain proof of Lemma 9",
                                "introduce example circuits",
                                "describe FIG. 6",
                                "describe FIG. 7",
                                "describe FIG. 8",
                                "describe FIG. 9",
                                "discuss coincidence among protocols",
                                "explain recursive formula",
                                "introduce qudits",
                                "define magic states",
                                "use magic states for transformation",
                                "derive transformation equation",
                                "explain phase factor correction",
                                "discuss interconvertibility of T gates",
                                "introduce inner codes",
                                "define stabilizer code",
                                "discuss logical operators",
                                "define transversal gate",
                                "implement measurement of stabilizer",
                                "deduce action of transversal gate",
                                "implement controlled Clifford on logical qudits",
                                "discuss implementation of C(SmX)",
                                "consider equation and solution for C(SmX)",
                                "implement simultaneous C(SmX) on all logical qudits",
                                "discuss generalization to matrices over a field p",
                                "introduce alternative construction from Reed-Muller codes",
                                "discuss rate of resulting weakly self-dual code",
                                "introduce outer codes",
                                "discuss parity check matrix for outer code",
                                "introduce check matrix from adjacency matrix of biregular graph",
                                "introduce symmetric forms over finite fields",
                                "classify quadratic spaces over fields of odd characteristic",
                                "discuss Witt group of the field",
                                "discuss quadratic spaces",
                                "classify quadratic spaces up to hyperbolic planes",
                                "prove diag(1, 1) is not hyperbolic",
                                "show diag(1, 1) is congruent to diag(-1, -1)",
                                "classify quadratic spaces by determinant of form",
                                "state Lemma 10 about isometry of subspaces",
                                "state Lemma 11 about orthogonal sum of null subspace and hyperbolic subspace",
                                "prove Lemma 11",
                                "state Lemma 12 about maximal null subspaces",
                                "prove Lemma 12",
                                "count null vectors in quadratic space",
                                "state Lemma 13 about probability of null vectors",
                                "prove Lemma 13",
                                "estimate probability of Mv=0",
                                "bound probability of v in Vc\u22a5 and v not in Vc",
                                "bound probability of v in Vc\u22a5",
                                "bound probability of v in Vc and v in Vc\u22a5",
                                "conclude proof of Lemma 13",
                                "introduce discussion",
                                "derive probability equation",
                                "bound probability factor",
                                "combine probabilities",
                                "illustrate computing environment",
                                "describe processing device",
                                "describe memory",
                                "describe software",
                                "describe storage",
                                "describe input devices",
                                "describe output devices",
                                "describe communication connections",
                                "describe computer-readable media",
                                "describe program modules",
                                "describe local or distributed computing environment",
                                "illustrate network topology",
                                "describe client-server network",
                                "describe distributed computing environment",
                                "illustrate system for implementing embodiments",
                                "describe quantum processing units",
                                "describe readout devices",
                                "describe quantum processor controller",
                                "describe classical processor",
                                "describe compilation process",
                                "describe remote computer",
                                "describe cloud computing environment",
                                "introduce general embodiments",
                                "describe method for distilling magic states",
                                "apply inner code",
                                "use control-Swap operations",
                                "apply outer code",
                                "suppress errors",
                                "describe inner code properties",
                                "describe outer code properties",
                                "describe error correcting codes",
                                "describe magic state implementation",
                                "describe quantum computing device",
                                "describe concatenated circuit",
                                "describe inputting magic states",
                                "describe controlled-Hadamard operations",
                                "illustrate method for distilling magic states",
                                "apply inner and outer codes",
                                "describe inner code properties",
                                "describe outer code properties",
                                "describe error correcting codes",
                                "describe magic state implementation",
                                "describe quantum computing device",
                                "describe concatenated circuit",
                                "conclude remarks"
                            ],
                            "num_characters": 58871,
                            "outline_medium": [
                                "motivate distillation protocols",
                                "describe advantages of protocols",
                                "compare with other protocols",
                                "discuss asymptotics of overhead",
                                "describe space and time efficiency",
                                "introduce example small inner and outer codes",
                                "define inner codes",
                                "define outer codes",
                                "describe example circuits",
                                "discuss coincidence among protocols",
                                "extend to qudits",
                                "generalize odd codes",
                                "define magic states",
                                "use magic states for transformation",
                                "derive phase factors",
                                "interconvert T gates",
                                "introduce inner codes",
                                "define logical operators",
                                "implement transversal gate",
                                "measure stabilizer",
                                "implement controlled Clifford",
                                "introduce outer codes",
                                "choose parity check matrix",
                                "classify symmetric forms over finite fields",
                                "classify quadratic spaces up to hyperbolic planes",
                                "prove diag(1, 1) is not hyperbolic",
                                "show existence of solution to a2+b2+1=0",
                                "state and prove lemmas about quadratic spaces",
                                "prove first claim of lemma 12",
                                "prove second claim of lemma 12",
                                "count null vectors in a quadratic space",
                                "state and prove lemma 13",
                                "bound probability that Mv=0",
                                "introduce discussion",
                                "derive probability bounds",
                                "bound probability of v in Vc and v in Vc\u22a5",
                                "sum probabilities to complete proof",
                                "introduce example computing environment",
                                "describe processing device and memory",
                                "describe storage and input/output devices",
                                "describe communication connections",
                                "describe software implementation",
                                "describe network topology for client-server network",
                                "describe network topology for distributed computing environment",
                                "introduce system for implementing quantum circuits",
                                "describe quantum processing units and readout devices",
                                "describe quantum processor controller and classical processor",
                                "describe compilation process",
                                "introduce general embodiments",
                                "describe method for distilling magic states",
                                "describe inner code and outer code",
                                "describe error suppression",
                                "describe circuit implementation",
                                "describe alternative embodiments",
                                "introduce second method for distilling magic states",
                                "describe inner code and outer code",
                                "conclude remarks"
                            ],
                            "outline_short": [
                                "motivate distillation protocols",
                                "discuss advantages of protocols",
                                "describe asymptotics of overhead",
                                "explain space and time efficiency",
                                "discuss limitations of other protocols",
                                "highlight benefits of disclosed protocols",
                                "motivate magic states",
                                "application of magic states",
                                "define inner codes",
                                "implement measurement of stabilizer",
                                "define outer codes",
                                "classify symmetric forms over finite fields",
                                "classify quadratic spaces",
                                "prove lemmas about quadratic spaces",
                                "count null vectors in quadratic spaces",
                                "bound probability of null vectors",
                                "introduce mathematical derivation",
                                "bound probability of error",
                                "describe computing environment",
                                "illustrate network topology",
                                "describe system for implementing quantum circuits",
                                "compile quantum computer circuit description",
                                "introduce general embodiments",
                                "describe method for distilling magic states",
                                "illustrate flowchart for distilling magic states",
                                "describe circuits for distilling magic states",
                                "illustrate flowchart for distilling magic states",
                                "conclude remarks"
                            ]
                        }
                    ],
                    "outline_long": [],
                    "num_characters": 0,
                    "outline_medium": [],
                    "outline_short": []
                }
            ],
            "outline_long": [],
            "num_characters": 0,
            "outline_medium": [],
            "outline_short": []
        }
    ],
    "claims": [
        "1. A method for distilling magic states in a topological quantum computing device, comprising:\napplying an inner code comprising a weakly self-dual error correcting code to implement control-Swap operations on a plurality of qubits or qudits; and\nusing the control-Swap operations to test properties of the magic states on the plurality of qubits or qudit so that a distance of the code scales proportional to the number of logical qubits or qudits.",
        "2. The method of claim 1, wherein the method suppresses errors exhibited by magic sates by a power, and wherein the method further comprises applying an outer code comprising an error-correcting code with a sensitivity selected to test the properties of the magic states such that measurement errors are also suppressed by the power.",
        "3. The method of claim 1, wherein the inner code (a) uses 16 physical qubits, obtains 6 logical qubits, and has a code distance of 4; (b) uses 30 physical qubits, obtains 6 logical qubits, and has a code distance of 6; or (c) uses 64 physical qubits, obtains 12 logical qubits, and has a code distance of 8.",
        "4. The method of claim 1, wherein the magic states are implemented by T-gates.",
        "5. The method of claim 1, wherein the error correcting codes are Calderbank-Shor-Steane codes that implement controlled Hadamards for the inner code and reduce circuit depth.",
        "6. The method of claim 1, wherein at least two of the magic states are input at different stages from one another.",
        "7. The method of claim 1, wherein the inner code implements controlled-Hadamard operations, and the number of physical qubits or qudits used is odd.",
        "8. The method of claim 7, wherein (a) the inner code uses 17 physical qubits, obtains 1 logical qubits, and has a code distance of 5; or (b) the inner code uses 21 physical qubits, obtains 3 logical qubits, and has a code distance of 5.",
        "9. A circuit configured to distill magic states in a quantum computing device, comprising:\nquantum circuit elements configured to implement an inner code and an outer code, the inner code providing a weakly self-dual error correcting code to implement control-Swap operations on a plurality of logical qubits or qudits and provide error suppression to a target power,\nthe outer code providing an error-correcting code with a sensitivity selected to test the properties of the magic states such that measurement errors are also suppressed by the target power.",
        "10. The circuit of claim 9, wherein the inner code uses: (a) 16 physical qubits, obtains 6 logical qubits, and has a code distance of 4; (b) 30 physical qubits, obtains 6 logical qubits, and has a code distance of 6; or (c) 64 physical qubits, obtains 12 logical qubits, and has a code distance of 8.",
        "11. The circuit of claim 9, further comprising a plurality of T-gates configured to implement the magic states.",
        "12. The circuit of claim 9, wherein the the circuit is part of a topologically protected quantum computer using Majorana zero modes to implement qubits or qudits.",
        "13. The circuit of claim 9, wherein the error correcting codes are Calderbank-Shor-Steane codes that implement controlled Hadamards for the inner code and reduce circuit depth.",
        "14. The circuit of claim 9, wherein the circuit is concatenation-free.",
        "15. The circuit of claim 9, wherein the circuit is configured to input at least two of the magic states at different circuit stages from one another.",
        "16. The circuit of claim 9, wherein the inner code implements controlled-Hadamard operations, and the number of physical qubits or qudits used is odd.",
        "17. The circuit of claim 16, wherein: (a) the inner code uses 17 physical qubits, obtains 1 logical qubit, and has a code distance of 5; or (b) the inner code uses 21 physical qubits, obtains 3 logical qubits, and has a code distance of 5.",
        "18. The circuit of claim 9, wherein the outer code is configured to give seventh order reduction in error when used with an inner code of distance 7 or more, and where the outer code is obtained from a Tanner graph of girth 6 or more and the outer code has distance 7 or more.",
        "19. A method for distilling magic states in a quantum computing device, comprising:\napplying an inner code and couter code to distill a plurality of the magic states in the quantum computing device, and thereby possible error in the magic states,\nwherein the inner code comprises Bose-Chaudhuri-Hocquenghem (\u201cBCH\u201d) codes to implement operations on a plurality of physical qubits or quidits in the quantum computing device, and\nwherein error correction is implemented on the inner code.",
        "20. The method of claim 19, wherein the outer codes are determined by arranging the qubits or qudits in a two dimensional or three dimensional grid.",
        "21. A circuit configured to distill magic states in a quantum computing device, comprising:\nquantum circuit elements configured to implement an inner code and an outer code,\nwherein the inner code provides a weakly self-dual error correcting code to implement control-Swap operations on a plurality of logical qubits or qudits,\nwherein the outer code provides an error-correcting code, and\nwherein the inner code and the outer code are concatenated with one or more stabilizer codes.",
        "22. The circuit of claim 21, wherein the one or more stabilizer codes are different from the inner code and the outer code.",
        "23. The circuit of claim 21, wherein the concatenation results in magic states being input at different circuit stages of the circuit.",
        "24. The circuit of claim 21, wherein the inner code provides error suppression to a target power,",
        "25. The circuit of claim 24, wherein the outer code provides the error-correcting code with a sensitivity selected to test the properties of the magic states such that measurement errors are also suppressed by the target power."
    ]
}